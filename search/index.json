[{"content":"测试 而这些并不是完全重要，更加重要的问题是， 带着这些问题，我们来审视一下学生会退会。 既然如何， 对我个人而言，学生会退会不仅仅是一个重大的事件，还可能会改变我的人生。 我们不得不面对一个非常尴尬的事实，那就是， 可是，即使是这样，学生会退会的出现仍然代表了一定的意义。 学生会退会，发生了会如何，不发生又会如何。 经过上述讨论， 生活中，若学生会退会出现了，我们就不得不考虑它出现了的事实。 学生会退会，到底应该如何实现。 这样看来， 在这种困难的抉择下，本人思来想去，寝食难安。 对我个人而言，学生会退会不仅仅是一个重大的事件，还可能会改变我的人生。 就我个人来说，学生会退会对我的意义，不能不说非常重大。 莎士比亚曾经提到过，人的一生是短的，但如果卑劣地过这一生，就太长了。这似乎解答了我的疑惑。 莫扎特说过一句富有哲理的话，谁和我一样用功，谁就会和我一样成功。这启发了我， 对我个人而言，学生会退会不仅仅是一个重大的事件，还可能会改变我的人生。 学生会退会，到底应该如何实现。 一般来说， 从这个角度来看， 这种事实对本人来说意义重大，相信对这个世界也是有一定意义的。 在这种困难的抉择下，本人思来想去，寝食难安。 了解清楚学生会退会到底是一种怎么样的存在，是解决一切问题的关键。 一般来说， 生活中，若学生会退会出现了，我们就不得不考虑它出现了的事实。 问题的关键究竟为何？ 而这些并不是完全重要，更加重要的问题是。\n奥斯特洛夫斯基曾经说过，共同的事业，共同的斗争，可以使人们产生忍受一切的力量。　带着这句话，我们还要更加慎重的审视这个问题： 一般来讲，我们都必须务必慎重的考虑考虑。 既然如此， 这种事实对本人来说意义重大，相信对这个世界也是有一定意义的。 带着这些问题，我们来审视一下学生会退会。 我认为， 我认为， 在这种困难的抉择下，本人思来想去，寝食难安。 问题的关键究竟为何？ 每个人都不得不面对这些问题。 在面对这种问题时， 要想清楚，学生会退会，到底是一种怎么样的存在。 我认为， 既然如此， 每个人都不得不面对这些问题。 在面对这种问题时， 那么， 我认为， 学生会退会因何而发生。\n引用 思念是最暖的忧伤像一双翅膀 让我停不了飞不远在过往游荡 不告而别的你 就算为了我着想 这么沉痛的呵护 我怎么能翱翔\n最暖的憂傷 - 田馥甄\n图片 1 2 3 ![Photo by Florian Klauer on Unsplash](florian-klauer-nptLmg6jqDo-unsplash.jpg) ![Photo by Luca Bravo on Unsplash](luca-bravo-alS7ewQ41M8-unsplash.jpg) ![Photo by Helena Hertz on Unsplash](helena-hertz-wWZzXlDpMog-unsplash.jpg) ![Photo by Hudai Gayiran on Unsplash](hudai-gayiran-3Od_VKcDEAA-unsplash.jpg) 相册语法来自 Typlog\n","date":"2020-09-09T00:00:00Z","permalink":"https://xiaonuoz.github.io/p/test-chinese/","title":"Chinese Test"},{"content":"\n包的导入 go语言中导入包是从 $GOPATH/src/后开始计算的，使用 /进行路径分隔。Go语言中禁止循环导入包（A导B，B导C，C导A），原因看此连接，https://www.jianshu.com/p/ea76c0d1b609，禁用虽然会导致写代码的时候麻烦点，但是可以让依赖整洁，开发高效。\n包名可以自定义，ca \u0026quot;github.com/calc\u0026quot;\n在Go语言程序执行时导入包语句会自动触发包内部 init()函数的调用。需要注意的是： init()函数没有参数也没有返回值。 init()函数在程序运行时自动被调用执行，不能在代码中主动调用它。运行自己的包也会执行自己的init函数，可以借此使用匿名包来只调用init函数，多用于自动加载配置文件等情况\niota常量自动生成 const() 括号中的为一个常量组，后一个不赋值默认与上一行值相同，因此可以只写一个iota\niota是常量的自动生成器，他每新增一行常量声明（即使新增的不是Iota）就自动累加1，只适用于常量，const出现的时候iota被置为0，如果iota第一次使用不是在const的第一行，如它在第五行，那iota第一次的值就为4\n如果c3不赋值为iota，那它的值为100（和上一行值相同）\n如果下面重新定义const内的iota，它会重置为0，也可以只写一个iota\n如果是同一行，值就都一样\n\u0026laquo;表示把1左移十位，后面接0，即kb等于1然后十个0，但这是二进制，转换为十进制就是1024，mb就是移20位，就是1024*1024，即为1M\nfor、函数别名、匿名函数、指针 go语言在switch语句中默认保留了break，但是默认是不用写的\ngolang中函数名首字母大写表示公有的，小写表示私有的\n可以由此实现多态\n如果有多个defer，遵循先进后出原则，即先定义的defer在最后输出，defer由最下面的defer语句开始向上执行直到第一个defer语句，中间如果有defer执行失败，后面的defer语句依然会继续执行，但是如果main函数中有非defer语句执行失败导致脚本退出，那就无法继续执行后面的defer语句和普通语句\ngo有自动的垃圾回收机制，我们只需要创建内存即可。\n数组 数组比较只支持等于和不等于，比较的是两个数组的每一个元素是否都一样，且比较的两个数组类型要一样\n二维数组定义则为\n当数组通过函数传递过去后，如果在主函数中没有值可以接收return的话，它就会释放，即传过去的值无论怎么修改都和主函数中的数组没关系\n如何将数组通过地址传递呢？\n首先方法的参数为(a *[5]int),这样就可以将数组的指针实参传递给方法，然后操作原数组的某一个下标值就可以使用 ( *a)[3]=22来改变原数组某个下标值，*a必须要用圆括号合成一个整体\n随机数产生 切片 array := [5]int{1,2,3,4,5} slice := array[1:3:5] 其中第一个数表示从数组的下标几开始切（下标的起点）；第二个数表示为从何处结束（下标的终点，不包括此下标），切边的长度为第二个数减去第一个数，遵循左闭右开原则；第三个数可以自己定义，最小等于第二个数（即容量等于长度），不写默认为父级（被切的那个数组或切片）的len(），容量为第三个数减去第一个数\n切片和数组的区别：\n数组[]里面的长度是一个固定的常量，设定后便不能进行修改；\na := [5]int{} (现在数组元素为5个0)\n切片,[]里面为空或者为\u0026hellip;，切片的长度可以不固定，可以通过append方法给切片末尾追加一个成员\ns := []int{} （{}中没有值，0元素，也可以像数组一样进行添加{1,2,3}）\ns=append(s,11)\n所以可以根据[]的值来判断是切片还是数组\n切片与底层数组的关系（重要）： 对一个数组或切片进行切片操作后，它并不是和数组传参一样拷贝一个新数组使用，如果在新切片中对某个值重新定义，它会反映到最初那个数组或切片中\n切片copy的作用为将一个切片复制到另一个切片，对应下标，不会改变容量，即如果参数交换，最终也是{6,6},使用copy是因为如果直接使用等号最后操作的依然是初始切片\nmap map是无序的键值对，可以通过range进行遍历，range还可以用于数组切片等\n1 2 3 4 5 6 7 8 9 10 11 map定义: m :=map[int]string{1:\u0026#34;value\u0026#34;,2:\u0026#34;value1\u0026#34;} m :=make(map[int]string,10) #10为长度 map赋值： m[\u0026#34;key\u0026#34;]=\u0026#34;value\u0026#34; map删除： delete(m,1) #删除key为1的内容 map作为函数参数传过去时属于引用传参，即在函数中修改了map的值，原值也会修改（切片也是） 结构体类型（多个变量合成一个变量） 也可以用s1.name=\u0026ldquo;mike\u0026quot;来进行部分成员初始化或者获取成员的值\n这样就可以和Java操作对象一样使用，虽然new返回的是一个内存指针，但是在结构体类型中*p2.id和p2.id指向的都是同一块内存，所以可以直接p2.id来对新申请的结构体成员赋值\n同一个结构体的不同变量可以进行赋值以及 等于和不等于的比较（它会比较两者每一个成员是否相等）\n结构体的函数传参属于值传递，它在另一个函数中值改变并不会影响到本函数的值\n引用传参才会对同一个值进行修改，如果要改为引用传参，则需要使用指针*和\u0026amp;进行指针传递\ngo语言只分为可见和不可见，当函数名、结构体、结构体成员名首字母为大写时，它为可见的，其他包可以进行调用，调用方法为包名.函数名、包名.结构体名，如果首字母为小写则只有自己包内的其他文件可以调用\n匿名字段（类似java中的继承） 对于父级的变量部分初始化首先需要子集中的名字Person，然后是修改父级中的某一个成员，需要再加一个Person\n我比较喜欢用st :=st{}先进行初始化（或者用var st student先声明），然后再用st.name（可以直接调用父级的元素）来进行赋值\n也可以用st.Person=Person{\u0026ldquo;go\u0026rdquo;,18}或者st.Person.name这种来对父级元素进行赋值\n如果父级和子级有同名成员(如name)，那么就根据就近原则，默认调用的为子级的name成员，想调用父级的name就需要用显式调用 st.Person.name来赋值\n当使用type定义了一个普通类型的别名后，用别名定义的变量和普通类型定义的变量是不同的类型，go将他们认作两个不同的类型\n方法（类似java封装） 这样就可以通过定义的结构体元素（甚至是普通类型起别名后）调用属于它的方法，只要定义了一个对应类型的变量，就可以调用这个类型的方法（就和java中new一个新对象一样），但是方法实际上依然是函数，所以如果对象是结构体或数组，它传参依然是值传参，可以通过对方法中绑定的实例设置为实例的指针来进行引用传参\n接收者类型本身不能是指针，*int之类的可以使用，但是如果在其他地方定义别名 type long *int，再将此long作为接收者的话就不能编译通过\n只要接收者类型不一样，就算方法同名也属于不同方法\n方法集 即一个变量或变量指针调用方法不受接收者类型的约束，只要接受者类型是同种自定义类型的值或者指针都可以进行调用（它在执行方法时，内部会先自动将指针转换成变量或者反之）\n方法的继承和重写 子级不仅可以继承父级的结构体成员，还会继承父级的方法（直接调用就行）\n重写就是将接收者改为子级的自定义函数，其他参数和变量名相同，go语言会采用就近原则，先调用同作用域的方法，如果同作用域没有该方法就会调用父级的，如果需要调用父级的方法，可以采用显式调用，st.Person.PrintInfo()\n方法值：保存方法的入口地址。调用方法时无需再传递接收者，因为它已经隐藏了接受者 pFunc := p.SetInfo()，下次直接pFunc()就可以直接调用\n方法表达式：通过自定义类型来显式的把接收者传递过去，pFunc := (Person).SetInfo，调用的时候就可以使用pFunc(p)来进行调用，这里p变量可以指针和变量通用，但是Person必须和方法对应，方法是指针就需要输入 *Person\n接口 接口命名习惯以er结尾，只有方法声明，没有实现也没有数据字段，但是方法是可以添加参数的\n然后在main函数中声明一个接口类型，var i Humaner,然后让 i 等于其他接收者的自定义类型，当 i 等于某个接收者类型它就会调用那个类型的同名方法，但是i等于其他接收者时，i只能调用属于i接口的方法，专属于接收者的方法以及其变量，接口都不能调用\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 //定义接口类型 type Hunmaner interface { sayhi() } //定义学生结构体类型 type student struct { name string id int } //定义学生方法 func (student) sayhi() { fmt.Println(\u0026#34;student say hi\u0026#34;) } //定义老师结构体类型 type teacher struct { name string addre string } //定义老师方法 func (teacher) sayhi() { fmt.Println(\u0026#34;teacher say hi\u0026#34;) } //实现多态，定义一个接口的方法，方法参数为接口类型，将其他接收者类型的实参传进去就可以实现调用不同方法 func whoSayhi(i Hunmaner){ i.sayhi() } func main() { //i等于学生结构体，i就可以调用学生的方法 var i Hunmaner i = student{name: \u0026#34;mike\u0026#34;} i.sayhi() //输出学生方法中的语句 //通过接口实现不同的方法 whoSayhi(student{name: \u0026#34;mike\u0026#34;}) i = teacher{name: \u0026#34;laoshi\u0026#34;} i.sayhi() //输出老师方法中的语句 } 也可以通过切片同时实现多种接收者的同名的方法\n接口也可以实现继承（使用匿名字段），当定义一个Personer变量时，它可以调用父级的sayhi()方法也可以调用自身的sing()方法\n父级可以等于子级的值，反过来则不可以（由多的向少的转换）,如 定义一个父级i，让i等于子级iPro，i=iPro是可以的，注意语法是 父级=子级，这个作用于设置子级的值，然后将子级的值赋给父级使用，父级只能使用属于父级的方法，子级的方法无法使用\n如何判断一个空接口变量中值的类型（value.(int)） ,ok模式常用于测试map的对应key是否有值，有值ok为ture，没有则为false，value用于存放为true时的值，为false时为空\n1 2 i := map[int]string{1: \u0026#34;a\u0026#34;} value, ok := i[1] 还有另外五种用法（https://zhuanlan.zhihu.com/p/129220255）\n有一种用法是判断空接口类型变量的type（切片和数组无法使用这个，因为它们两个在定义之初就已经确定了类型）\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 i := make([]interface{}, 3) i[0] = 1 i[1] = \u0026#34;str\u0026#34; i[2] = stu{\u0026#34;mike\u0026#34;} for _, deta := range i { if value, ok := deta.(int); ok == true { fmt.Println(\u0026#34;这是一个整型\u0026#34;, value) } else if value, ok := deta.(string); ok == true { fmt.Println(\u0026#34;这是一个字符串\u0026#34;, value) } else if value, ok := deta.(stu); ok == true { fmt.Println(\u0026#34;这是一个结构体类型\u0026#34;, value) } } //也可以使用switch方法，用此方法时括号中为type for _, deta := range i { switch value := deta.(type) { case int: fmt.Println(\u0026#34;这是一个整型\u0026#34;, value) case string: fmt.Println(\u0026#34;这是一个字符串\u0026#34;, value) case stu: fmt.Println(\u0026#34;这是一个结构体类型\u0026#34;, value) } } error错误接口的应用（错误抛出，不致命错误使用这种） 在工作中error常用于普通错误，这样可以自建一个错误信息抛出，error是默认值为nil （空值）\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 //要先导入包errors，import \u0026#34;errors\u0026#34; func Mydiv(a, b int) (result int, err error) { if b == 0 { err = errors.New(\u0026#34;分母不能为0\u0026#34;) } else { result = a / b } return } func main() { result, err := Mydiv(10, 0) fmt.Println(result) //值为默认值0 fmt.Println(err) //值为自己定义的错误值 } panic错误接口的调用（致命错误） 自己调用panic属于显式调用，但在数组越界，空指针引用等情况发生时，go也会抛出panic异常，因为它有自己隐式调用了默认定义的panic异常\nrecover错误接口的调用（拦截panic异常，恢复程序运行流程） 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 func test01(x int) { //使用数组下标越界生成panic异常 //recover必须和defer一起存在，recover()会拦截panic异常并返回panic的异常信息 //如果未发生panic异常，recover()会返回一个nil //程序会继续运行,但是出错的函数会跳过 defer func() { if err := recover(); err != nil { fmt.Println(err) } }() var a [10]int a[x] = 111 } func test02() { fmt.Println(\u0026#34;正常输出的一个方法\u0026#34;) } func main() { test01(11) test02() } 运行结果： runtime error: index out of range [11] with length 10 正常输出的一个方法 文本和文件处理 字符串处理 字符串操作：(需要导入包strings)\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 Contains(查看是否包含某一字串，包含返回true) strings.Contains(\u0026#34;hello\u0026#34;, \u0026#34;he\u0026#34;) Join(字符串拼接，参数为一个切片和一个string，返回结果为he@ta@ssss) s := []string{\u0026#34;he\u0026#34;, \u0026#34;ta\u0026#34;, \u0026#34;ssss\u0026#34;} fmt.Println(strings.Join(s, \u0026#34;@\u0026#34;)) Index(在字符串s中查找sep所在的位置，返回位置值，找不到返回-1，如果ken第二个值为t，返回的就是-1) strings.Index(\u0026#34;chicken\u0026#34;,\u0026#34;ken\u0026#34;) 返回4 Repeat(重复字符串n次，最后返回重复的字符串) strings.Repeat(\u0026#34;na\u0026#34;,2) Replace(替换,2表示替换几个，-1表示全部替换) strings.Replace(\u0026#34;ok ok ok\u0026#34;,\u0026#34;k\u0026#34;,\u0026#34;t\u0026#34;,2) Split(分离，把字符串按某个字符进行分割，返回分割后的值，返回值是一个切片) strings.Split(\u0026#34;a,b,c\u0026#34;,\u0026#34;,\u0026#34;) Trim(在s字符串的头部和尾部去除指定的字符串,最后三个感叹号都会去除，如果结尾没有感叹号就只去除开头的) strings.Trim(\u0026#34;!!!Anan!!!\u0026#34;,\u0026#34;!\u0026#34;) Fields(去除s字符串的空格符，并且按照空格分割返回一个切片类型,任意个空格都会去除) strings.Fields(\u0026#34; a b c \u0026#34;) 字符串转换：(需要导入包strconv)\nAppend系列函数将整数等转换为字符串后，添加到现有的字节数组中\nParse系列函数把字符串转换为其他类型\nParse系列函数的返回值有两个，第一个是转换的值，第二个是error值，当转换失败时error会抛出错误，如转布尔值输入的是tr11ue\n正则表达式的使用（导入包regexp） 1 2 3 4 5 6 7 buf := \u0026#34;abc adc aac a88 k8s\u0026#34; //1.解释规则，它会解析正则表达式，如果成功返回解释器，失败返回nil reg1 := regexp.MustCompile(`a.c`) //括号中可以用双引号和反引号，推荐反引号 //2.根据规则提取关键信息，-1表示匹配所有，1表示只匹配一个，返回的值是一个切片类型 result := reg1.FindAllStringSubmatch(buf, -1) fmt.Println(result, result[2]) JSON处理(需要encoding/json包) 通过结构体生成json文件 默认情况下从结构体生成json格式，结构体的成员首字母必须大写，结构体名可以小写，因为在本包使用 Marshal方法是从本包传结构体到json的包让它编码，它肯定能访问到结构体，但是成员如果小写，json的包就无法调用到\n1 2 3 4 5 6 7 8 9 10 11 12 13 type person struct { Name string Age int } func main() { p1 := person{\u0026#34;张三\u0026#34;,19} b, _ := json.Marshal(p1) fmt.Println(string(b)) var p2 person json.Unmarshal(b, \u0026amp;p2)\t//结构体是值传递，如果不使用指针就只会修改副本，不会修改p2原有的内容 fmt.Println(p2) } Marshal()会返回两个值，一个json内容一个错误值，可以用If语句接受错误，然后用return让main函数中断，return在函数中的意义：如果函数返回值有定义，则return表示返回数据，如果没有定义返回值，return就表示退出此函数，在main函数中有return就表示中断程序但是不会报错\nbuf获得的值是一个字节切片类型，可以直接string(buf)强转成string类型\n转换成string后输出的是一个整体值，无法再用切片[0]来调用任意一个成员\n通过map生成json文件 MarshalIndent()的第三个参数为一个TAB键字符串\njson解析到结构体(json解码) json的变量名是小写，而结构体的首字母是大写，所以可以通过对结构体二次编码来关联上，不建议将结构体的首字母变成小写，因为如果变成小写的话，以后又需要生成json就会失败，并且如果程序其他地方有使用到这个结构体，成员名赋值也需要修改\nUnmarshal()有两个参数，一个是byte切片类型（通过强转jsonBuf获得），一个是结构体的指针，放指针是因为给函数传结构体变量属于值传递，并不会修改本身结构体的内容，是拷贝了一份新的结构体给函数，只有通过指针实现引用传递才可以修改本身结构体内容，这个函数的返回值只有error\n如果只需要部分解析，可以重新定义一个只含有部分成员的结构体来接受解析内容\njson解析到map map也需要传递指针过去，这里原理不太清楚，但是测试过发现不加指针\u0026amp;就无法对原值进行修改，尽管map属于引用传递\n如果通过map接受解析的值，它接受到的值类型都属于空接口类型，对其强转string(m[\u0026ldquo;test\u0026rdquo;])是无法成功的，需要使用switch断言来回推类型进行赋值\nswitch可以在赋值的同时进行判断，即 switch a := 3; 判断的是st的值，空接口类型断言隐性的将data的类型放在了判断上面，且将data空接口类型自动转换成适合它的类型\n推荐使用结构体来解析，因为map如果要确定值的类型就需要断言，过于麻烦\n文件操作（需要os包） 设备文件有屏幕键盘等，标准输出就是屏幕，可以通过os.Stdout.Close()来阻止后面的程序输出内容，可以通过os.Stdint.Close()来阻止后面的程序通过键盘获取输入内容\n文件的创建和写入 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 path := \u0026#34;./test.txt\u0026#34; //创建文件，如果文件存在则打开文件且清空文件内容,它返回一个file的指针和一个error f, err := os.Create(path) if err != nil { //如果有错误就输出错误信息并且中止函数 fmt.Println(err) return } //使用完毕记得要关闭文件，使用defer就可以在函数结束的前一刹那进行关闭 defer f.Close() //Sprintln()可以将一行信息赋值给一个变量 buf := fmt.Sprintln(\u0026#34;我往文件内写入东西\u0026#34;) //往文件内写入字符串，f代表文件的指针，WriteString就可以将内容追加到文件，注意是追加 //它返回两个值，一个是写入的字节数，另一个是error n, err := f.WriteString(buf) if err != nil { fmt.Println(err) return } 文件的读取 下面的代码可以实现指定读取多少内容，如果想直接读完整个文件，只需要在读取那里加一个for循环，它就会一直往下读取直到结尾出现error抛出EOF错误（EOF表示结尾），注意：抛出EOF的if语句要写到err !=nil中，因为EOF错误是它的子集，在err不为空中加return，而EOF中只需要加break，因为break触发后直接跳出循环了，就不会触发return了\n1 2 3 4 5 6 7 if err1 != nil { if err1 == io.EOF{ break } fmt.Println(err1) return } 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 path := \u0026#34;./test.txt\u0026#34; //打开文件,返回一个文件指针和一个error f, err := os.Open(path) if err != nil { fmt.Println(err) } //函数运行结束时关闭文件 defer f.Close() //创建一个2k长度的字节切片，表示读取的总量 buf := make([]byte, 1024*10) //Read返回两个值，一个是字节数，一个是error //n是读取了多少文件字节数，如果buf大于文件总字节数，n返回总字节数。 //如果总字节数大于buf，则n等于buf，即最多只能读取buf字节的内容，如果想多读取点就只能增大buf的长度值 //Read()方法会将读取的内容放入buf中，后面查看buf内容即是查看文件内容 n, err1 := f.Read(buf) if err1 != nil \u0026amp;\u0026amp; err1 != io.EOF {\t//文件出错并且没有读到结尾 fmt.Println(err1) return } //可以用m:n来读取buf中间内容，n不能大于buf前面设定的值（即不能大于总长度），否则会报错 //n可以设置常量，即表示查看buf容量中从m到n的内容 //设置n则可以实现当文件总字节数小于buf量全部读取，大于则读取设置的最大值 fmt.Println(\u0026#34;buf:\u0026#34;, string(buf[:n])) //buf中的值都是字节型的，可以通过强转变成string 如何一行一行的进行读取且务必读完文件的全部内容（不论大小） bufio包有一个NewReader函数可以为文件的读取创建一个缓冲区并返回一个缓冲区的指针\nReadBytes是缓冲区 *Reader的方法，读取缓冲区直到第一次遇到delim字节（即指定的关键值\u0026rsquo;\\n\u0026rsquo;等），读取出一次后缓冲区中对应的内容就会消失，因此可以用for死循环来读取多行缓冲区内容\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 path := \u0026#34;./test.txt\u0026#34; //打开文件,返回一个文件指针和一个error f, err := os.Open(path) if err != nil { fmt.Println(err) } //函数运行结束时关闭文件 defer f.Close() //新建一个缓冲区，先把内容放进缓冲区里 r := bufio.NewReader(f) for { //遇到\\n就结束读取,buf为读取到的数据,这种会将\\n也读取进去，所以使用Printf() buf, err1 := r.ReadBytes(\u0026#39;\\n\u0026#39;) //当读到结尾即退出循环 fmt.Printf(\u0026#34;%v\u0026#34;, string(buf)) /*把err判断放到打印后面的原因是如果将它放在前面，它会先判断是否是最后一行，当处于最后 一行时它直接跳出循环，最后一行的输出语句就不会进行，那么就会少输出一行 */ if err1 != nil { if err1 == io.EOF { break } fmt.Println(err1) } } 实例：拷贝文件 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 //获取命令行参数，判断是否为3个 list := os.Args if len(list) != 3 { fmt.Println(\u0026#34;拷贝格式为xx.exe src dst\u0026#34;) } //比较目标文件和源文件是否同名 srcName := list[1] dstName := list[2] if srcName == dstName { fmt.Println(\u0026#34;源文件和目标文件不能相等\u0026#34;) } //只读方式打开源文件 sf, err1 := os.Open(srcName) if err1 != nil { fmt.Println(err1) return } //新建目标文件 df, err2 := os.Create(dstName) if err2 != nil { fmt.Println(err2) return } //操作完毕要关闭文件 defer sf.Close() defer df.Close() for { //读源文件 buf := make([]byte, 1024*4) n, err3 := sf.Read(buf) //从源文件读取内容 if err3 != nil { if err3 == io.EOF { //源文件读取完毕 break } fmt.Println(err3) return } //写入目标文件，读多少写多少 _, err4 := df.Write(buf[:n]) if err4 != nil { fmt.Println(err3) return } } go语言多线程 Go从语言层面就支持了并发，虽然并发程序的内存管理是非常复杂的，但是GO提供了自动垃圾回收机制\n并行和并发的区别：并行指在同一时刻有多条指令在多个处理器上同时进行，并发指虽然在单个处理器上同一时刻只能有一条指令执行，但多个进程指令被快速的轮换执行，使得在宏观上具有多个进程同时执行的效果\ngoroutine(协程) 通常main函数在一个单独的协程中运行，成为主协程，新的goroutine用go语句来创建，称为子协程，如果主协程中有for死循环，子协程要在死循环前建立，否则一直死循环就无法运行到创建子协程的语句\n注意：主协程退出后，子协程会同时跟着退出\nruntime包 Gosched() Gosched()的作用就像linux中的进程优先级一样，但是如果在A协程中添加了runtime.Gosched()后，A协程会搁置到其他协程完成任务退出协程后再继续进行A协程\nGoexit() 调用runtime.Goexit()将立即终止当前协程的进行，即使写在协程中的调用函数里也会中止当前协程\nGOMAXPROCS() 调用runtime.GOMAXPROCS()用来设置 可以并发计算 的CPU核数的最大值，并返回之前的值\nn := runtime.GOMAXPROCS(4) //以四核并发计算，核数可以大于当前系统的最大核数\nchannel类型 定义了两个函数person1和person2，虽然协程是同时进行的，但是两个公用了一个公共资源，最后打印就会出现这边打印一个字母那边打印一个，就造成了资源竞争问题。channel属于引用传递，即调用的都是同一个channel。\n如果在person2中设置channel堵塞，它就会让此进程一直堵在channel步骤，而person1中先调用公共资源，person2暂停，当person1资源调用完毕后将int=666传入ch,子进程1结束，ch管道中有内容了不再堵塞，此时person2中的同一个ch管道将int传入函数并丢弃，然后继续执行后面的代码来调用公共资源，这样就可以避免资源竞争问题。\n如果希望在子协程工作完成后再关闭主协程的话（主协程关闭会导致子协程同时关闭），可以在子协程中设置管道 ch\u0026lt;- \u0026ldquo;子协程完毕\u0026rdquo;，然后主协程接受这段内容并丢弃( \u0026lt;-ch )，这样就可以实现子协程没有进行到发送信息到管道那一步时，主协程ch永远堵塞，只有完成子协程任务并关闭后，主协程channel才有信息不堵塞，然后才可以正常完成主协程（channel也可以用于发送接受数据，类似linux的竖线管道）\n无缓存通道和有缓存通道 channer分为无缓存通道和有缓存通道，无缓存channel没有接收或者没有发送都会造成堵塞，有缓存值的在写满缓存时就会造成堵塞，通道中没值时也无法取数据\n有缓存cannel属于异步处理，每当接收者从cannel取出一条数据时，cannel中就会丢弃这条数据，将空间闲置出来给新的数据使用，当数据取完或写满时就会造成阻塞\nclose(ch)可以关闭通道，接收者可以通过 value,ok := \u0026lt;-ch来获取值，value为管道中的数据，ok在当管道没有关闭时为true，管道关闭了则为false\n单项channel管道 双向channel可以隐式的转换为单向channel ( var writeCan chan\u0026lt;- int = ch ),单向无法转换为双向\n案例：\nchannel可以通过range来依次读取通道内的数据，它的参数只有num，并非两个值。且必须搭配close(ch)使用，不然继续迭代下去，没有值但是还在进行\u0026lt;-ch，这会造成通道阻塞，出现死锁问题。在写入channel的函数中最后加上 close(ch) 就可以给它发送一个信号，它会在读取完全部值后退出for循环\n由于channel属于引用传递，所以虽然函数的参数是单项通道，但是最终修改的依然是本来的双向通道ch，这可以避免在函数中又读又写造成逻辑混乱\n定时器 Timer(类似一次性闹钟) NewTimer只是返回了一个2s后的Timer指针变量，如果需要真的延时2s，必须使用 \u0026lt;-timer.C来将通道数据丢弃或赋值，因为它是在2s后接受数据并传入变量，在2s之前这个通道都是堵塞的（通道内没有数据），程序不会向下运行\nNewTimer函数返回一个Timer的指针，Timer只会响应一次，过后不会再响应（一次性闹钟），即只会向cannel写一次2s后的时间\n1 2 3 4 5 \u0026lt;-time.After(2 * time.Second) 定时程序2s,2s后产生一个事件，往channerl中写入时间（2s后那个时间点）数据 timer.Stop() 停止定时器 timer.Reset(1 * time.Second) 重新设置为1s Ticker（类似循环闹钟） Select (可以监听channel通道的数据流动) 注意：如果写了default，即每次都能判定成功，会导致select语句完成判定然后结束，不写就会（一直）阻塞直到case判定成功执行某一个case语句然后结束\n如果select语句不加for循环，那么它只会判定一次并只将数据写入一次管道，监听一次就结束显然不符合监听的目的，所以需要往select外套一个for死循环来实现监听操作\n第二个case语句，写入通道的操作必须要有一个读的操作（\u0026lt;-chan2）可以接收它的数据，只有写没有读是不能写成功的，有读没写也是不能读成功，都会造成管道死锁问题，这样就可以通过select实现在外部写入，select中的case读操作就判断成功。\n注意：case不止是判断，它判断后面的语句能否读写成功，那么在判断成功的同时它也会往通道中读写数据\n斐波那契数列 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 func fibonacci(ch chan\u0026lt;- int, quit \u0026lt;-chan bool) { x, y := 1, 1 for { select { case ch \u0026lt;- x: x, y = y, x+y case flag := \u0026lt;-quit: return } } } func main() { ch := make(chan int) quit := make(chan bool) //输出数字 go func() { for i := 0; i \u0026lt; 8; i++ { num := \u0026lt;-ch fmt.Println(num) } quit \u0026lt;- true }() //产生数字，写入管道 fibonacci(ch, quit) } 输出结果为：1\t1\t2\t3\t5\t8\t13\t21 除去第二个数，其他数为前两个数相加 如果select语句不加for循环，那么它只会判定一次并只将数据写入一次管道，而fibonacci函数处于主协程，当判定成功后就会直接完成主协程，那么子协程也会退出，后面的数据都无法继续输出\n用select实现超时退出 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 ch := make(chan int) quit := make(chan bool) //监听管道数据 go func() { for { select { case num := \u0026lt;-ch: fmt.Println(num) case \u0026lt;-time.NewTimer(3 * time.Second).C: fmt.Println(\u0026#34;3s没有输出数据\u0026#34;) quit \u0026lt;- true return } } }() go func() { for i := 0; i \u0026lt; 4; i++ { ch \u0026lt;- i time.Sleep(time.Second) } \u0026lt;-quit fmt.Println(\u0026#34;程序结束\u0026#34;) }() for {} 当ch中没有数据时，case ch会堵塞，然后三秒后case time会有数据，执行case2，往quit管道中写入数据，最下面的读取quit就不会堵塞，程序就会继续执行，如果不希望主程序结束，可以将quit管道放到一个子协程中（且主程序有for循环之类的不会结束），那么三秒后子协程运行完自动退出，不会波及主协程\n注意：case语句是会执行之后的语句的，所以time.NewTimer()会在3s后继续有值，且会再输出fmt，然后此时quit管道没接收者，会一直堵塞在这里，子协程会一直存在直到主协程关闭，所以加上return语句让它在第一次就关闭此函数，或者break跳出for循环\nSocket网络编程（需要net包） c/s架构 服务器部分： 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 //设置监听，此处及下面都会返回err，为了缩短代码量丢弃了err，工作中不要丢弃 listener, _ := net.Listen(\u0026#34;tcp\u0026#34;, \u0026#34;127.0.0.1:8888\u0026#34;) //阻塞等待用户数据 conn, _ := listener.Accept() //接收用户请求 buf := make([]byte, 1024) //用户数据最后返回到了buf切片中，n表示从用户数据那读取的字节数，最大值为切片的长度1024 n, _ := conn.Read(buf) fmt.Println(string(buf[:n])) //最后处理完数据记得关闭连接 defer func() { listener.Close() conn.Close() }() 服务器端先定义一个监听，表示将这个服务器以什么协议放置于什么位置，然后listener.Accept()让服务器阻塞等待用户向服务器端发送数据，用户发送数据后会存入conn中，通过conn.Read()来获取用户输入的数据并放到buf切片中，通过string(buf[:n])强转用户的字节数据为字符串，n表示数据量大于切片则返回切片最大值数据量，小于切片则返回全部数据，n返回的是Read所读取的总字节量，其值不会超过buf定义的1024字节\n客户端部分： 1 2 3 4 5 //主动连接服务器 conn, _ := net.Dial(\u0026#34;tcp\u0026#34;, \u0026#34;127.0.0.1:8888\u0026#34;) //发送数据 conn.Write([]byte(\u0026#34;are you ok?\u0026#34;)) defer conn.Close() 客户端部分只需要连接服务器并且发送数据，连接服务器需要指定服务器的ip端口和协议，发送的数据是字节切片类型\n如何多个客户端同时连接同一个服务器（重要） 服务器端：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 //conn的类型为net包里的Conn接口 func HandleConn(conn net.Conn) { //每个用户使用完毕后关闭协程 defer conn.Close() //获取客户端的网络信息,并以ip 端口的形式输出 addr := conn.RemoteAddr().String() fmt.Println(addr, \u0026#34;---连接成功\u0026#34;) buf := make([]byte, 2048) //用for循环套住Read()，用户发送一次数据，接收一次并赋值给buf， //运行下面的打印和回传，再次循环并阻塞在Read()处等待用户再次发送请求 //但是这样会让子进程一直存在，除非设置了err不为空时退出实现强制退出 //因此加一个用户输入exit退出的逻辑 for{ n, _ := conn.Read(buf) //打印用户发送过来的内容 fmt.Printf(\u0026#34;%s输入了: %s\\n\u0026#34;, addr, string(buf[:n])) //把用户信息转为大写发回给用户(先将小写的字节切片转为string，然后变成大写再强转为字节切片) //n-是因为在windows中输入的语句有一个\\r\\n换行符，需要-2去除它 //各个平台都不一样，因此可以在前面通过len(string(buf[:n]))来判断到底多了几个字符 if string(buf[:n-2]) == \u0026#34;exit\u0026#34; { fmt.Println(addr, \u0026#34; exit\u0026#34;) return } conn.Write([]byte(strings.ToUpper(string(buf[:n])))) } } func main() { //设置监听，此处及下面都会返回err，为了缩短代码量丢弃了err，工作中不要丢弃 listener, _ := net.Listen(\u0026#34;tcp\u0026#34;, \u0026#34;127.0.0.1:8888\u0026#34;) //利用for循环实现多个客户端连接同一个服务器 for { //循环阻塞等待用户请求，一个用户请求然后往下走，然后循环继续等下一个用户 conn, _ := listener.Accept() //开子协程处理多个用户请求，如果没有用户进入就会阻塞到第一步直到第一个用户请求， //然后往下开一个新协程给此用户，继续for循环等待下一个用户请求 go HandleConn(conn) } defer listener.Close() } 客户端：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 func main() { //主动连接服务端 conn, _ := net.Dial(\u0026#34;tcp\u0026#34;, \u0026#34;127.0.0.1:8888\u0026#34;) defer conn.Close() //从键盘获取输入并发往服务器端 go func() { str := make([]byte, 2048) //用for循环可以实现当os.Stdin.Read()中没有数据时（即没有进行输入）， //阻塞在这一步，直到用户输入内容才继续向下进行 for { //os.Stdin.Read可以提示键盘输入并且将输入的内容转换为字节切片，并赋值到str中，返回切片的长度 n, _ := os.Stdin.Read(str) //发送给服务器端 conn.Write(str[:n]) } }() //从服务器端获取数据 buf := make([]byte, 2048) for { //for循环实现当服务器未往客户端发送数据时，conn.Read(buf)为空，阻塞在这一步， //有数据循环一遍，然后等待下次服务器的数据 //当服务器端输入exit后，服务器端所对应的子协程结束，conn.Read()返回err， //通过return结束主协程，子协程同时结束，退出程序 n, err := conn.Read(buf) if err != nil { fmt.Println(err) return } fmt.Println(string(buf[:n])) } } 远程发送文件： 服务器端：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 func RecvFile(path string, conn net.Conn) { //创建文件 f, _ := os.Create(path) //循环接收文件的内容 buf := make([]byte, 1024*4) for { n, err := conn.Read(buf) if err != nil { if err == io.EOF { fmt.Println(\u0026#34;文件接收完毕\u0026#34;) } else { fmt.Println(err) } return } //往文件写入内容 f.Write(buf[:n]) } } func main() { //建立监听 listener, _ := net.Listen(\u0026#34;tcp\u0026#34;, \u0026#34;127.0.0.1:8888\u0026#34;) //阻塞等待用户请求 conn, _ := listener.Accept() //接收用户文件名 buf := make([]byte, 1024) n, _ := conn.Read(buf) path := string(buf[:n]) //返回消息 conn.Write([]byte(\u0026#34;开始发送\u0026#34;)) //接收文件内容 RecvFile(path, conn) defer listener.Close() defer conn.Close() } 客户端：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 func SendFile(path string, conn net.Conn) { //打开文件，读取文件 f, _ := os.Open(path) buf := make([]byte, 1024*4) for { n, err := f.Read(buf) if err != nil { if err == io.EOF { fmt.Println(\u0026#34;文件传输完成\u0026#34;) } else { fmt.Println(err) } return } //发送到服务器 conn.Write(buf[:n]) } defer f.Close() defer conn.Close() } func main() { fmt.Println(\u0026#34;请输入文件名：\u0026#34;) var path string fmt.Scan(\u0026amp;path) //os.Stat()返回FileInfo类型变量，可以获取文件信息,info.Name()获取文件名,没有此文件则会报错 info, err := os.Stat(path) if err != nil { fmt.Println(\u0026#34;没有这个文件\u0026#34;, err) return } //连接服务器,工作中err别丢空 conn, _ := net.Dial(\u0026#34;tcp\u0026#34;, \u0026#34;127.0.0.1:8888\u0026#34;) //给服务器先发送文件名,err和n都可以丢空 conn.Write([]byte(info.Name())) //服务器接收到文件名，向客户端发送消息,客户端进行判断开始进行发送 buf := make([]byte, 1024) n, _ := conn.Read(buf) if string(buf[:n]) == \u0026#34;开始发送\u0026#34; { SendFile(path, conn) } } 并发聊天服务器 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 type Clinet struct { C chan string //管道string类型，暂存用户发送的数据 Name string //用户名 Addr string //网络地址 } var onlineMap = make(map[string]Clinet) var message = make(chan string) func WriteMsgToClient(cli Clinet, conn net.Conn) { //这个是为了实现cli.C中有数据时向各自客户端发送数据，没有数据时阻塞在这一步 //且任意用户都会在登录时都会通过Manager()方法向每个用户的cli.C发送登录信息， //只要cli.C一有信息，这个子协程就会检测到cli.C不再阻塞，就能向客户端写入新的他人登录信息 //只要发送处的管道没有关闭，cli.Close()，这个for就不会检测到false，会一直堵塞在这里 for msg := range cli.C { conn.Write([]byte(msg + \u0026#34;\\n\u0026#34;)) } } //将用户存进在线用户变量onlineMap中 func HandleConn(conn net.Conn) { defer conn.Close() //获取网络地址 cliAddr := conn.RemoteAddr().String() //创建一个结构体,添加到map中 cli := Clinet{make(chan string), cliAddr, cliAddr} onlineMap[cliAddr] = cli //新开一个协程，专门给当前用户发送消息 go WriteMsgToClient(cli, conn) //广播某个人在线 message \u0026lt;- \u0026#34;[\u0026#34; + cli.Name + \u0026#34;]---login\u0026#34; //退出进行广播并且关闭子协程 isQuit := make(chan bool) hasData := make(chan bool) //新开一个协程，接收用户发送过来的请求 go func() { buf := make([]byte, 2048) //for循环可以避免输入一次就不再进行接收信息的问题 for { n, _ := conn.Read(buf) if n == 0 { //对方断开或者出问题 isQuit \u0026lt;- true return } msg := string(buf[:n-2]) //过滤window末尾的/r/n符号 //查询所有用户 if len(msg) == 3 \u0026amp;\u0026amp; msg == \u0026#34;who\u0026#34; { //避免whoami和who匹配 //遍历map，给当前用户发送所有成员 conn.Write([]byte(\u0026#34;user list:\\n\u0026#34;)) for _, tmp := range onlineMap { msg = tmp.Name + \u0026#34;-----is online\\n\u0026#34; conn.Write([]byte(msg)) } //给用户重命名，输入rename|mike } else if len(msg) \u0026gt;= 8 \u0026amp;\u0026amp; msg[:6] == \u0026#34;rename\u0026#34; { name := strings.Split(msg, \u0026#34;|\u0026#34;)[1] //将msg以|分割 cli.Name = name conn.Write([]byte(\u0026#34;u name is rename\u0026#34;)) } else { //message复用来给所有用户广播它发送的消息，包括自己也看见 message \u0026lt;- cli.Name + \u0026#34;:\u0026#34; + msg } hasData \u0026lt;- true } }() //用for循环让此子协程不会结束，避免发送消息后子协程结束，这个用户就通信结束了 //目的是让用户可以接收到后面登录和发送的信息，所以这个子协程就必须一直存在，除非用户退出 for { //通过select检测管道isQuit的流动 select { case \u0026lt;-isQuit: //删除用户并且广播谁下线了 delete(onlineMap, cliAddr) message \u0026lt;- cli.Name + \u0026#34;--is login out\u0026#34; return case \u0026lt;-hasData: //有数据不作处理 case \u0026lt;-time.After(60 * time.Second): //60s后超时执行此case,超时强制退出 delete(onlineMap, cliAddr) message \u0026lt;- cli.Name + \u0026#34;--is time out leave out\u0026#34; return } } } //新开一个协程，转发消息，只要消息来了就遍历map，给map每个成员都发送此消息 func Manager() { for { //mes为string类型的变量，自动推导类型 msg := \u0026lt;-message //遍历map，给map每个成员都发送此消息 for _, cli := range onlineMap { cli.C \u0026lt;- msg } } } func main() { //监听 listener, _ := net.Listen(\u0026#34;tcp\u0026#34;, \u0026#34;127.0.0.1:8888\u0026#34;) defer listener.Close() go Manager() //循环 for { //循环阻塞，形成多个客户端共用一个服务器 conn, _ := listener.Accept() //处理用户连接 go HandleConn(conn) } } 先是主函数启动子协程HandleConn(conn)，它作用于往map中写入在线成员，并将消息发给管道message,再通过Manager()将message管道发给msg字符串，遍历map，往每个map中的管道写入信息,紧接着通过WriteMsgToClient()中的range向客户端写入消息，且for遍历管道时，没有cli.Close()的存在，它会一直堵塞在此处等待新的信息写进cli.C\nb/s架构： 但是如果工作中每次都需要向服务器发送一长串的请求包过于繁琐，所以可以使用net/http包来简化\nhttp服务器： 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 //w为给客户端回复的数据 //req，读取客户端的数据 func HandConn(w http.ResponseWriter, req *http.Request) { //给客户端浏览器发送数据 w.Write([]byte(\u0026#34;hello go\u0026#34;)) //获取客户端的请求头部参数等 //在https://studygolang.com/pkgdoc中的net/http中搜type Request可以获取req的所有参数 fmt.Println(req.URL.Path) } func main() { //注册处理函数，用户连接进来自动调用指定的处理函数(即如果域名后面接了/hello则调用后面那个函数) //源代码中第二个参数为handler func(ResponseWriter, *Request) //即在定义函数时已经定义了这是一个func，且默认已经传了两个参数进去，所以不需要加()来调用， //自己写HandConn函数时也不再需要想办法获取ResponseWriter和*http.Request的值了 http.HandleFunc(\u0026#34;/hello\u0026#34;, HandConn) //该方法用于在指定的网络地址进行监听，然后调用服务端处理程序来处理传入的连接请求 //该方法有两个参数：第一个为监听地址；第二个参数表示服务器端处理程序，通常为空 //第二个参数为空意味着服务端调用http.DefaultServerMux进行处理 http.ListenAndServe(\u0026#34;127.0.0.1:8000\u0026#34;, nil) } http客户端： 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 //获取从百度回传回来的请求包，http是必须要加的 resp, _ := http.Get(\u0026#34;http://www.baidu.com\u0026#34;) //body是从服务器端读取资源(类似于conn.Read())，最后是需要进行关闭的 defer resp.Body.Close() fmt.Println(\u0026#34;Status =\u0026#34;, resp.Status) fmt.Println(\u0026#34;StatusCode =\u0026#34;, resp.StatusCode) fmt.Println(\u0026#34;Header =\u0026#34;, resp.Header) //获取baidu.com中的数据Read()，然后赋值给buf，最后追加到tmp中 buf := make([]byte, 1024*4) var tmp string for { n, err := resp.Body.Read(buf) if n == 0 { fmt.Println(\u0026#34;read err =\u0026#34;, err) break } tmp += string(buf[:n]) } fmt.Println(tmp) 用go写爬虫爬百度贴吧： 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 func SpiderPage(i int, page chan int) { //寻找网址规律，每页pn加50,用for循环获取每个网址 url := \u0026#34;http://tieba.baidu.com/f?kw=%E6%8A%97%E5%8E%8B%E8%83%8C%E9%94%85\u0026amp;ie=utf-8\u0026amp;pn=\u0026#34; + strconv.Itoa((i-1)*50) fmt.Printf(\u0026#34;正在爬取第%d页网页%s\\n\u0026#34;, i, url) result, _ := HttpGet(url) //将内容写到文件中 f, _ := os.Create(strconv.Itoa(i) + \u0026#34;.html\u0026#34;) f.Write([]byte(result)) f.Close() page \u0026lt;- i } func HttpGet(url string) (result string, err error) { rep, _ := http.Get(url) defer rep.Body.Close() //爬取 buf := make([]byte, 1024*4) for { n, err := rep.Body.Read(buf) if n == 0 { fmt.Println(err) break } result += string(buf[:n]) } return } func DoWork(start, end int) { fmt.Printf(\u0026#34;正在爬取 %d到%d的页面。。。\u0026#34;, start, end) //建立一个管道，避免主进程结束导致子进程结束 page := make(chan int) //获取地址 for i := start; i \u0026lt;= end; i++ { //建立子协程，让多个爬虫同时进行 go SpiderPage(i, page) } for i := start; i \u0026lt;= end; i++ { //避免协程结束影响子协程 fmt.Printf(\u0026#34;第%d页已经读取完毕\u0026#34;, \u0026lt;-page) } return } func main() { var start, end int fmt.Println(\u0026#34;请输入起始页\u0026#34;) fmt.Scan(\u0026amp;start) fmt.Println(\u0026#34;请输入结束页\u0026#34;) fmt.Scan(\u0026amp;end) DoWork(start, end) } 此方法可以爬取每页内容（包括html内容）存到新建的.html中，如果要爬取需要的内容，可以查看源代码然后通过正则表达式爬出来再存入文件中\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 如爬取每个帖子的某段内容，先在每个主页查看源代码爬取出每个帖子的url， \u0026lt;a rel=\u0026#34;noreferrer\u0026#34; href=\u0026#34;/p/6978750013\u0026#34; title=\u0026#34;老马是真的叼，剪辑的更吊！！！\u0026#34; target=\u0026#34;_blank\u0026#34; class=\u0026#34;j_th_tit \u0026#34; 用正则表达式 (`\u0026lt;a rel=\u0026#34;noreferrer\u0026#34; href=\u0026#34;(?s:(.*?))\u0026#34; title=`) 来爬取出网页链接， regexp的FindAllStringSubmatch会返回一个二维切片，切片中的里切片第一个值是通过表达式过滤出的内容， 第二个值是正则表达式代表的内容，即/p/6978750013，给它拼接上贴吧网址即可访问 通过range迭代外切片然后在里面调用里切片[1]即可 然后在range中用http.Get爬取内容，依然是查看源代码找到对应的内容进行过滤 过来出来的内容可能会有些\\t \u0026lt;br /\u0026gt;之类的，可以用strings.Replace(text,\u0026#34;\\t\u0026#34;,\u0026#34;\u0026#34;,-1)去掉 最后写入文件，如果多标题多内容，可以分开存入到两个切片中，然后后面一口气写进文件中 如果不用子协程来爬取，它就是单协程的程序，它会爬完一个再爬下一个，开了子协程后它可以同时爬取多个，节省了大量时间，但是要注意子协程开启后主协程不能关闭，这样会导致子协程也同时消失，可以使用切片来阻塞主协程，直到爬取完毕\n常见知识点 switch中隐式含有break，但是select中必须要用break或continue跳出循环 结构体实现接口时不需要导入接口所在的包 一个go文件中可以包含多个init同名函数，他属于官方在内存中定义的函数，自上而下运行，自己定义的函数不能同名 变量定义可以用中文，会转换成ASCII码，变量名中不能有$ string不能用nil，它的空值为“”空字符串 make([]int,0)初始化切片的时候，必须要指定容量，即使是0，不指定会报错 golang的自增自减++ \u0026ndash; 只有后置，没有前置 只要两个接口拥有相同的方法列表，那么它们就是等价的，可以相互赋值。 cap函数（容量大小）只能传数组，切片，管道 recover()在func()外运行是无法阻止异常的，必须要写func(){recover()}才能处理异常 指针、数组、切片、map字典、结构体都属于复合类型 new()返回*T，只分配内存，不初始化。make返回T，分配并初始化，只适用于map,slice,chan 以使用切片来阻塞主协程，直到爬取完毕 常见知识点 switch中隐式含有break，但是select中必须要用break或continue跳出循环 结构体实现接口时不需要导入接口所在的包 一个go文件中可以包含多个init同名函数，他属于官方在内存中定义的函数，自上而下运行，自己定义的函数不能同名 变量定义可以用中文，会转换成ASCII码，变量名中不能有$ string不能用nil，它的空值为“”空字符串 make([]int,0)初始化切片的时候，必须要指定容量，即使是0，不指定会报错 golang的自增自减++ \u0026ndash; 只有后置，没有前置 只要两个接口拥有相同的方法列表，那么它们就是等价的，可以相互赋值。 cap函数（容量大小）只能传数组，切片，管道 recover()在func()外运行是无法阻止异常的，必须要写func(){recover()}才能处理异常 指针、数组、切片、map字典、结构体都属于复合类型 new()返回*T，只分配内存，不初始化。make返回T，分配并初始化，只适用于map,slice,chan 1 2 3 ![20190918](20190918.jpg) ![Photo by Luca Bravo on Unsplash](luca-bravo-alS7ewQ41M8-unsplash.jpg) ![Photo by Helena Hertz on Unsplash](helena-hertz-wWZzXlDpMog-unsplash.jpg) ![Photo by Hudai Gayiran on Unsplash](hudai-gayiran-3Od_VKcDEAA-unsplash.jpg) ","date":"2020-09-09T00:00:00Z","permalink":"https://xiaonuoz.github.io/p/test-chinese11/","title":"Chinese Test11"},{"content":"\nsqlx可以认为是Go语言内置 database/sql的超集，它在内置 database/sql基础上提供了一组扩展。这些扩展中除了常用来查询的 Get(dest interface{}, ...) error和 Select(dest interface{}, ...) error外还有很多其他强大的功能。\n安装sqlx 1 go get github.com/jmoiron/sqlx 基本使用 连接数据库 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 var db *sqlx.DB func initDB() (err error) { dsn := \u0026#34;user:password@tcp(127.0.0.1:3306)/sql_test?charset=utf8mb4\u0026amp;parseTime=True\u0026#34; // 也可以使用MustConnect连接不成功就panic //sqlx不需要进行Ping()来判断是否连接成功，它在connect同时也进行了Ping() db, err = sqlx.Connect(\u0026#34;mysql\u0026#34;, dsn) if err != nil { fmt.Printf(\u0026#34;connect DB failed, err:%v\\n\u0026#34;, err) return } db.SetMaxOpenConns(20) db.SetMaxIdleConns(10) return } 查询 查询单行数据示例代码如下：\n1 2 3 4 5 6 7 8 9 10 11 // 查询单条数据示例 func queryRowDemo() { sqlStr := \u0026#34;select id, name, age from user where id=?\u0026#34; var u user err := db.Get(\u0026amp;u, sqlStr, 1) if err != nil { fmt.Printf(\u0026#34;get failed, err:%v\\n\u0026#34;, err) return } fmt.Printf(\u0026#34;id:%d name:%s age:%d\\n\u0026#34;, u.ID, u.Name, u.Age) } 查询多行数据示例代码如下：\n1 2 3 4 5 6 7 8 9 10 11 12 // 查询多条数据示例 func queryMultiRowDemo() { sqlStr := \u0026#34;select id, name, age from user where id \u0026gt; ?\u0026#34; //此处切片不make初始化是因为在select()中会帮忙进行初始化操作 var users []user err := db.Select(\u0026amp;users, sqlStr, 0) if err != nil { fmt.Printf(\u0026#34;query failed, err:%v\\n\u0026#34;, err) return } fmt.Printf(\u0026#34;users:%#v\\n\u0026#34;, users) } 注意：sqlx通过反射来获取结构体的成员或切片等变量，将查询出的结果赋值给结构体或切片，因此结构体成员必须首字母大写（公开的变量），并且反射中有判断如果参数不是指针类型就直接return，因此即使切片是引用传递也需要传指针进去。\n插入、更新和删除 sqlx中的exec方法与原生sql中的exec使用基本一致：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 // 插入数据 func insertRowDemo() { sqlStr := \u0026#34;insert into user(name, age) values (?,?)\u0026#34; ret, err := db.Exec(sqlStr, \u0026#34;笑傩\u0026#34;, 23) if err != nil { fmt.Printf(\u0026#34;insert failed, err:%v\\n\u0026#34;, err) return } theID, err := ret.LastInsertId() // 新插入数据的id if err != nil { fmt.Printf(\u0026#34;get lastinsert ID failed, err:%v\\n\u0026#34;, err) return } fmt.Printf(\u0026#34;insert success, the id is %d.\\n\u0026#34;, theID) } // 更新数据 func updateRowDemo() { sqlStr := \u0026#34;update user set age=? where id = ?\u0026#34; ret, err := db.Exec(sqlStr, 39, 6) if err != nil { fmt.Printf(\u0026#34;update failed, err:%v\\n\u0026#34;, err) return } n, err := ret.RowsAffected() // 操作影响的行数 if err != nil { fmt.Printf(\u0026#34;get RowsAffected failed, err:%v\\n\u0026#34;, err) return } fmt.Printf(\u0026#34;update success, affected rows:%d\\n\u0026#34;, n) } // 删除数据 func deleteRowDemo() { sqlStr := \u0026#34;delete from user where id = ?\u0026#34; ret, err := db.Exec(sqlStr, 6) if err != nil { fmt.Printf(\u0026#34;delete failed, err:%v\\n\u0026#34;, err) return } n, err := ret.RowsAffected() // 操作影响的行数 if err != nil { fmt.Printf(\u0026#34;get RowsAffected failed, err:%v\\n\u0026#34;, err) return } fmt.Printf(\u0026#34;delete success, affected rows:%d\\n\u0026#34;, n) } NamedExec DB.NamedExec方法用来绑定SQL语句与结构体或map中的同名字段。\n1 2 3 4 5 6 7 8 9 func insertUserDemo()(err error){ sqlStr := \u0026#34;INSERT INTO user (name,age) VALUES (:name,:age)\u0026#34; _, err = db.NamedExec(sqlStr, map[string]interface{}{ \u0026#34;name\u0026#34;: \u0026#34;笑傩\u0026#34;, \u0026#34;age\u0026#34;: 23, }) return } NamedQuery 与 DB.NamedExec同理，这里是支持查询。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 func namedQuery(){ sqlStr := \u0026#34;SELECT * FROM user WHERE name=:name\u0026#34; // 使用map做命名查询 rows, err := db.NamedQuery(sqlStr, map[string]interface{}{\u0026#34;name\u0026#34;: \u0026#34;笑傩\u0026#34;}) if err != nil { fmt.Printf(\u0026#34;db.NamedQuery failed, err:%v\\n\u0026#34;, err) return } defer rows.Close() for rows.Next(){ var u user err := rows.StructScan(\u0026amp;u) if err != nil { fmt.Printf(\u0026#34;scan failed, err:%v\\n\u0026#34;, err) continue } fmt.Printf(\u0026#34;user:%#v\\n\u0026#34;, u) } u := user{ Name: \u0026#34;笑傩\u0026#34;, } // 使用结构体命名查询，根据结构体字段的 db tag进行映射 rows, err = db.NamedQuery(sqlStr, u) if err != nil { fmt.Printf(\u0026#34;db.NamedQuery failed, err:%v\\n\u0026#34;, err) return } defer rows.Close() for rows.Next(){ var u user err := rows.StructScan(\u0026amp;u) if err != nil { fmt.Printf(\u0026#34;scan failed, err:%v\\n\u0026#34;, err) continue } fmt.Printf(\u0026#34;user:%#v\\n\u0026#34;, u) } } 事务操作 对于事务操作，可以使用 sqlx中提供的 db.Beginx()和 tx.Exec()方法。示例代码如下：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 func transactionDemo2()(err error) { tx, err := db.Beginx() // 开启事务 if err != nil { fmt.Printf(\u0026#34;begin trans failed, err:%v\\n\u0026#34;, err) return err } defer func() { if p := recover(); p != nil { tx.Rollback() panic(p) // re-throw panic after Rollback } else if err != nil { fmt.Println(\u0026#34;rollback\u0026#34;) tx.Rollback() // err is non-nil; don\u0026#39;t change it } else { err = tx.Commit() // err is nil; if Commit returns error update err fmt.Println(\u0026#34;commit\u0026#34;) } }() sqlStr1 := \u0026#34;Update user set age=20 where id=?\u0026#34; rs, err := tx.Exec(sqlStr1, 1) if err!= nil{ return err } n, err := rs.RowsAffected() if err != nil { return err } if n != 1 { return errors.New(\u0026#34;exec sqlStr1 failed\u0026#34;) } sqlStr2 := \u0026#34;Update user set age=50 where i=?\u0026#34; rs, err = tx.Exec(sqlStr2, 5) if err!=nil{ return err } n, err = rs.RowsAffected() if err != nil { return err } if n != 1 { return errors.New(\u0026#34;exec sqlStr1 failed\u0026#34;) } return err } sqlx.In sqlx.In是 sqlx提供的一个非常方便的函数。\nsqlx.In的批量插入示例 表结构 创建一个 user表，表结构如下：\n1 2 3 4 5 6 CREATE TABLE `user` ( `id` BIGINT(20) NOT NULL AUTO_INCREMENT, `name` VARCHAR(20) DEFAULT \u0026#39;\u0026#39;, `age` INT(11) DEFAULT \u0026#39;0\u0026#39;, PRIMARY KEY(`id`) )ENGINE=InnoDB AUTO_INCREMENT=1 DEFAULT CHARSET=utf8mb4; 结构体 定义一个 user结构体，字段通过tag与数据库中user表的列一致。\n1 2 3 4 type User struct { Name string `db:\u0026#34;name\u0026#34;` Age int `db:\u0026#34;age\u0026#34;` } bindvars（绑定变量） 查询占位符 ?在内部称为bindvars（查询占位符）,它非常重要。你应该始终使用它们向数据库发送值，因为它们可以防止SQL注入攻击。database/sql不尝试对查询文本进行任何验证；它与编码的参数一起按原样发送到服务器。除非驱动程序实现一个特殊的接口，否则在执行之前，查询是在服务器上准备的。因此 bindvars是特定于数据库的:\nMySQL中使用 ? PostgreSQL使用枚举的 $1、$2等bindvar语法 SQLite中 ?和 $1的语法都支持 Oracle中使用 :name的语法 bindvars的一个常见误解是，它们用来在sql语句中插入值。它们其实仅用于参数化，不允许更改SQL语句的结构。例如，使用 bindvars尝试参数化列或表名将不起作用：\n1 2 3 4 5 // ？不能用来插入表名（做SQL语句中表名的占位符） db.Query(\u0026#34;SELECT * FROM ?\u0026#34;, \u0026#34;mytable\u0026#34;) // ？也不能用来插入列名（做SQL语句中列名的占位符） db.Query(\u0026#34;SELECT ?, ? FROM people\u0026#34;, \u0026#34;name\u0026#34;, \u0026#34;location\u0026#34;) 手动拼接语句实现批量插入 就是有多少个User就拼接多少个 (?, ?)。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 // BatchInsertUsers 自行构造批量插入的语句 func BatchInsertUsers(users []*User) error { // 存放 (?, ?) 的slice valueStrings := make([]string, 0, len(users)) // 存放values的slice valueArgs := make([]interface{}, 0, len(users) * 2) // 遍历users准备相关数据 for _, u := range users { // 此处占位符要与插入值的个数对应 valueStrings = append(valueStrings, \u0026#34;(?, ?)\u0026#34;) valueArgs = append(valueArgs, u.Name) valueArgs = append(valueArgs, u.Age) } // 自行拼接要执行的具体语句 stmt := fmt.Sprintf(\u0026#34;INSERT INTO user (name, age) VALUES %s\u0026#34;, strings.Join(valueStrings, \u0026#34;,\u0026#34;)) _, err := DB.Exec(stmt, valueArgs...) return err } 使用sqlx.In实现批量插入 前提是需要结构体实现 driver.Valuer接口：\n1 2 3 func (u User) Value() (driver.Value, error) { return []interface{}{u.Name, u.Age}, nil } 使用 sqlx.In实现批量插入代码如下：\n1 2 3 4 5 6 7 8 9 10 11 // BatchInsertUsers2 使用sqlx.In帮我们拼接语句和参数, 注意传入的参数是[]interface{} func BatchInsertUsers2(users []interface{}) error { query, args, _ := sqlx.In( \u0026#34;INSERT INTO user (name, age) VALUES (?), (?), (?)\u0026#34;, users..., // 如果arg实现了 driver.Valuer, sqlx.In 会通过调用 Value()来展开它 ) fmt.Println(query) // 查看生成的querystring fmt.Println(args) // 查看生成的args _, err := DB.Exec(query, args...) return err } 使用NamedExec实现批量插入 在项目目录下执行以下命令下载并使用 master分支代码：\n1 go get github.com/jmoiron/sqlx@master 使用 NamedExec实现批量插入的代码如下：\n1 2 3 4 5 // BatchInsertUsers3 使用NamedExec实现批量插入 func BatchInsertUsers3(users []*User) error { _, err := DB.NamedExec(\u0026#34;INSERT INTO user (name, age) VALUES (:name, :age)\u0026#34;, users) return err } 把上面三种方法综合起来试一下：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 func main() { err := initDB() if err != nil { panic(err) } defer DB.Close() u1 := User{Name: \u0026#34;笑傩\u0026#34;, Age: 18} u2 := User{Name: \u0026#34;xn\u0026#34;, Age: 28} u3 := User{Name: \u0026#34;笑笑\u0026#34;, Age: 38} // 方法1 users := []*User{\u0026amp;u1, \u0026amp;u2, \u0026amp;u3} err = BatchInsertUsers(users) if err != nil { fmt.Printf(\u0026#34;BatchInsertUsers failed, err:%v\\n\u0026#34;, err) } // 方法2 users2 := []interface{}{u1, u2, u3} err = BatchInsertUsers2(users2) if err != nil { fmt.Printf(\u0026#34;BatchInsertUsers2 failed, err:%v\\n\u0026#34;, err) } // 方法3 users3 := []*User{\u0026amp;u1, \u0026amp;u2, \u0026amp;u3} err = BatchInsertUsers3(users3) if err != nil { fmt.Printf(\u0026#34;BatchInsertUsers3 failed, err:%v\\n\u0026#34;, err) } } sqlx.In的查询示例 关于 sqlx.In这里再补充一个用法，在 sqlx查询语句中实现In查询和FIND_IN_SET函数。即实现 SELECT * FROM user WHERE id in (3, 2, 1);和 SELECT * FROM user WHERE id in (3, 2, 1) ORDER BY FIND_IN_SET(id, '3,2,1');。\nin查询 查询id在给定id集合中的数据。\n1 2 3 4 5 6 7 8 9 10 11 12 13 // QueryByIDs 根据给定ID查询 func QueryByIDs(ids []int)(users []User, err error){ // 动态填充id query, args, err := sqlx.In(\u0026#34;SELECT name, age FROM user WHERE id IN (?)\u0026#34;, ids) if err != nil { return } // sqlx.In 返回带 `?` bindvar的查询语句, 我们使用Rebind()重新绑定它 query = DB.Rebind(query) err = DB.Select(\u0026amp;users, query, args...) return } in查询和FIND_IN_SET函数 查询id在给定id集合的数据并维持给定id集合的顺序。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 // QueryAndOrderByIDs 按照指定id查询并维护顺序 func QueryAndOrderByIDs(ids []int)(users []User, err error){ // 动态填充id strIDs := make([]string, 0, len(ids)) for _, id := range ids { strIDs = append(strIDs, fmt.Sprintf(\u0026#34;%d\u0026#34;, id)) } query, args, err := sqlx.In(\u0026#34;SELECT name, age FROM user WHERE id IN (?) ORDER BY FIND_IN_SET(id, ?)\u0026#34;, ids, strings.Join(strIDs, \u0026#34;,\u0026#34;)) if err != nil { return } // sqlx.In 返回带 `?` bindvar的查询语句, 我们使用Rebind()重新绑定它 query = DB.Rebind(query) err = DB.Select(\u0026amp;users, query, args...) return } 也可以先使用 IN查询，然后通过代码按给定的ids对查询结果进行排序。\n","date":"2020-09-09T00:00:00Z","permalink":"https://xiaonuoz.github.io/p/test-chinese11222/","title":"Chinese Test11222"},{"content":"title: golang接口 date: \u0026lsquo;2020-10-24 19:30:55\u0026rsquo; updated: \u0026lsquo;2020-11-05 17:54:34\u0026rsquo; tags: [golang学习] permalink: /articles/2020/10/24/1603539055067.html 接口也是一种类型，特殊的类型，它不关心对应方法的变量类型（接口只针对有接收者的函数，即方法）是什么，如fmt包的println函数可以传多种数据类型进行打印，接口常用于对不同变量类型定义一个相同方法名的方法（每个方法中的实现内容和结果都可能不同），这样就可以通过一个调用接口里函数的函数的参数的不同类型来调用不同数据类型的方法（可以少记很多方法名，且统一），可以用于连接各种不同数据库，采用同一函数，用传递进去的参数类型不同来区别连接哪种数据库\n一个变量如果实现了接口中规定的所有方法（必须是实现了所有方法），那么这个变量就实现了这个接口，也可以称为这个接口类型的变量，那么定义一个接口变量就可以接收该变量的值，最后接口变量的类型会由于接收赋值变成该变量的类型\n1 2 3 4 s1 := stu{name: \u0026#34;学生\u0026#34;} var s sayer s = s1 fmt.Printf(\u0026#34;%T\u0026#34;, s) 接口它自己不会存值，它的类型取决于给了它什么值，给什么值就是什么类型，接口类型定义时分配了一个动态类型和一个动态值，类型和值都为nil，然后将其他类型变量赋值给接口类型就是将值和值的类型赋值给接口，这样子就可以实现接口可以存任意类型的值。\n一个类型的方法通常我们会用指针接收者，因为这样可以对原数据进行修改，也可以对值接收者传递指针，但是这样依然不能更改到原数据\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 //定义一个接口类型，里面只有方法声明 type sayer interface { say() } //定义一个学生的结构体和方法 type stu struct { name string } func (s *stu) say() { fmt.Println(s.name, \u0026#34;say hi ttt\u0026#34;) s.name = \u0026#34;王五\u0026#34; } type tea struct { name string } func (t *tea) say() { fmt.Println(t.name, \u0026#34;say hi\u0026#34;) } func toSay(s sayer) { s.say() } func main() { s1 := stu{name: \u0026#34;学生\u0026#34;} toSay(\u0026amp;s1) fmt.Println(s1) } 关于接口需要注意的是：只有当有两个或两个以上的具体类型必须以相同的方式进行处理时才需要定义接口，不要为了写接口而定义接口，那样只会增加不必要的抽象，导致不必要的运行时损耗。\n接口命名习惯以er结尾，只有方法声明，\n没有实现也没有数据字段，但是方法是可以添加参数的\n然后在main函数中声明一个接口类型，var i Humaner,然后让 i 等于其他接收者的自定义类型，当 i 等于某个接收者类型它就会调用那个类型的同名方法，但是i等于其他接收者时，i只能调用属于i接口的方法，专属于接收者的方法以及其变量，接口都不能调用\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 //定义接口类型 type Hunmaner interface { sayhi() } //定义学生结构体类型 type student struct { name string id int } //定义学生方法 func (student) sayhi() { fmt.Println(\u0026#34;student say hi\u0026#34;) } //定义老师结构体类型 type teacher struct { name string addre string } //定义老师方法 func (teacher) sayhi() { fmt.Println(\u0026#34;teacher say hi\u0026#34;) } //实现多态，定义一个接口的方法，方法参数为接口类型，将其他接收者类型的实参传进去就可以实现调用不同方法 func whoSayhi(i Hunmaner){ i.sayhi() } func main() { //i等于学生结构体，i就可以调用学生的方法 var i Hunmaner i = student{name: \u0026#34;mike\u0026#34;} i.sayhi() //输出学生方法中的语句 //通过接口实现不同的方法 whoSayhi(student{name: \u0026#34;mike\u0026#34;}) i = teacher{name: \u0026#34;laoshi\u0026#34;} i.sayhi() //输出老师方法中的语句 } 也可以通过切片同时实现多种接收者的同名的方法\n接口也可以实现继承（使用匿名字段），当定义一个Personer变量时，它可以调用父级的sayhi()方法也可以调用自身的sing()方法\n父级可以等于子级的值，反过来则不可以（由多的向少的转换）,如 定义一个父级i，让i等于子级iPro，i=iPro是可以的，注意语法是 父级=子级，这个作用于设置子级的值，然后将子级的值赋给父级使用，父级只能使用属于父级的方法，子级的方法无法使用\n空接口 如何判断一个空接口变量中值的类型（value.(type)） ,ok模式常用于测试map的对应key是否有值，有值ok为ture，没有则为false，value用于存放为true时将空接口类型中的值强转成对应类型的值，为false时为对应类型的零值\n1 2 i := map[int]string{1: \u0026#34;a\u0026#34;} value, ok := i[1] 还有另外五种用法（https://zhuanlan.zhihu.com/p/129220255）\n有一种用法是判断空接口类型变量的type（切片和数组无法使用这个，因为它们两个在定义之初就已经确定了类型），value的返回依然是ok为true时将空接口类型中的值强转成对应类型的值，为false时存对应类型的零值\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 i := make([]interface{}, 3) i[0] = 1 i[1] = \u0026#34;str\u0026#34; i[2] = stu{\u0026#34;mike\u0026#34;} for _, deta := range i { if value, ok := deta.(int); ok == true { fmt.Println(\u0026#34;这是一个整型\u0026#34;, value) } else if value, ok := deta.(string); ok == true { fmt.Println(\u0026#34;这是一个字符串\u0026#34;, value) } else if value, ok := deta.(stu); ok == true { fmt.Println(\u0026#34;这是一个结构体类型\u0026#34;, value) } } //也可以使用switch方法，用此方法时括号中为type for _, deta := range i { switch value := deta.(type) { case int: fmt.Println(\u0026#34;这是一个整型\u0026#34;, value) case string: fmt.Println(\u0026#34;这是一个字符串\u0026#34;, value) case stu: fmt.Println(\u0026#34;这是一个结构体类型\u0026#34;, value) } } 反射 **反射是指在程序运行期对程序本身进行访问和修改的能力。**程序在编译时，变量被转换为内存地址，变量名不会被编译器写入到可执行部分。在运行程序时，程序无法获取自身的信息。(如函数的参数是一个空接口类型，那么在程序编译时它是不知道这个空接口存入什么类型的，只有在运行到此函数时才能确定)\n支持反射的语言可以在程序编译期将变量的反射信息，如字段名称、类型信息、结构体信息等整合到可执行文件中，并给程序提供接口访问反射信息，这样就可以在程序运行期获取类型的反射信息，并且有能力修改它们。\nGo程序在运行期使用reflect包访问程序的反射信息。\nreflect包 在Go语言的反射机制中，任何接口值都由是 一个具体类型和 具体类型的值两部分组成的(动态类型和动态值)。 在Go语言中反射的相关功能由内置的reflect包提供，任意接口值在反射中都可以理解为由 reflect.Type和 reflect.Value两部分组成，并且reflect包提供了 reflect.TypeOf和 reflect.ValueOf两个函数来获取任意对象的Value和Type。reflect.TypeOf(a)返回值存的是原始值的类型，但此返回值的类型是 *reflect.rtype\n在反射中关于类型还划分为两种：类型（Type）和 种类（Kind）。因为在Go语言中我们可以使用type关键字构造很多自定义类型，而 种类（Kind）就是指底层的类型，但在反射中，当需要区分指针、结构体等大品种的类型时，就会用到 种类（Kind）。通过reflect.TypeOf(a)返回值的name()方法取到的是具体类型，kind()方法取到的是种类（如结构体）\nValueOf reflect.ValueOf()返回的是 reflect.Value类型，其中包含了原始值的值信息。b与原始值之间可以互相转换。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 func reflectValue(x interface{}) { v := reflect.ValueOf(x) k := v.Kind()\t//这个kind是获取值的类型种类 switch k { case reflect.Int64: // v.Int()从反射中获取整型的原始值，然后通过int64()强制类型转换 fmt.Printf(\u0026#34;type is int64, value is %d\\n\u0026#34;, int64(v.Int())) case reflect.Float32: // v.Float()从反射中获取浮点型的原始值，然后通过float32()强制类型转换 fmt.Printf(\u0026#34;type is float32, value is %f\\n\u0026#34;, float32(v.Float())) case reflect.Float64: // v.Float()从反射中获取浮点型的原始值，然后通过float64()强制类型转换 fmt.Printf(\u0026#34;type is float64, value is %f\\n\u0026#34;, float64(v.Float())) } } func main() { var a float32 = 3.14 var b int64 = 100 reflectValue(a) // type is float32, value is 3.140000 reflectValue(b) // type is int64, value is 100 // 将int类型的原始值转换为reflect.Value类型 c := reflect.ValueOf(10) fmt.Printf(\u0026#34;type c :%T\\n\u0026#34;, c) // type c :reflect.Value } ValueOf没有int64、int32之类的，它只有int、float等\n参考文档： https://www.liwenzhou.com/posts/Go/13_reflect/\n实现对ini配置文件的反射（将ini中的内容写入到结构体中） 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 package main import ( \u0026#34;errors\u0026#34; \u0026#34;fmt\u0026#34; \u0026#34;io/ioutil\u0026#34; \u0026#34;reflect\u0026#34; \u0026#34;strconv\u0026#34; \u0026#34;strings\u0026#34; ) type MysqlConfig struct { Address string `ini:\u0026#34;address\u0026#34;` Port int `ini:\u0026#34;port\u0026#34;` Username string `ini:\u0026#34;username\u0026#34;` Password string `ini:\u0026#34;password\u0026#34;` } type RedisConfig struct { Host string `ini:\u0026#34;host\u0026#34;` Port int `ini:\u0026#34;port\u0026#34;` Password string `ini:\u0026#34;password\u0026#34;` Database uint8 `ini:\u0026#34;database\u0026#34;` } //嵌套结构体，用于关联配置文件和结构体 type Config struct { MysqlConfig `ini:\u0026#34;mysql\u0026#34;` RedisConfig `ini:\u0026#34;redis\u0026#34;` } func loadIni(b []byte, data interface{}) error { //1.参数的校验 t := reflect.TypeOf(data) //1.1 传进来的data参数必须是指针类型（因为需要在函数中对其赋值，不使用指针就是修改的副本） if t.Kind() != reflect.Ptr { err := errors.New(\u0026#34;传入的参数不是指针\u0026#34;) return err } //1.2 传进来的data参数必须是结构体类型指针（因为配置文件中各种键值对需要赋值给结构体字段） if t.Elem().Kind() != reflect.Struct { //Elem()方法可以由对应的指针函数获取到相应的值 err := errors.New(\u0026#34;传入的参数不是结构体指针\u0026#34;) return err } var structName string //2.一行一行的读数据,先将传进来的字节切片以换行切成字符串切片，windows中换行是\\r\\n lineStr := strings.Split(string(b), \u0026#34;\\r\\n\u0026#34;) for index, line := range lineStr { //先去掉首尾空格 line = strings.TrimSpace(line) //如果是空行就跳过 if len(line)==0{ continue } // 如果是注释就跳过，首字母是#或者; if strings.HasPrefix(line, \u0026#34;#\u0026#34;) || strings.HasPrefix(line, \u0026#34;;\u0026#34;) { continue } //加判断避免以 ] 开头 if strings.HasPrefix(line, \u0026#34;]\u0026#34;) { err := fmt.Errorf(\u0026#34;节点定义错误，line:%d\u0026#34;, index+1) return err } // 如果是[开头就表示是节(section) if strings.HasPrefix(line, \u0026#34;[\u0026#34;) { if line[len(line)-1] != \u0026#39;]\u0026#39; { err := fmt.Errorf(\u0026#34;节点定义错误，line:%d\u0026#34;, index+1) return err } //先切出不包含[]的内容，然后去空格，最好统计长度为0则表示节点中全是空格或者未写 sectionName := strings.TrimSpace(line[1 : len(line)-1]) if len(sectionName) == 0 { err := fmt.Errorf(\u0026#34;节点定义错误，line:%d\u0026#34;, index+1) return err } //根据字符串sectionName去data里面根据反射找到对应的结构体,NumField()返回对应结构体的字段个数 for i := 0; i \u0026lt; t.Elem().NumField(); i++ { filed := t.Elem().Field(i) //找到对应的结构体 if sectionName ==filed.Tag.Get(\u0026#34;ini\u0026#34;) { structName=filed.Name\t//filed.Name指对应结构体名 } } } else { // 不是节点才是需要的键值对 //\t1.1 以等号分隔这一行，等号左边是key，右边是value //如果不包含=，行首或者行位是=就抛出错误 if strings.Index(line,\u0026#34;=\u0026#34;) ==-1 || strings.HasPrefix(line,\u0026#34;=\u0026#34;)||strings.HasSuffix(line,\u0026#34;=\u0026#34;){ err:=fmt.Errorf(\u0026#34;第%d行语法错误\u0026#34;,index+1) return err } idx:=strings.Index(line,\u0026#34;=\u0026#34;) key:=line[:idx]\t//ini中的key value:=line[idx+1:]\t//ini中的value // 1.2 根据structName去data里面把对应的嵌套结构体取出来 v :=reflect.ValueOf(data) sValue:=v.Elem().FieldByName(structName)\t//拿到嵌套结构体中的子结构体值信息 sType:=sValue.Type()\t//拿到嵌套结构体中的子结构体累心信息 if sValue.Kind()!=reflect.Struct{ err:=fmt.Errorf(\u0026#34;%s不是一个结构体\u0026#34;,structName) return err } var filedName string var filedType reflect.StructField // 1.3 遍历嵌套结构体的每一个字段，判断tag是否等于key for i:=0;i\u0026lt;sValue.NumField();i++{ filed:=sType.Field(i)\t//找到对应子结构体的成员 filedType=filed\t//tag是存储在类型信息中的 //将结构体ini的字段和配置文件中的字段进行比较，相等则赋值 if filed.Tag.Get(\u0026#34;ini\u0026#34;)==key{ filedName=filed.Name\t//filed.Name返回结构体的成员名 break } } //for循环过后如果filedName为0则表示在结构体中没找到这个字段，直接跳过 if len(filedName) ==0 { continue } // 1.4 根据filedName取出这个字段并赋值 filedObj:=sValue.FieldByName(filedName) switch filedType.Type.Kind() { case reflect.String: filedObj.SetString(value) case reflect.Int,reflect.Int8,reflect.Int16,reflect.Int32,reflect.Int64: valueInt,err:=strconv.ParseInt(value,10,64) if err!=nil{ err=fmt.Errorf(\u0026#34;int转换失败,line:%d\u0026#34;,index+1) return err } filedObj.SetInt(valueInt) } } } return nil } func main() { var cfg Config //使用ReadFile可以直接将文件内容全部读取出来，然后存进变量。 //用os.open()来一行行的读取会让程序运行时文件一直处于打开状态 buf, err := ioutil.ReadFile(\u0026#34;./config.ini\u0026#34;) if err != nil { fmt.Printf(\u0026#34;read file faild,err:%v\\n\u0026#34;, err) return } err = loadIni(buf, \u0026amp;cfg) if err != nil { fmt.Printf(\u0026#34;loadIni file faild,err:%v\\n\u0026#34;, err) return } fmt.Println(cfg) } ini配置文件：\n1 2 3 4 5 6 7 8 9 10 11 12 13 ; mysql config [mysql] address=10.20.30.40 port=3306 username=root password=123456 # redis config [redis] host=127.0.0.1 port=6379 password=root database=0 ","date":"0001-01-01T00:00:00Z","permalink":"https://xiaonuoz.github.io/p/","title":""},{"content":"title: golang日志库的简单实现 date: \u0026lsquo;2020-10-29 11:05:15\u0026rsquo; updated: \u0026lsquo;2020-11-10 20:01:53\u0026rsquo; tags: [golang学习] permalink: /articles/2020/10/29/1603940715811.html 在开发过程中，通常我们会将信息输出到终端来查看变量和结果是否和预想的一样，但是如果丢到线上后依然是输出到终端的话，它就会占用部分资源，但是我们并没有使用到，并且后期出错查询也很困难，因此写一个在开发过程中输出到终端，在编译后输出到文件的程序很有必要\n1 2 3 4 5 fileObj,_:=os.OpenFile(\u0026#34;./xx.log\u0026#34;,os.O_APPEND|os.O_CREATE|os.O_WRONLY,0644) //设置日志输出位置为fileObj，默认的值是os.Stdout,即终端 log.SetOutput(fileObj) log.Printf(\u0026#34;这是一条错误输出\u0026#34;) time.Sleep(3*time.Second) 需求分析 支持往不同的地方输出日志（终端和文件中） 日志分级别 Debug Trace Info Warning Error Fatal 日志要支持级别开关控制，比如说开发的时候所有级别都输出，但是上线后只有INFO级别往下的才能输出 完整的日志记录要包含时间、行号、文件名、日志级别、日志信息 日志文件要切割 按文件大小切割 我们初始化时有设置一个maxFileSize文件最大值，可以通过在每次写日志时都判断一下当前文件大小来进行切割 按日志切割（直接将文件名设置为当前时间就可以通过日志切割） runtime.Caller() pc,file,line,ok:=runtime.Caller(skip int) 这个函数是运行时gc的获取的部分信息，它返回四个值\npc返回的是执行函数指针，可以通过这个获取函数名runtime.FuncForPC(pc).Name()等信息 file是执行函数所在文件名目录，使用path.Base(file)可以获取到绝对路径中的最后一层目录， line是执行的函数所在行号 ok 是否可以获取到信息,返回false时前面三个值都为零值 执行函数指的是调用Caller的那个函数，通过skip可以向上调用更高级别的执行函数信息\nskip是要提升的堆栈帧数，如就在当前函数调用的Caller，它的值就是0，如果要在另一个函数调用它，并且获取的值要是另一个函数的，那它就得提升一个，即为1，如果main再调用，想获取main的信息，就是2，即a函数调用caller就升一层，b调用a再升一层，想获取b的信息skip就为2\n代码 公用代码：logPublicfunc.go 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 package mylogger import ( \u0026#34;fmt\u0026#34; \u0026#34;strings\u0026#34; ) //定义一个接口处理两种不同日志 type Logger interface { Debug(format string,a ...interface{}) Info(format string,a ...interface{}) } //定义日志级别为非0的整数，使用type可以在以后打印类型时知道它的作用，而uint则无法理解用于什么地方 type LogLevel uint16 //设置每个级别对应的uint16值，unknow为0，表示输入的格式不正确 const ( UNKNOW LogLevel =iota DEBUG INFO ) //通过传入的字符串来判断级别，返回的是uint常量 func parseLogLevel(s string) (LogLevel,error){ //将传入的字符串全部转为大写 s=strings.ToUpper(s) switch s { case \u0026#34;DEBUG\u0026#34;: return DEBUG,nil case \u0026#34;INFO\u0026#34;: return INFO,nil default: //创建一个err，如果err不为空则是输入有误 err:=fmt.Errorf(\u0026#34;无效的日志级别，请检查\u0026#34;) return UNKNOW,err } } func getLogString(lv LogLevel) string{ switch lv { case DEBUG: return \u0026#34;DEBUG\u0026#34; case INFO: return \u0026#34;INFO\u0026#34; default: return \u0026#34;UNKNOW\u0026#34; } } 日志写到终端中：consolelogger.go 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 package mylogger //往终端中写日志 import ( \u0026#34;fmt\u0026#34; \u0026#34;os\u0026#34; \u0026#34;time\u0026#34; ) //自定义一个日志库结构体 type ConsoleLogger struct { Level LogLevel } //初始化一个Logger结构体 func NewConsoleLogger(s string) *ConsoleLogger{ level,err:=parseLogLevel(s) if err!=nil{ //如果err不为空，则level为零值=0,0对应着UNKNOW fmt.Println(err) os.Exit(0) } return \u0026amp;ConsoleLogger{Level: level} } //实现开关级别,通过对象和参数的比较来执行比设置的级别高的日志消息 func (c *ConsoleLogger)enable(loglevel LogLevel)bool{ return loglevel\u0026gt;=c.Level } //可以通过可变参数（参照fmt.Printf函数）实现格式化输出,实现传变量进字符串 //Sprintf返回一个格式化好的字符串 func (c *ConsoleLogger)logFmt(lv LogLevel,format string,a ...interface{}){ //设置日志时间格式 var timeInit =time.Now().Format(\u0026#34;2006-01-02 15:04:05\u0026#34;) if c.enable(lv){ msg:=fmt.Sprintf(format,a...) fmt.Fprintf(os.Stdout,\u0026#34;[%s] [%s] %s\\n\u0026#34;,timeInit,getLogString(lv),msg) } } func (c *ConsoleLogger)Debug(format string,a ...interface{}){ c.logFmt(DEBUG,format,a...) } func (c *ConsoleLogger)Info(format string,a ...interface{}){ c.logFmt(INFO,format,a...) } 日志写到文件中，且以大小分隔：fileLogger.go 可以使用channel让日志和业务代码分开来，写日志不影响正常业务的运行。写日志报错只会导致日志写入失败，但是程序依然在运行\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 package mylogger import ( \u0026#34;fmt\u0026#34; \u0026#34;os\u0026#34; \u0026#34;path\u0026#34; \u0026#34;time\u0026#34; ) //往文件中写日志 type FileLogger struct { Level LogLevel FileName string\t//日志文件保存的文件名 FilePath string\t//日志文件保存的路径 MaxFileSize int64 //每个日志文件的最大值 FileObj *os.File\t//初始化时打开一个文件 ErrFileObj *os.File\t//记录错误日志的文件 logChan chan *logMsg\t//管道，用于存放日志信息 } type logMsg struct { level LogLevel\t//日志级别 msg string\t//日志信息 timestamp string //时间戳 } //初始化一个Logger结构体 func NewFileLogger(s,fileName,filePath string,maxFileSize int64) *FileLogger{ level,err:=parseLogLevel(s) if err!=nil{ //如果err不为空，则level为零值=0,0对应着UNKNOW fmt.Println(err) os.Exit(0) } f1:= \u0026amp;FileLogger{ Level: level, FileName:fileName, FilePath: filePath, MaxFileSize: maxFileSize, logChan: make(chan *logMsg,50000), } err1:=f1.initFile() if err1!=nil{ //日志文件都无法打开，直接panic中断程序运行 panic(err1) } return f1 } //实现开关级别,通过对象和参数的比较来执行比设置的级别高的日志消息 func (f *FileLogger)enable(loglevel LogLevel)bool{ return loglevel\u0026gt;=f.Level } //初始化，打开一个文件向内写日志 func (f *FileLogger)initFile() error{ //拼接文件路径和文件名，然后打开此文件，没有就进行创建 fullFileName:=path.Join(f.FilePath,f.FileName) fileObj,err:=os.OpenFile(fullFileName,os.O_APPEND|os.O_CREATE|os.O_WRONLY,0644) if err!=nil{ fmt.Printf(\u0026#34;open log file failed,err:%v\u0026#34;,err) return err } //专门记录错误的日志 errfileObj,err:=os.OpenFile(fullFileName+\u0026#34;.err\u0026#34;,os.O_APPEND|os.O_CREATE|os.O_WRONLY,0644) if err!=nil{ fmt.Printf(\u0026#34;open log file failed,err:%v\u0026#34;,err) return err } f.FileObj=fileObj f.ErrFileObj=errfileObj //开启一个后台goroutine往文件内写日志 //不能开启多个，因为同一时间不能有多个程序操作同一个文件 go f.writeLogBackground() //return nil可以实现调用此方法时加if判断来判断是否有错误 return nil } //判断当前文件大小，超过指定值就进行切割，将要写入的文件传进去判断 func (f *FileLogger)checkSize(file *os.File) bool{ fileInfo,err:=file.Stat() if err!=nil{ fmt.Printf(\u0026#34;get file info failed,err:%v\\n\u0026#34;,err) return false } //如果当前文件大小大于等于预设时文件的最大值，就应该返回true，进行切割 return fileInfo.Size()\u0026gt;=f.MaxFileSize } func (f *FileLogger)splitFile(file *os.File) (*os.File,error){ //此时则需要进行文件切割,如果返回为false就会直接跳过该判断，继续往原文件写内容 fileInfo,err:=file.Stat() if err!=nil{ fmt.Printf(\u0026#34;open file faile,err:%v\\n\u0026#34;,err) return nil,err } //然后rename原文件,fileInfo.Name()可以获取文件名，可以同时适配普通文件和错误文件 logName:=path.Join(f.FilePath,fileInfo.Name())//拿到当前日志的路径，join的拼接是用/来拼接的 //在重命名时要先关闭当前的日志文件 nowStr:=time.Now().Format(\u0026#34;20060102150405\u0026#34;)//获取当前时间 file.Close() newName:=logName+\u0026#34;.bak\u0026#34;+nowStr os.Rename(logName,newName)//重命名 //打开新的文件并赋值给FileObj fileObj,err:=os.OpenFile(logName,os.O_APPEND|os.O_CREATE|os.O_WRONLY,0644) if err!=nil{ fmt.Printf(\u0026#34;open file faild,err:%v\\n\u0026#34;,err) return f.FileObj,err } return fileObj,nil } //开携程让日志和业务代码区分开 func (f *FileLogger)writeLogBackground(){ //用for循环让此函数一直运行等待从管道中取数据 for{ //普通日志文件分割 if f.checkSize(f.FileObj){ fileObj,err:=f.splitFile(f.FileObj) if err!=nil{ fmt.Printf(\u0026#34;open file faild,err:%v\\n\u0026#34;,err) return } f.FileObj=fileObj } select { //如果无法从logChan中取出数据，就一直阻塞在此处 case logtmp:=\u0026lt;-f.logChan: logInfo:=fmt.Sprintf(\u0026#34;[%s] [%s] %s\\n\u0026#34;,logtmp.timestamp,getLogString(logtmp.level),logtmp.msg) fmt.Fprintf(f.FileObj,logInfo) //错误日志文件分割 if logtmp.level\u0026gt;=INFO{ if f.checkSize(f.ErrFileObj){ errfileObj,err:=f.splitFile(f.ErrFileObj) if err!=nil{ fmt.Printf(\u0026#34;open file faild,err:%v\u0026#34;,err) return } f.ErrFileObj=errfileObj } //如果要记录的日志等级（输入的参数）大于等于INFO级别，则还要在err日志文件中再记录一遍 fmt.Fprintf(f.ErrFileObj,logInfo) } } } } //可以通过可变参数（参照fmt.Printf函数）实现格式化输出,实现传变量进字符串 //Sprintf返回一个格式化好的字符串 func (f *FileLogger)logFmt(lv LogLevel,format string,a ...interface{}){ if f.enable(lv){ //设置日志时间格式 var timeInit =time.Now().Format(\u0026#34;2006-01-02 15:04:05\u0026#34;) msg:=fmt.Sprintf(format,a...) //先把日志发到通道中 logtmp:=\u0026amp;logMsg{level: lv,msg:msg,timestamp: timeInit} //通过select监听管道，避免极端情况下通道阻塞影响业务代码的运行 //写的进去和写不进去都直接跳过，然后继续执行代码 select { case f.logChan\u0026lt;-logtmp: default: //如果写不进去就进行跳过，保证业务代码正常运行，但是此时日志写不进去（极端情况） } } } func (f *FileLogger)Debug(format string,a ...interface{}){ f.logFmt(DEBUG,format,a...) } func (f *FileLogger)Info(format string,a ...interface{}){ f.logFmt(INFO,format,a...) } //在用完后记得关闭文件 func (f *FileLogger)Close(){ f.FileObj.Close() f.ErrFileObj.Close() } main文件：logermain.go 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 package main import ( \u0026#34;mylogger\u0026#34; \u0026#34;time\u0026#34; ) var logger mylogger.Logger func main() { //这里的参数表示会输出大于等于debug等级的日志 //可以在consolelogger.go中设置大于则输出到终端，小于则输出到文件中 //输出到终端 logger = mylogger.NewConsoleLogger(\u0026#34;debug\u0026#34;) for i:=0;i\u0026lt;2;i++{ logger.Debug(\u0026#34;我是一条debug消息\u0026#34;) id:=10010 name:=\u0026#34;张三\u0026#34; logger.Info(\u0026#34;我是一条info消息，来自%d-%s\u0026#34;,id,name) } //输出到文件中 logger=mylogger.NewFileLogger(\u0026#34;info\u0026#34;,time.Now().Format(\u0026#34;2006-01-02\u0026#34;),\u0026#34;./\u0026#34;,10*1024)//for { //如果消息级别为0表示是错误的等级 for{ logger.Debug(\u0026#34;我是一条debug消息\u0026#34;) id:=10010 name:=\u0026#34;张三\u0026#34; logger.Info(\u0026#34;我是一条info消息，来自%d-%s\u0026#34;,id,name) } } ","date":"0001-01-01T00:00:00Z","permalink":"https://xiaonuoz.github.io/p/","title":""},{"content":"title: golang的小知识点 date: \u0026lsquo;2020-10-12 21:56:03\u0026rsquo; updated: \u0026lsquo;2022-02-21 17:35:14\u0026rsquo; tags: [golang学习] permalink: /articles/2020/10/12/1602510963133.html uint类型不能有负数，int类型可以为正也可以为负\ngoroutinue 1 2 3 4 5 6 7 8 9 10 11 12 13 14 go func() { func() { fmt.Println(\u0026#34;这是子go\u0026#34;) // 退出当前函数（此匿名函数） // return // 退出当前进程（主携程加子携程合在一起是一个进程,似崩溃） // os.Exit(-1) // 退出当前子携程 runtime.Goexit() }() fmt.Println(\u0026#34;子go over\u0026#34;) }() time.Sleep(2 * time.Second) fmt.Println(\u0026#34;主go over\u0026#34;) 对于有缓冲的通道，如果写的次数和读的次数不一样就会造成严重的问题，会无限阻塞，在主程序出现就会崩溃死锁，在子携程中阻塞就会内存泄漏。所以最好使用for range来对管道进行读，写完所有数据后最好进行close来关闭这个管道，这样在读的for range中如果发现读的是一个已经关闭的管道（此时管道关闭，无法继续往里面写数据，会崩溃），那它读完这个管道中的所有数据后就会跳出循环。且close要写在写端，如果在读端，和写端速度不一致会导致可能有数据还在往里面写\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 channels := make(chan int, 10) go func() { for i := 0; i \u0026lt; 2; i++ { time.Sleep(time.Second) channels \u0026lt;- i } close(channels) }() // for range是不知道管道是否已经写完了的，因此当写的携程结束后这边依然在等待新的数据，就会死锁 // 所以要在写完数据之后关闭管道，这样管道就变为了nil，for range遍历关闭的管道时会退出 for v := range channels { fmt.Println(\u0026#34;开始读取\u0026#34;) fmt.Println(v) fmt.Println(\u0026#34;结束读取\u0026#34;) } 可以通过 v,ok:=\u0026lt;-channel 来判断管道是否已经关闭，ok为false则表示没从管道中取出数据，v为对应类型的零值\nbyte和rune类型 组成字符串的元素叫做字符，可以通过遍历（range）或者下标获取单个字符（s[0]）。字符用单引号括起来，字符串用双引号\n当需要处理中文日文等，需要用到rune类型，它实际上是一个int32\n1 2 3 4 s1 := \u0026#34;白萝卜\u0026#34; s2 := []rune(s1) fmt.Println(string(s2[1])) 如果不使用rune直接调用s1，最后出现的会是一个乱码 单词字母可以直接遍历，它属于byte类型\nGO语言中只有显式强制类型转换(var a float32 =float32(n))，没有隐式转换。该语法只能在两个类型相互支持转换的时候使用（int到float，string到切片等）\n1 2 3 //数组可以通过...来自动推断后续数组初始化值的长度 a1 := [...]int{1, 2, 3, 4, 5, 6, 7} fmt.Println(a1) 切片 当使用var定义了切片或map却没有使用make时，它是对应的零值nil，nil时是无法调用成员的，所以需要make，而结构体的零值不是nil，它里面有对应的成员零值\n切片的容量cap()是指从第一个切片所对应的底层数组元素到底层数组最后一个元素的元素总数量\n切片是引用类型，都指向了底层的一个数组，即修改切片会修改到底层数组（切片不保存值，它操作的是底层数组的值），修改数组会影响到切片\n1 2 3 4 5 6 7 8 9 10 a1 := [...]int{1, 3, 5, 7, 8} s1 := a1[:] s1 = append(s1, 555) s1[3] = 777 fmt.Println(s1) fmt.Println(a1) 输出结果： [1 3 5 777 8 555] [1 3 5 7 8] 当切片追加一个元素且超过原数组最大值后，它会重新创建一个属于自己的底层数组，再修改切片的值就不会让原底层数组发送改变\n会报panic错误，因为定义了一个int类型的指针但是没有初始化，默认指针值为nil，对空指针所对应的内容进去赋值是不可能的，所以需要使用new函数来申请一个内存地址\tvar a = new(int)\nmap如果没有进行初始化（make），它就没有在内存中开辟空间，默认值为nil，是无法往map中写入数据的\n切片，map动态扩容会影响到性能，最好是在创建时就直接估算好\nmap可以用value ,ok :=m1[\u0026ldquo;key\u0026rdquo;]来判断key对应的值是否存在，返回的布尔值存在ok中\ncopy复制切片要注意：目标切片如果make出的容量不足以复制源切片的全部元素时，会复制从0开始的部分元素，如果目标切片make给的长度是0，copy是不会自动扩容的，则没有元素复制过去\n1 if unicode.Is(unicode.Han,char) 判断一个字符是不是汉字，unicode.Han 函数类型也可以作为另一个函数的参数和返回值，传参和返回时千万不要加括号，加上括号表示调用此函数方法，不加就是作为参数或者返回值使用\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 func f1(x int){ fmt.Println(\u0026#34;我是f1\u0026#34;) } func f2(x,y int) int{ return x+y } func f3(x func(int)) func(int,int)int{ return f2 } func main(){ f4:=f3(f1) fmt.Println(f4(5,10)) } defer延迟加载在注册时就会将变量的状态代入进去，会先进入代入延迟加载中的变量的值，即a会先代入1这个值，后面a改变也不会影响到defer的值，如果defer函数中嵌套了函数calc(20,add())，它也会先将里面的函数(add)计算出值然后再搁置在最后结束时运行defer,defer只会保存最外层的函数至最后执行\n1 2 3 a:=1 defer fmt.Println(a) a=2 构造函数（结构体） 约定成俗用new开头作为构造函数\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 type person struct { name string age int } func newPerson(name string,age int) *person{ return \u0026amp;person{ name:name, age:age, } } func main() { p1:=newPerson(\u0026#34;张三\u0026#34;,12) fmt.Println(p1) } 结构体可以使用声明的方式产生新的变量，也可以通过函数来产生，通过函数产生时最好返回值为结构体的指针，减少程序的内存开销，因为结构体属于值传递，如果不使用指针就是将函数返回值拷贝一份给变量，当结构体的元素更多或者使用函数的次数更多，会给内存造成压力，而且复制指针比复制结构体内容要更快，内存压力更小\n方法 只能给自己定义的类型添加方法，是无法给go标准库中的(int,string等)类型和别的包里面的类型添加方法的，所以才有type myInt int这种情况，给其他包添加方法也可以通过type来实现\n方法的接受者形参约定成俗用类型的首字母小写来定义，接受者分为指针传递和值传递，如果是值传递，那么方法内部对变量的改变不会影响到外部，且建议当同一类型的某个方法使用了指针接受者，其他方法也应该用指针接受者\n一般都使用指针接受者，因为如果结构体成员过多，值传递拷贝会影响内存的占用，而指针永远都是一个uint64类型的值\ntime包 time.Now()记录了当前时间，time.Now().Year()可以获取当前年，还有Month，Day等\ntime.Now().Unix()表示从1970年1月1日8点整到现在的时间戳，UnixNano()精确到纳秒\ntime.Unix()可以将时间戳转换为时间格式\ntime有个add方法可以进行时间增加，如当前时间的5小时后为 time.Now().Add(5*time.Hour)\n格式化时间将时间对象转换成字符串类型的时间，使用 time.Now().Format(2006-01-02 15:04:05),它使用的是GO的诞生时间2006年1月2日15点4分5秒（可以记作2006 1 2 3 4 5），如果想用12小时制的在后面加个PM即可\n按照对应字符串格式将字符串时间解析成时间对象类型 使用Parse()方法来进行解析\n1 2 3 4 5 6 t,err:=time.Parse(\u0026#34;2006-01-02\u0026#34;,\u0026#34;1998-01-19\u0026#34;) if err!=nil{ fmt.Println(\u0026#34;输入的时间格式不对\u0026#34;) return } fmt.Println(t) 对于求两个时间间隔的结果不准确的解决方案 1 2 3 4 5 6 7 8 9 10 11 //Now()会按照本地时间获取，而Parse则会按照UTC时间获取，因此两者相减的时间(如果本地不是UTC时间)会比正常情况多几个小时 now := time.Now() tim, _ := time.Parse(\u0026#34;2006-01-02 15:04:05\u0026#34;, \u0026#34;2020-10-29 22:00:00\u0026#34;) d := tim.Sub(now) fmt.Println(d) //按照指定时区解析时间 loc, _ := time.LoadLocation(\u0026#34;Asia/Shanghai\u0026#34;) tim1, _ := time.ParseInLocation(\u0026#34;2006-01-02 15:04:05\u0026#34;, \u0026#34;2020-10-29 22:00:00\u0026#34;, loc) d1 := tim1.Sub(now) fmt.Println(d1) 对于可变参数的理解 1 2 3 4 5 6 7 8 9 10 func f1(a ...interface{}){ fmt.Println(a) fmt.Println(a...) } func main(){ f1(1,2,3) } 输出结果： [1 2 3]\t//这个为一个变量的输出 1 2 3\t//这是三个变量 在使用函数的可变参数时（只有空接口类型才能使用三个\u0026hellip;进行拆解），在参数后面加三个点表示拆开可变参数生成的切片，分成多个变量，如果不加三个点就表示将a作为一个空接口切片类型传入\n在golang中，栈（stack）和堆（heap）存的东西不一样，栈存的是对应类型的名字，堆存的是对应类型的具体数据，由栈指向堆\n使用map时，value如果是一个结构体，必须使用指针类型，map里结构体无法直接寻址，必须取址 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 var i map[string]*Age=make(map[string]*Age) i[\u0026#34;张文\u0026#34;]=\u0026amp;Age{Id: 23} i[\u0026#34;利尔\u0026#34;]=\u0026amp;Age{Id: 38} //此处map的value如果不是地址而是结构体本身的话，v的地址一直都是一个地址，遍历只是将新的值覆盖到旧地址上。并且它是无法寻址的，即无法找到对应结构体的成员进行改变 for _,v:=range i{ v.Id=v.Id+3 } //将结构体赋值给map则需要这样 for i:=0;i\u0026lt;len(ages);i++{ x[ages[i].Name]=\u0026amp;ages[i] } for _,v:=range i{ fmt.Println(v.Id) } 重写sort方法实现结构体的排序 1 2 3 4 5 6 7 8 9 10 11 // SortByReadBook 按照阅读量排序，定义一个结构体是原结构体的切片 type SortByReadBook []ReadLeaderboardResp func (s SortByReadBook) Len() int { return len(s) } //重写len方法 func (s SortByReadBook) Swap(i, j int) { s[i], s[j] = s[j], s[i] } //重写swap方法 func (s SortByReadBook) Less(i, j int) bool {\t//重写less方法 //uint用大于小于，Decimal使用自身的lessThan方法 return s[i].ReadBookCount \u0026gt; (s[j].ReadBookCount) } 调用时则使用sort方法，强转原结构体 sort.Sort(SortByReadBook(readLeader)) vscode 调试配置 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 { // 使用 IntelliSense 了解相关属性。 // 悬停以查看现有属性的描述。 // 欲了解更多信息，请访问: https://go.microsoft.com/fwlink/?linkid=830387 \u0026#34;version\u0026#34;: \u0026#34;0.2.0\u0026#34;, \u0026#34;configurations\u0026#34;: [ { \u0026#34;name\u0026#34;: \u0026#34;Launch Package\u0026#34;, \u0026#34;type\u0026#34;: \u0026#34;go\u0026#34;, \u0026#34;request\u0026#34;: \u0026#34;launch\u0026#34;, \u0026#34;mode\u0026#34;: \u0026#34;auto\u0026#34;, \u0026#34;program\u0026#34;: \u0026#34;${workspaceFolder}//cmd//operation//main.go\u0026#34; } ] } 结构体的String方法 1 2 3 4 5 6 7 8 9 10 11 12 type Test struct { name string } func (t Test) String() string { return t.name + \u0026#34;======111\u0026#34; } func main() { t := Test{\u0026#34;张三\u0026#34;} fmt.Println(t) } 如果给结构体绑定一个String的方法，那么在打印时只打印此结构体会隐式的调用此结构体的String方法\n通过reflect.Value修改值 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 type test struct { Name string Age int } func main() { t := reflect.ValueOf(\u0026amp;test{\u0026#34;张三\u0026#34;, 18}) // a reflect.Type switch t.Kind() { case reflect.Ptr: if t.IsNil() { log.Println(\u0026#34;this is nil\u0026#34;) } else { va := t.Elem() for i := 0; i \u0026lt; va.NumField(); i++ { // 1. 针对结构体成员是小写不公开的情况需要这种 // temp := va.Addr().Interface().(*test) // temp.name = \u0026#34;李四\u0026#34; // 2. 公开的可以直接通过set方法来设置 if va.Type().Field(i).Name == \u0026#34;Name\u0026#34; { fmt.Println(\u0026#34;true\u0026#34;) va.Field(i).SetString(\u0026#34;历史\u0026#34;) } } } } fmt.Println(t) } golang是没有野指针的，因为只要有一个指针指向函数返回的变量，它就不会被回收。Go语言的内存回收机制规定，只要有一个指针指向一个变量，那么这个变量就不会被释放（内存逃逸），因此在 Go 语言中返回函数参数或临时变量是安全的。\n","date":"0001-01-01T00:00:00Z","permalink":"https://xiaonuoz.github.io/p/","title":""},{"content":"title: golang闭包 date: \u0026lsquo;2020-10-20 23:34:26\u0026rsquo; updated: \u0026lsquo;2020-10-23 23:01:10\u0026rsquo; tags: [golang学习] permalink: /articles/2020/10/20/1603208066614.html 函数类型是可以作为参数和返回值使用的\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 func main() { ret := f2(f1, 10, 20) f3(ret) //或者f3(f2(f1, 10, 20)) } func f1(x, y int) int { fmt.Println(\u0026#34;this is f2\u0026#34;) return x + y } func f2(x func(int, int) int, m, n int) func() { tmp := func() { a1 := x(m, n) fmt.Println(a1) } return tmp } func f3(f func()) { fmt.Println(\u0026#34;this is f3\u0026#34;) f() } 将f2作为两个函数的中转站，f3只能接收无参无返回值，但是我们只有一个f1，是有参的，所以定义一个f2让它返回一个无参函数类型的返回值，将f1和f1的参数传进去，这样通过调用f2就可以同时调用f3，并且在f2中使用匿名函数调用f1，这样就可以通过f3(f2(f1,10,20))来实现f3调用f1\n闭包的概念就是一个函数除了调用本身内部的变量还可以调用函数外部作用域的变量（其他函数中的局部变量）\n1 2 3 4 5 6 7 8 9 10 11 12 func adder(x int) func (int) int{ return func(y int) int{ x +=y return x } } func main(){ a1:=adder(100) y:=a1(100) fmt.Println(y) } 平时的函数，你调用它就只需要看它内部有哪些变量，但是闭包通过匿名函数可以实现我在函数中使用x并不需要定义，它直接在匿名函数上一级函数进行定义了，匿名变量作为返回值就可以对上一级的函数变量进行引用\n这样示例一就实现了函数一的参数是一个无参无返回值的函数类型，但是只有一个有参有返回值的函数二，通过定义一个函数三，将有参有返回值的函数二和它需要的变量作为参数传进去，然后直接返回一个无参无返回值的匿名函数，在匿名函数中调用有参函数二，这样在需要的地方只需要调用中转函数三并将有参函数二传进去，就可以获得一个无参无返回值但是调用了有参函数二的函数类型，可以作为函数一的参数使用了\n闭包=函数 + 函数上一级作用域的变量的引用\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 func calc(base int) (func(int)int,func(int)int){ add:=func(i int)int{ base+=i return base } sub:=func (i int)int{ base-=i return base } return add,sub } func main() { f1,f2:=calc(10) fmt.Println(f1(1),f2(2)) //11 9 fmt.Println(f1(3),f2(4)) //12 8 } add和sub函数调用了外部的base变量，calc函数只调用了一次，即base只初始化了一次（10），第一次先调用add就是寻找外部的变量，增加后返回，但是此时base值已经改变（变为11），然后进行sub函数,重新寻找base,此时为11（11-2），无论进行多少次都是在上次的基础上进行计算，不会重新初始化为10了\n","date":"0001-01-01T00:00:00Z","permalink":"https://xiaonuoz.github.io/p/","title":""},{"content":"title: Socket网络编程 date: \u0026lsquo;2020-10-23 22:54:24\u0026rsquo; updated: \u0026lsquo;2021-11-03 18:27:35\u0026rsquo; tags: [golang学习] permalink: /articles/2020/10/23/1603464864790.html Socket是BSD UNIX的进程通信机制，通常也称作”套接字”，用于描述IP地址和端口，是一个通信链的句柄。Socket可以理解为TCP/IP网络的API，它定义了许多函数或例程，程序员可以用它们来开发TCP/IP网络上的应用程序。电脑上运行的应用程序通常通过”套接字”向网络发出请求或者应答网络请求。\n五层协议只是OSI七层和TCP/IP四层的综合，实际应用还是TCP/IP的四层结构。应用层、传输层、网络层、链路层。\nSocket是应用层与TCP/IP协议族通信的中间软件抽象层。在设计模式中，Socket其实就是一个门面模式，它把复杂的TCP/IP协议族隐藏在 Socket后面，对用户来说只需要调用Socket规定的相关函数，让 Socket去组织符合指定的协议数据然后进行通信。\nc/s架构 服务器部分： 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 //设置监听，此处及下面都会返回err，为了缩短代码量丢弃了err，工作中不要丢弃 listener, _ := net.Listen(\u0026#34;tcp\u0026#34;, \u0026#34;127.0.0.1:8888\u0026#34;) //阻塞等待用户数据 conn, _ := listener.Accept() //接收用户请求 buf := make([]byte, 1024) //用户数据最后返回到了buf切片中，n表示从用户数据那读取的字节数，最大值为切片的长度1024 n, _ := conn.Read(buf) fmt.Println(string(buf[:n])) //最后处理完数据记得关闭连接 defer func() { listener.Close() conn.Close() }() 服务器端先定义一个监听，表示将这个服务器以什么协议放置于什么位置，然后listener.Accept()让服务器阻塞等待用户向服务器端发送数据，用户发送数据后会存入conn中，通过conn.Read()来获取用户输入的数据并放到buf切片中，通过string(buf[:n])强转用户的字节数据为字符串，n表示数据量大于切片则返回切片最大值数据量，小于切片则返回全部数据，n返回的是Read所读取的总字节量，其值不会超过buf定义的1024字节\n客户端部分： 1 2 3 4 5 //主动连接服务器 conn, _ := net.Dial(\u0026#34;tcp\u0026#34;, \u0026#34;127.0.0.1:8888\u0026#34;) //发送数据 conn.Write([]byte(\u0026#34;are you ok?\u0026#34;)) defer conn.Close() 客户端部分只需要连接服务器并且发送数据，连接服务器需要指定服务器的ip端口和协议，发送的数据是字节切片类型\n如何多个客户端同时连接同一个服务器（重要） 服务器端：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 //conn的类型为net包里的Conn接口 func HandleConn(conn net.Conn) { //每个用户使用完毕后关闭协程 defer conn.Close() //获取客户端的网络信息,并以ip 端口的形式输出 addr := conn.RemoteAddr().String() fmt.Println(addr, \u0026#34;---连接成功\u0026#34;) buf := make([]byte, 2048) //用for循环套住Read()，用户发送一次数据，接收一次并赋值给buf， //运行下面的打印和回传，再次循环并阻塞在Read()处等待用户再次发送请求 //但是这样会让子进程一直存在，除非设置了err不为空时退出实现强制退出 //因此加一个用户输入exit退出的逻辑 for{ n, _ := conn.Read(buf) //打印用户发送过来的内容 fmt.Printf(\u0026#34;%s输入了: %s\\n\u0026#34;, addr, string(buf[:n])) //把用户信息转为大写发回给用户(先将小写的字节切片转为string，然后变成大写再强转为字节切片) //n-是因为在windows中输入的语句有一个\\r\\n换行符，需要-2去除它 //各个平台都不一样，因此可以在前面通过len(string(buf[:n]))来判断到底多了几个字符 if string(buf[:n-2]) == \u0026#34;exit\u0026#34; { fmt.Println(addr, \u0026#34; exit\u0026#34;) return } conn.Write([]byte(strings.ToUpper(string(buf[:n])))) } } func main() { //设置监听，此处及下面都会返回err，为了缩短代码量丢弃了err，工作中不要丢弃 listener, _ := net.Listen(\u0026#34;tcp\u0026#34;, \u0026#34;127.0.0.1:8888\u0026#34;) //利用for循环实现多个客户端连接同一个服务器 for { //循环阻塞等待用户请求，一个用户请求然后往下走，然后循环继续等下一个用户 conn, _ := listener.Accept() //开子协程处理多个用户请求，如果没有用户进入就会阻塞到第一步直到第一个用户请求， //然后往下开一个新协程给此用户，继续for循环等待下一个用户请求 go HandleConn(conn) } defer listener.Close() } 客户端：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 func main() { //主动连接服务端 conn, _ := net.Dial(\u0026#34;tcp\u0026#34;, \u0026#34;127.0.0.1:8888\u0026#34;) defer conn.Close() //从键盘获取输入并发往服务器端 go func() { str := make([]byte, 2048) //用for循环可以实现当os.Stdin.Read()中没有数据时（即没有进行输入）， //阻塞在这一步，直到用户输入内容才继续向下进行 for { //os.Stdin.Read可以提示键盘输入并且将输入的内容转换为字节切片，并赋值到str中，返回切片的长度 n, _ := os.Stdin.Read(str) //发送给服务器端 conn.Write(str[:n]) } }() //从服务器端获取数据 buf := make([]byte, 2048) for { //for循环实现当服务器未往客户端发送数据时，conn.Read(buf)为空，阻塞在这一步， //有数据循环一遍，然后等待下次服务器的数据 //当服务器端输入exit后，服务器端所对应的子协程结束，conn.Read()返回err， //通过return结束主协程，子协程同时结束，退出程序 n, err := conn.Read(buf) if err != nil { fmt.Println(err) return } fmt.Println(string(buf[:n])) } } 远程发送文件： 服务器端：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 func RecvFile(path string, conn net.Conn) { //创建文件 f, _ := os.Create(path) //循环接收文件的内容 buf := make([]byte, 1024*4) for { n, err := conn.Read(buf) if err != nil { if err == io.EOF { fmt.Println(\u0026#34;文件接收完毕\u0026#34;) } else { fmt.Println(err) } return } //往文件写入内容 f.Write(buf[:n]) } } func main() { //建立监听 listener, _ := net.Listen(\u0026#34;tcp\u0026#34;, \u0026#34;127.0.0.1:8888\u0026#34;) //阻塞等待用户请求 conn, _ := listener.Accept() //接收用户文件名 buf := make([]byte, 1024) n, _ := conn.Read(buf) path := string(buf[:n]) //返回消息 conn.Write([]byte(\u0026#34;开始发送\u0026#34;)) //接收文件内容 RecvFile(path, conn) defer listener.Close() defer conn.Close() } 客户端：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 func SendFile(path string, conn net.Conn) { //打开文件，读取文件 f, _ := os.Open(path) buf := make([]byte, 1024*4) for { n, err := f.Read(buf) if err != nil { if err == io.EOF { fmt.Println(\u0026#34;文件传输完成\u0026#34;) } else { fmt.Println(err) } return } //发送到服务器 conn.Write(buf[:n]) } defer f.Close() defer conn.Close() } func main() { fmt.Println(\u0026#34;请输入文件名：\u0026#34;) var path string fmt.Scan(\u0026amp;path) //os.Stat()返回FileInfo类型变量，可以获取文件信息,info.Name()获取文件名,没有此文件则会报错 info, err := os.Stat(path) if err != nil { fmt.Println(\u0026#34;没有这个文件\u0026#34;, err) return } //连接服务器,工作中err别丢空 conn, _ := net.Dial(\u0026#34;tcp\u0026#34;, \u0026#34;127.0.0.1:8888\u0026#34;) //给服务器先发送文件名,err和n都可以丢空 conn.Write([]byte(info.Name())) //服务器接收到文件名，向客户端发送消息,客户端进行判断开始进行发送 buf := make([]byte, 1024) n, _ := conn.Read(buf) if string(buf[:n]) == \u0026#34;开始发送\u0026#34; { SendFile(path, conn) } } 并发聊天服务器 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 type Clinet struct { C chan string //管道string类型，暂存用户发送的数据 Name string //用户名 Addr string //网络地址 } var onlineMap = make(map[string]Clinet) var message = make(chan string) func WriteMsgToClient(cli Clinet, conn net.Conn) { //这个是为了实现cli.C中有数据时向各自客户端发送数据，没有数据时阻塞在这一步 //且任意用户都会在登录时都会通过Manager()方法向每个用户的cli.C发送登录信息， //只要cli.C一有信息，这个子协程就会检测到cli.C不再阻塞，就能向客户端写入新的他人登录信息 //只要发送处的管道没有关闭，cli.Close()，这个for就不会检测到false，会一直堵塞在这里 for msg := range cli.C { conn.Write([]byte(msg + \u0026#34;\\n\u0026#34;)) } } //将用户存进在线用户变量onlineMap中 func HandleConn(conn net.Conn) { defer conn.Close() //获取网络地址 cliAddr := conn.RemoteAddr().String() //创建一个结构体,添加到map中 cli := Clinet{make(chan string), cliAddr, cliAddr} onlineMap[cliAddr] = cli //新开一个协程，专门给当前用户发送消息 go WriteMsgToClient(cli, conn) //广播某个人在线 message \u0026lt;- \u0026#34;[\u0026#34; + cli.Name + \u0026#34;]---login\u0026#34; //退出进行广播并且关闭子协程 isQuit := make(chan bool) hasData := make(chan bool) //新开一个协程，接收用户发送过来的请求 go func() { buf := make([]byte, 2048) //for循环可以避免输入一次就不再进行接收信息的问题 for { n, _ := conn.Read(buf) if n == 0 { //对方断开或者出问题 isQuit \u0026lt;- true return } msg := string(buf[:n-2]) //过滤window末尾的/r/n符号 //查询所有用户 if len(msg) == 3 \u0026amp;\u0026amp; msg == \u0026#34;who\u0026#34; { //避免whoami和who匹配 //遍历map，给当前用户发送所有成员 conn.Write([]byte(\u0026#34;user list:\\n\u0026#34;)) for _, tmp := range onlineMap { msg = tmp.Name + \u0026#34;-----is online\\n\u0026#34; conn.Write([]byte(msg)) } //给用户重命名，输入rename|mike } else if len(msg) \u0026gt;= 8 \u0026amp;\u0026amp; msg[:6] == \u0026#34;rename\u0026#34; { name := strings.Split(msg, \u0026#34;|\u0026#34;)[1] //将msg以|分割 cli.Name = name conn.Write([]byte(\u0026#34;u name is rename\u0026#34;)) } else { //message复用来给所有用户广播它发送的消息，包括自己也看见 message \u0026lt;- cli.Name + \u0026#34;:\u0026#34; + msg } hasData \u0026lt;- true } }() //用for循环让此子协程不会结束，避免发送消息后子协程结束，这个用户就通信结束了 //目的是让用户可以接收到后面登录和发送的信息，所以这个子协程就必须一直存在，除非用户退出 for { //通过select检测管道isQuit的流动 select { case \u0026lt;-isQuit: //删除用户并且广播谁下线了 delete(onlineMap, cliAddr) message \u0026lt;- cli.Name + \u0026#34;--is login out\u0026#34; return case \u0026lt;-hasData: //有数据不作处理 case \u0026lt;-time.After(60 * time.Second): //60s后超时执行此case,超时强制退出 delete(onlineMap, cliAddr) message \u0026lt;- cli.Name + \u0026#34;--is time out leave out\u0026#34; return } } } //新开一个协程，转发消息，只要消息来了就遍历map，给map每个成员都发送此消息 func Manager() { for { //mes为string类型的变量，自动推导类型 msg := \u0026lt;-message //遍历map，给map每个成员都发送此消息 for _, cli := range onlineMap { cli.C \u0026lt;- msg } } } func main() { //监听 listener, _ := net.Listen(\u0026#34;tcp\u0026#34;, \u0026#34;127.0.0.1:8888\u0026#34;) defer listener.Close() go Manager() //循环 for { //循环阻塞，形成多个客户端共用一个服务器 conn, _ := listener.Accept() //处理用户连接 go HandleConn(conn) } } 先是主函数启动子协程HandleConn(conn)，它作用于往map中写入在线成员，并将消息发给管道message,再通过Manager()将message管道发给msg字符串，遍历map，往每个map中的管道写入信息,紧接着通过WriteMsgToClient()中的range向客户端写入消息，且for遍历管道时，没有cli.Close()的存在，它会一直堵塞在此处等待新的信息写进cli.C\nTCP黏包 1 2 3 4 5 6 7 8 9 10 11 12 func main() { conn, err := net.Dial(\u0026#34;tcp\u0026#34;, \u0026#34;127.0.0.1:30000\u0026#34;) if err != nil { fmt.Println(\u0026#34;dial failed, err\u0026#34;, err) return } defer conn.Close() for i := 0; i \u0026lt; 20; i++ { msg := `Hello, Hello. How are you?` conn.Write([]byte(msg)) } } 将msg输出20次到服务端，可以看到服务端输出结果如下：\n1 2 3 4 5 收到client发来的数据： Hello, Hello. How are you?Hello, Hello. How are you?Hello, Hello. How are you?Hello, Hello. How are you?Hello, Hello. How are you? 收到client发来的数据： Hello, Hello. How are you?Hello, Hello. How are you?Hello, Hello. How are you?Hello, Hello. How are you?Hello, Hello. How are you?Hello, Hello. How are you?Hello, Hello. How are you?Hello, Hello. How are you? 收到client发来的数据： Hello, Hello. How are you?Hello, Hello. How are you? 收到client发来的数据： Hello, Hello. How are you?Hello, Hello. How are you?Hello, Hello. How are you? 收到client发来的数据： Hello, Hello. How are you?Hello, Hello. How are you? 客户端分20次发送的数据，在服务端并没有成功的输出20次，而是多条数据“粘”到了一起。\n为什么会出现粘包 主要原因就是tcp数据传递模式是流模式，在保持长连接的时候可以进行多次的收和发。\n“粘包”可发生在发送端也可发生在接收端：\n**由Nagle算法造成的发送端的粘包：**Nagle算法是一种改善网络传输效率的算法。简单来说就是当我们提交一段数据给TCP发送时，TCP并不立刻发送此段数据，而是等待一小段时间看看在等待期间是否还有要发送的数据，若有则会一次把这两段数据发送出去。 **接收端接收不及时造成的接收端粘包：**TCP会把接收到的数据存在自己的缓冲区中，然后通知应用层取数据。当应用层由于某些原因不能及时的把TCP的数据取出来，就会造成TCP缓冲区中存放了几段数据。 解决办法 出现”粘包”的关键在于接收方不确定将要传输的数据包的大小，因此我们可以对数据包进行封包和拆包的操作。\n封包：封包就是给一段数据加上包头，这样一来数据包就分为包头和包体两部分内容了(过滤非法包时封包会加入”包尾”内容)。包头部分的长度是固定的，并且它存储了包体的长度，根据包头长度固定以及包头中含有包体长度的变量就能正确的拆分出一个完整的数据包。\n我们可以自己定义一个协议，比如数据包的前4个字节为包头，里面存储的是发送的数据的长度。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 package proto import ( \u0026#34;bufio\u0026#34; \u0026#34;bytes\u0026#34; \u0026#34;encoding/binary\u0026#34; ) // Encode 将消息编码 func Encode(message string) ([]byte, error) { // 读取消息的长度，转换成int32类型（占4个字节） var length = int32(len(message)) var pkg = new(bytes.Buffer) // 写入消息头 //LittleEndian：小端，可以百度搜大端小端进行了解，它只是写入内存的顺序不一样 //只要编码和解码都用小端或大端就没问题 //这段代码的意思就是往pkg字节缓存中写入一个数据，是int32的message长度，int32是32位，8位为一个字节，所以这里就占了4个字节 err := binary.Write(pkg, binary.LittleEndian, length) if err != nil { return nil, err } // 写入消息实体 err = binary.Write(pkg, binary.LittleEndian, []byte(message)) if err != nil { return nil, err } return pkg.Bytes(), nil } // Decode 解码消息 func Decode(reader *bufio.Reader) (string, error) { // 读取消息的长度，前4个字节就是一条消息的长度 lengthByte, _ := reader.Peek(4) // 读取前4个字节的数据 lengthBuff := bytes.NewBuffer(lengthByte) var length int32 //将前4个字节放到length中 err := binary.Read(lengthBuff, binary.LittleEndian, \u0026amp;length) if err != nil { return \u0026#34;\u0026#34;, err } // Buffered返回缓冲中现有的可读取的字节数。现在发送过来的数据长度是消息的长度信息length加上存放长度信息的包头4个字节 if int32(reader.Buffered()) \u0026lt; length+4 { return \u0026#34;\u0026#34;, err } // 读取真正的消息数据 pack := make([]byte, int(4+length)) //这里是测试是否能从pack中读出数据，并将读的数据放入pack，读的出就从第5个字节读到尾（下标是从0开始的，因此下标4代表第五个字节） _, err = reader.Read(pack) if err != nil { return \u0026#34;\u0026#34;, err } return string(pack[4:]), nil } 接下来在服务端和客户端分别使用上面定义的 proto包的 Decode和 Encode函数处理数据。\n服务端代码如下：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 // socket_stick/server2/main.go func process(conn net.Conn) { defer conn.Close() reader := bufio.NewReader(conn) for { msg, err := proto.Decode(reader) if err == io.EOF { return } if err != nil { fmt.Println(\u0026#34;decode msg failed, err:\u0026#34;, err) return } fmt.Println(\u0026#34;收到client发来的数据：\u0026#34;, msg) } } func main() { listen, err := net.Listen(\u0026#34;tcp\u0026#34;, \u0026#34;127.0.0.1:30000\u0026#34;) if err != nil { fmt.Println(\u0026#34;listen failed, err:\u0026#34;, err) return } defer listen.Close() for { conn, err := listen.Accept() if err != nil { fmt.Println(\u0026#34;accept failed, err:\u0026#34;, err) continue } go process(conn) } } 客户端代码如下：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 // socket_stick/client2/main.go func main() { conn, err := net.Dial(\u0026#34;tcp\u0026#34;, \u0026#34;127.0.0.1:30000\u0026#34;) if err != nil { fmt.Println(\u0026#34;dial failed, err\u0026#34;, err) return } defer conn.Close() for i := 0; i \u0026lt; 20; i++ { msg := `Hello, Hello. How are you?` data, err := proto.Encode(msg) if err != nil { fmt.Println(\u0026#34;encode msg failed, err:\u0026#34;, err) return } conn.Write(data) } } b/s架构： 但是如果工作中每次都需要向服务器发送一长串的请求包过于繁琐，所以可以使用net/http包来简化\nhttp服务器： 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 //w为给客户端回复的数据 //req，读取客户端的数据 func HandConn(w http.ResponseWriter, req *http.Request) { //给客户端浏览器发送数据 w.Write([]byte(\u0026#34;hello go\u0026#34;)) //获取客户端的请求头部参数等 //在https://studygolang.com/pkgdoc中的net/http中搜type Request可以获取req的所有参数 fmt.Println(req.URL.Path) } func main() { //注册处理函数，用户连接进来自动调用指定的处理函数(即如果域名后面接了/hello则调用后面那个函数) //源代码中第二个参数为handler func(ResponseWriter, *Request) //即在定义函数时已经定义了这是一个func，且默认已经传了两个参数进去，所以不需要加()来调用， //自己写HandConn函数时也不再需要想办法获取ResponseWriter和*http.Request的值了 http.HandleFunc(\u0026#34;/hello\u0026#34;, HandConn) //该方法用于在指定的网络地址进行监听，然后调用服务端处理程序来处理传入的连接请求 //该方法有两个参数：第一个为监听地址；第二个参数表示服务器端处理程序，通常为空 //第二个参数为空意味着服务端调用http.DefaultServerMux进行处理 http.ListenAndServe(\u0026#34;127.0.0.1:8000\u0026#34;, nil) } http客户端： 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 //获取从百度回传回来的请求包，http是必须要加的 resp, _ := http.Get(\u0026#34;http://www.baidu.com\u0026#34;) //body是从服务器端读取资源(类似于conn.Read())，最后是需要进行关闭的 defer resp.Body.Close() fmt.Println(\u0026#34;Status =\u0026#34;, resp.Status) fmt.Println(\u0026#34;StatusCode =\u0026#34;, resp.StatusCode) fmt.Println(\u0026#34;Header =\u0026#34;, resp.Header) //获取baidu.com中的数据Read()，然后赋值给buf，最后追加到tmp中 buf := make([]byte, 1024*4) var tmp string for { n, err := resp.Body.Read(buf) if n == 0 { fmt.Println(\u0026#34;read err =\u0026#34;, err) break } tmp += string(buf[:n]) } fmt.Println(tmp) 参考文档 https://www.liwenzhou.com/posts/Go/go_http/\n用go写爬虫爬百度贴吧： 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 func SpiderPage(i int, page chan int) { //寻找网址规律，每页pn加50,用for循环获取每个网址 url := \u0026#34;http://tieba.baidu.com/f?kw=%E6%8A%97%E5%8E%8B%E8%83%8C%E9%94%85\u0026amp;ie=utf-8\u0026amp;pn=\u0026#34; + strconv.Itoa((i-1)*50) fmt.Printf(\u0026#34;正在爬取第%d页网页%s\\n\u0026#34;, i, url) result, _ := HttpGet(url) //将内容写到文件中 f, _ := os.Create(strconv.Itoa(i) + \u0026#34;.html\u0026#34;) f.Write([]byte(result)) f.Close() page \u0026lt;- i } func HttpGet(url string) (result string, err error) { rep, _ := http.Get(url) defer rep.Body.Close() //爬取 buf := make([]byte, 1024*4) for { n, err := rep.Body.Read(buf) if n == 0 { fmt.Println(err) break } result += string(buf[:n]) } return } func DoWork(start, end int) { fmt.Printf(\u0026#34;正在爬取 %d到%d的页面。。。\u0026#34;, start, end) //建立一个管道，避免主进程结束导致子进程结束 page := make(chan int) //获取地址 for i := start; i \u0026lt;= end; i++ { //建立子协程，让多个爬虫同时进行 go SpiderPage(i, page) } for i := start; i \u0026lt;= end; i++ { //避免协程结束影响子协程 fmt.Printf(\u0026#34;第%d页已经读取完毕\u0026#34;, \u0026lt;-page) } return } func main() { var start, end int fmt.Println(\u0026#34;请输入起始页\u0026#34;) fmt.Scan(\u0026amp;start) fmt.Println(\u0026#34;请输入结束页\u0026#34;) fmt.Scan(\u0026amp;end) DoWork(start, end) } 此方法可以爬取每页内容（包括html内容）存到新建的.html中，如果要爬取需要的内容，可以查看源代码然后通过正则表达式爬出来再存入文件中\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 如爬取每个帖子的某段内容，先在每个主页查看源代码爬取出每个帖子的url， \u0026lt;a rel=\u0026#34;noreferrer\u0026#34; href=\u0026#34;/p/6978750013\u0026#34; title=\u0026#34;老马是真的叼，剪辑的更吊！！！\u0026#34; target=\u0026#34;_blank\u0026#34; class=\u0026#34;j_th_tit \u0026#34; 用正则表达式 (`\u0026lt;a rel=\u0026#34;noreferrer\u0026#34; href=\u0026#34;(?s:(.*?))\u0026#34; title=`) 来爬取出网页链接， regexp的FindAllStringSubmatch会返回一个二维切片，切片中的里切片第一个值是通过表达式过滤出的内容， 第二个值是正则表达式代表的内容，即/p/6978750013，给它拼接上贴吧网址即可访问 通过range迭代外切片然后在里面调用里切片[1]即可 然后在range中用http.Get爬取内容，依然是查看源代码找到对应的内容进行过滤 过来出来的内容可能会有些\\t \u0026lt;br /\u0026gt;之类的，可以用strings.Replace(text,\u0026#34;\\t\u0026#34;,\u0026#34;\u0026#34;,-1)去掉 最后写入文件，如果多标题多内容，可以分开存入到两个切片中，然后后面一口气写进文件中 如果不用子协程来爬取，它就是单协程的程序，它会爬完一个再爬下一个，开了子协程后它可以同时爬取多个，节省了大量时间，但是要注意子协程开启后主协程不能关闭，这样会导致子协程也同时消失，可以使用切片来阻塞主协程，直到爬取完毕\nGo语言实现UDP通信 UDP协议 UDP协议（User Datagram Protocol）中文名称是用户数据报协议，是OSI（Open System Interconnection，开放式系统互联）参考模型中一种无连接的传输层协议，不需要建立连接就能直接进行数据发送和接收，属于不可靠的、没有时序的通信，但是UDP协议的实时性比较好，通常用于视频直播相关领域。\nUDP服务端 使用Go语言的 net包实现的UDP服务端代码如下：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 // UDP/server/main.go // UDP server端 func main() { listen, err := net.ListenUDP(\u0026#34;udp\u0026#34;, \u0026amp;net.UDPAddr{ IP: net.IPv4(0, 0, 0, 0), Port: 30000, }) if err != nil { fmt.Println(\u0026#34;listen failed, err:\u0026#34;, err) return } defer listen.Close() for { var data [1024]byte //addr就是发送端的地址类型 n, addr, err := listen.ReadFromUDP(data[:]) // 接收数据 if err != nil { fmt.Println(\u0026#34;read udp failed, err:\u0026#34;, err) continue } fmt.Printf(\u0026#34;data:%v addr:%v count:%v\\n\u0026#34;, string(data[:n]), addr, n) _, err = listen.WriteToUDP(data[:n], addr) // 发送数据 if err != nil { fmt.Println(\u0026#34;write to udp failed, err:\u0026#34;, err) continue } } } UDP客户端 使用Go语言的 net包实现的UDP客户端代码如下：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 // UDP 客户端 func main() { socket, err := net.DialUDP(\u0026#34;udp\u0026#34;, nil, \u0026amp;net.UDPAddr{ IP: net.IPv4(0, 0, 0, 0), Port: 30000, }) if err != nil { fmt.Println(\u0026#34;连接服务端失败，err:\u0026#34;, err) return } //close要写在err判断后面，避免真的出错直接结束，导致直接执行defer造成问题 defer socket.Close() sendData := []byte(\u0026#34;Hello server\u0026#34;) _, err = socket.Write(sendData) // 发送数据 if err != nil { fmt.Println(\u0026#34;发送数据失败，err:\u0026#34;, err) return } data := make([]byte, 4096) n, remoteAddr, err := socket.ReadFromUDP(data) // 接收数据 if err != nil { fmt.Println(\u0026#34;接收数据失败，err:\u0026#34;, err) return } fmt.Printf(\u0026#34;recv:%v addr:%v count:%v\\n\u0026#34;, string(data[:n]), remoteAddr, n) } ","date":"0001-01-01T00:00:00Z","permalink":"https://xiaonuoz.github.io/p/","title":""},{"content":"title: 用golang进行文件操作 date: \u0026lsquo;2020-10-23 22:58:25\u0026rsquo; updated: \u0026lsquo;2020-10-28 17:13:38\u0026rsquo; tags: [golang学习] permalink: /articles/2020/10/23/1603465105244.html 设备文件有屏幕键盘等，标准输出就是屏幕，可以通过os.Stdout.Close()来阻止后面的程序输出内容，可以通过os.Stdint.Close()来阻止后面的程序通过键盘获取输入内容\n文件的创建和写入 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 path := \u0026#34;./test.txt\u0026#34; //创建文件，如果文件存在则打开文件且清空文件内容,它返回一个file的指针和一个error f, err := os.Create(path) if err != nil { //如果有错误就输出错误信息并且中止函数 fmt.Println(err) return } //使用完毕记得要关闭文件，使用defer就可以在函数结束的前一刹那进行关闭 defer f.Close() //Sprintln()可以将一行信息赋值给一个变量 buf := fmt.Sprintln(\u0026#34;我往文件内写入东西\u0026#34;) //往文件内写入字符串，f代表文件的指针，WriteString就可以将内容追加到文件，注意是追加 //它返回两个值，一个是写入的字节数，另一个是error n, err := f.WriteString(buf) if err != nil { fmt.Println(err) return } 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 fileObj,err:= os.OpenFile(\u0026#34;./xxx.txt\u0026#34;,os.O_CREATE|os.O_APPEND,0644) if err!=nil{ fmt.Println(err) return } fileObj.Write([]byte(\u0026#34;强转string为字节切片\u0026#34;)) //也可以用bufio进行写操作 wr := bufio.NewWriter(fileObj) //写到缓存中 wr.WriteString(\u0026#34;hello\\n\u0026#34;) //这一步是将缓存中的内容写入文件，如果没有这一步，内容是在缓存中的，等程序执行完毕就会消失 writer.Flush() //也可以使用ioutil.WriteFile将内容写入文件 ioutil.WriteFile(\u0026#34;./xx.txt\u0026#34;,[]byte(\u0026#34;写入的内容\u0026#34;),0666) 注意：在windows中，第三个参数文件权限可以随便写，因为这只针对于linux用户，os.O_CREATE|os.O_APPEND表示没有文件就创建，有文件就打开，内容是追加写入(它的实现方式是这两个参数分别对应一个十六进制的数，转成2进制后根据数的值进行操作)，如CREATE是0x00040，二进制是0100 0000，APPEND是0x00400，二进制是0100 0000 0000，使用| 位运算符表示两位有一个1就为1，即最后的值是0100 0100 0000，这样就实现了传一个int参数有多个功能，可以进行多个位运算符。\n像只读和只写就是在同一位上一个为0一个为1，这样最后这一位就为1，只执行值为1的那个操作，就像linux的权限一样，每个位置的1代表不同的意义\nos.O_CREATE|os.O_APPEND 和 os.O_CREATE|os.O_TRUNC APPEND表示追加写入，TRUNC表示清空后写入\n文件的读取 下面的代码可以实现指定读取多少内容，如果想直接读完整个文件，只需要在读取那里加一个for循环，它就会一直往下读取直到结尾出现error抛出EOF错误（EOF表示结尾），注意：抛出EOF的if语句要写到err !=nil中，因为EOF错误是它的子集，在err不为空中加return，而EOF中只需要加break，因为break触发后直接跳出循环了，就不会触发return了\n尽量将关闭文件的defer写到err判定后面，因为如果先写defer，如果出现了err错误程序返回的*File是对应的零值nil，当程序结束时，defer中对于nil进行Close()函数就会造成panic错误（使用文件操作这里不会报错，因为close会返回一个error，但是如果调用的是第三方函数库，可能就会因此产生panic），而在err中写入return语句后，如果出现了err错误的话，直接返回，并不会执行到下面defer中的Close()函数\n1 2 3 4 5 6 7 if err1 != nil { if err1 == io.EOF{ break } fmt.Println(err1) return } 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 path := \u0026#34;./test.txt\u0026#34; //打开文件,返回一个文件指针和一个error f, err := os.Open(path) if err != nil { fmt.Println(err) } //函数运行结束时关闭文件 defer f.Close() //创建一个2k长度的字节切片，表示读取的总量 buf := make([]byte, 1024*10) //Read返回两个值，一个是字节数，一个是error //n是读取了多少文件字节数，如果buf大于文件总字节数，n返回总字节数。 //如果总字节数大于buf，则n等于buf，即最多只能读取buf字节的内容，如果想多读取点就只能增大buf的长度值 //Read()方法会将读取的内容放入buf中，后面查看buf内容即是查看文件内容 n, err1 := f.Read(buf) if err1 != nil \u0026amp;\u0026amp; err1 != io.EOF {\t//文件出错并且没有读到结尾 fmt.Println(err1) return } //可以用m:n来读取buf中间内容，n不能大于buf前面设定的值（即不能大于总长度），否则会报错 //n可以设置常量，即表示查看buf容量中从m到n的内容 //设置n则可以实现当文件总字节数小于buf量全部读取，大于则读取设置的最大值 fmt.Print(\u0026#34;buf:\u0026#34;, string(buf[:n])) //buf中的值都是字节型的，可以通过强转变成string //不用println是原因是ln会进行换行，如果第一次读取并没有读取到行末尾， //ln还是会让它换行，这会导致读取内容有问题 如何解决fmt.Scanln()无法读取输入空格后的内容 Scanln()是以空白符分隔的，空白符就包括空格 回车等，如果输入的内容中含有空格，就只能读取到空格以前的内容，因此可以使用bufio来获取标准输入\n1 2 3 4 5 fmt.Println(\u0026#34;请输入内容：\u0026#34;) reader := bufio.NewReader(os.Stdin) //一直读，读到\\n结束,返回读取到的内容 str, _ := reader.ReadString(\u0026#39;\\n\u0026#39;) fmt.Println(\u0026#34;你输入的内容是：\u0026#34;, str) 如何一行一行的进行读取且务必读完文件的全部内容（不论大小） bufio包有一个NewReader函数可以为文件的读取创建一个缓冲区并返回一个缓冲区的指针\nReadBytes是缓冲区 *Reader的方法，读取缓冲区直到第一次遇到delim字节（即指定的关键值\u0026rsquo;\\n\u0026rsquo;等），读取出一次后缓冲区中对应的内容就会消失，因此可以用for死循环来读取多行缓冲区内容\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 path := \u0026#34;./test.txt\u0026#34; //打开文件,返回一个文件指针和一个error f, err := os.Open(path) if err != nil { fmt.Println(err) } //函数运行结束时关闭文件 defer f.Close() //新建一个缓冲区，先把内容放进缓冲区里 r := bufio.NewReader(f) for { //遇到\\n就结束读取,buf为读取到的数据,这种会将\\n也读取进去，所以使用Printf() buf, err1 := r.ReadBytes(\u0026#39;\\n\u0026#39;) //当读到结尾即退出循环 fmt.Printf(\u0026#34;%v\u0026#34;, string(buf)) /*把err判断放到打印后面的原因是如果将它放在前面，它会先判断是否是最后一行，当处于最后 一行时它直接跳出循环，最后一行的输出语句就不会进行，那么就会少输出一行 */ if err1 != nil { if err1 == io.EOF { break } fmt.Println(err1) } } 使用ioutil直接读取整个文件 1 2 3 4 5 6 7 8 9 10 11 12 13 //它的底层用的依然是os.Open()的原理,文件的打开和defer关闭在底层已经设置好了，直接使用就行 func fileByioutil(){ b,err:=ioutil.ReadFile(\u0026#34;C:\\\\Users\\\\admin\\\\Desktop\\\\新建文件夹\\\\gold_control_config.xml\u0026#34;) if err ==io.EOF{ fmt.Println(\u0026#34;读取完了\u0026#34;) return } if err!=nil{ fmt.Println(\u0026#34;file err\u0026#34;,err) return } fmt.Println(string(b)) } 实例：拷贝文件 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 //获取命令行参数，判断是否为3个 list := os.Args if len(list) != 3 { fmt.Println(\u0026#34;拷贝格式为xx.exe src dst\u0026#34;) } //比较目标文件和源文件是否同名 srcName := list[1] dstName := list[2] if srcName == dstName { fmt.Println(\u0026#34;源文件和目标文件不能相等\u0026#34;) } //只读方式打开源文件 sf, err1 := os.Open(srcName) if err1 != nil { fmt.Println(err1) return } //新建目标文件 df, err2 := os.Create(dstName) if err2 != nil { fmt.Println(err2) return } //操作完毕要关闭文件 defer sf.Close() defer df.Close() for { //读源文件 buf := make([]byte, 1024*4) n, err3 := sf.Read(buf) //从源文件读取内容 if err3 != nil { if err3 == io.EOF { //源文件读取完毕 break } fmt.Println(err3) return } //写入目标文件，读多少写多少 _, err4 := df.Write(buf[:n]) if err4 != nil { fmt.Println(err3) return } } 如何在一个文件中间部分插入内容 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 //打开源文件，第一次读取到要插入的点 //读取完后下次读取时光标会在此处 f1,_:=os.Open(\u0026#34;./a.txt\u0026#34;) buf:=make([]byte,1) n,_:=f1.Read(buf) //创建临时文件，并将读取的内容写入进去 f2,_:=os.Create(\u0026#34;./b.txt\u0026#34;) f2.Write(buf[:n]) //写入自己需要插入的内容 f2.Write([]byte(\u0026#34;哈哈哈哈哈\u0026#34;)) //读取源文件后面的部分，如果多就需要使用for循环 buf1:=make([]byte,1024) n1,err:=f1.Read(buf1) //将源文件后半部分写入临时文件 f2.Write(buf1[:n1]) if err!=nil{ return } f2.Close() f1.Close() //现在f2临时文件就有插入想要的内容，通过rename重命名成源文件实现覆盖 os.Rename(\u0026#34;./b.txt\u0026#34;,\u0026#34;./a.txt\u0026#34;) ","date":"0001-01-01T00:00:00Z","permalink":"https://xiaonuoz.github.io/p/","title":""},{"content":"title: 通过golang处理json文件 date: \u0026lsquo;2020-10-23 22:59:38\u0026rsquo; updated: \u0026lsquo;2020-10-23 23:01:47\u0026rsquo; tags: [golang学习] permalink: /articles/2020/10/23/1603465177957.html 通过结构体生成json文件 默认情况下从结构体生成json格式，结构体的成员首字母必须大写，结构体名可以小写，因为在本包使用 Marshal方法是从本包传结构体到json的包让它编码，它肯定能访问到结构体，但是成员如果小写，json的包就无法调用到\n1 2 3 4 5 6 7 8 9 10 11 12 13 type person struct { Name string Age int } func main() { p1 := person{\u0026#34;张三\u0026#34;,19} b, _ := json.Marshal(p1) fmt.Println(string(b)) var p2 person json.Unmarshal(b, \u0026amp;p2)\t//结构体是值传递，如果不使用指针就只会修改副本，不会修改p2原有的内容 fmt.Println(p2) } Marshal()会返回两个值，一个json内容一个错误值，可以用If语句接受错误，然后用return让main函数中断，return在函数中的意义：如果函数返回值有定义，则return表示返回数据，如果没有定义返回值，return就表示退出此函数，在main函数中有return就表示中断程序但是不会报错\nbuf获得的值是一个字节切片类型，可以直接string(buf)强转成string类型\n转换成string后输出的是一个整体值，无法再用切片[0]来调用任意一个成员\n通过map生成json文件 MarshalIndent()的第三个参数为一个TAB键字符串\njson解析到结构体(json解码) json的变量名是小写，而结构体的首字母是大写，所以可以通过对结构体二次编码来关联上，不建议将结构体的首字母变成小写，因为如果变成小写的话，以后又需要生成json就会失败，并且如果程序其他地方有使用到这个结构体，成员名赋值也需要修改\nUnmarshal()有两个参数，一个是byte切片类型（通过强转jsonBuf获得），一个是结构体的指针，放指针是因为给函数传结构体变量属于值传递，并不会修改本身结构体的内容，是拷贝了一份新的结构体给函数，只有通过指针实现引用传递才可以修改本身结构体内容，这个函数的返回值只有error\n如果只需要部分解析，可以重新定义一个只含有部分成员的结构体来接受解析内容\njson解析到map map也需要传递指针过去，这里原理不太清楚，但是测试过发现不加指针\u0026amp;就无法对原值进行修改，尽管map属于引用传递\n如果通过map接受解析的值，它接受到的值类型都属于空接口类型，对其强转string(m[\u0026ldquo;test\u0026rdquo;])是无法成功的，需要使用switch断言来回推类型进行赋值\nswitch可以在赋值的同时进行判断，即 switch a := 3; 判断的是st的值，空接口类型断言隐性的将data的类型放在了判断上面，且将data空接口类型自动转换成适合它的类型\n推荐使用结构体来解析，因为map如果要确定值的类型就需要断言，过于麻烦\n","date":"0001-01-01T00:00:00Z","permalink":"https://xiaonuoz.github.io/p/","title":""}]