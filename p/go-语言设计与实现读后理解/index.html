<!DOCTYPE html>
<html lang="zh-cn" dir="ltr">
    <head><meta charset='utf-8'>
<meta name='viewport' content='width=device-width, initial-scale=1'><meta name='description' content='此文章为学习 《Go 语言设计与实现》的总结性文章 编译原理 词法分析和语法分析 词法分析 源代码在计算机眼中其实是一团乱麻，是一个由字符组成的、无法被'>
<title>《Go 语言设计与实现》读后理解</title>

<link rel='canonical' href='https://xiaonuoz.github.io/p/go-%E8%AF%AD%E8%A8%80%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0%E8%AF%BB%E5%90%8E%E7%90%86%E8%A7%A3/'>

<link rel="stylesheet" href="/scss/style.min.5470349c9ee04f592bc7c1dcd2e028072cd1dec2a37467ccfd4c5ecaf180dcaa.css"><meta property='og:title' content='《Go 语言设计与实现》读后理解'>
<meta property='og:description' content='此文章为学习 《Go 语言设计与实现》的总结性文章 编译原理 词法分析和语法分析 词法分析 源代码在计算机眼中其实是一团乱麻，是一个由字符组成的、无法被'>
<meta property='og:url' content='https://xiaonuoz.github.io/p/go-%E8%AF%AD%E8%A8%80%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0%E8%AF%BB%E5%90%8E%E7%90%86%E8%A7%A3/'>
<meta property='og:site_name' content='笑傩'>
<meta property='og:type' content='article'><meta property='article:section' content='Post' /><meta property='article:published_time' content='2023-06-05T00:00:00&#43;00:00'/><meta property='article:modified_time' content='2023-06-05T00:00:00&#43;00:00'/>
<meta name="twitter:title" content="《Go 语言设计与实现》读后理解">
<meta name="twitter:description" content="此文章为学习 《Go 语言设计与实现》的总结性文章 编译原理 词法分析和语法分析 词法分析 源代码在计算机眼中其实是一团乱麻，是一个由字符组成的、无法被">
    <link rel="shortcut icon" href="/favicon.ico" />

    </head>
    <body class="
    article-page
    ">
    <script>
        (function() {
            const colorSchemeKey = 'StackColorScheme';
            if(!localStorage.getItem(colorSchemeKey)){
                localStorage.setItem(colorSchemeKey, "auto");
            }
        })();
    </script><script>
    (function() {
        const colorSchemeKey = 'StackColorScheme';
        const colorSchemeItem = localStorage.getItem(colorSchemeKey);
        const supportDarkMode = window.matchMedia('(prefers-color-scheme: dark)').matches === true;

        if (colorSchemeItem == 'dark' || colorSchemeItem === 'auto' && supportDarkMode) {
            

            document.documentElement.dataset.scheme = 'dark';
        } else {
            document.documentElement.dataset.scheme = 'light';
        }
    })();
</script>
<div class="container main-container flex on-phone--column extended"><aside class="sidebar left-sidebar sticky ">
    <button class="hamburger hamburger--spin" type="button" id="toggle-menu" aria-label="切换菜单">
        <span class="hamburger-box">
            <span class="hamburger-inner"></span>
        </span>
    </button>

    <header>
        
            
            <figure class="site-avatar">
                <a href="/">
                
                    
                    
                    
                        
                        <img src="/img/avatar_hu89d70501dbd1e038dcbf309839bfe7a9_213951_300x0_resize_box_3.png" width="300"
                            height="300" class="site-logo" loading="lazy" alt="Avatar">
                    
                
                </a>
                
            </figure>
            
        
        
        <div class="site-meta">
            <h1 class="site-name"><a href="/">笑傩</a></h1>
            <h2 class="site-description">永远不要高估自己~</h2>
        </div>
    </header><ol class="social-menu">
            
                <li>
                    <a 
                        href='https://github.com/xiaonuoz'
                        target="_blank"
                        title="GitHub"
                        rel="me"
                    >
                        
                        
                            <svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-brand-github" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round">
  <path stroke="none" d="M0 0h24v24H0z" fill="none"/>
  <path d="M9 19c-4.3 1.4 -4.3 -2.5 -6 -3m12 5v-3.5c0 -1 .1 -1.4 -.5 -2c2.8 -.3 5.5 -1.4 5.5 -6a4.6 4.6 0 0 0 -1.3 -3.2a4.2 4.2 0 0 0 -.1 -3.2s-1.1 -.3 -3.5 1.3a12.3 12.3 0 0 0 -6.2 0c-2.4 -1.6 -3.5 -1.3 -3.5 -1.3a4.2 4.2 0 0 0 -.1 3.2a4.6 4.6 0 0 0 -1.3 3.2c0 4.6 2.7 5.7 5.5 6c-.6 .6 -.6 1.2 -.5 2v3.5" />
</svg>



                        
                    </a>
                </li>
            
        </ol><ol class="menu" id="main-menu">
        
        
        
        <li >
            <a href='/' >
                
                
                
                    <svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-home" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round">
  <path stroke="none" d="M0 0h24v24H0z"/>
  <polyline points="5 12 3 12 12 3 21 12 19 12" />
  <path d="M5 12v7a2 2 0 0 0 2 2h10a2 2 0 0 0 2 -2v-7" />
  <path d="M9 21v-6a2 2 0 0 1 2 -2h2a2 2 0 0 1 2 2v6" />
</svg>



                
                <span>主页</span>
            </a>
        </li>
        
        
        <li >
            <a href='/search/' >
                
                
                
                    <svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-search" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round">
  <path stroke="none" d="M0 0h24v24H0z"/>
  <circle cx="10" cy="10" r="7" />
  <line x1="21" y1="21" x2="15" y2="15" />
</svg>



                
                <span>搜索</span>
            </a>
        </li>
        

        <div class="menu-bottom-section">
            
            
                <li id="dark-mode-toggle">
                    <svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-toggle-left" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round">
  <path stroke="none" d="M0 0h24v24H0z"/>
  <circle cx="8" cy="12" r="2" />
  <rect x="2" y="6" width="20" height="12" rx="6" />
</svg>



                    <svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-toggle-right" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round">
  <path stroke="none" d="M0 0h24v24H0z"/>
  <circle cx="16" cy="12" r="2" />
  <rect x="2" y="6" width="20" height="12" rx="6" />
</svg>



                    <span>暗色模式</span>
                </li>
            
        </div>
    </ol>
</aside>

    <aside class="sidebar right-sidebar sticky">
        
            
                
    <section class="widget archives">
        <div class="widget-icon">
            <svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-hash" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round">
  <path stroke="none" d="M0 0h24v24H0z"/>
  <line x1="5" y1="9" x2="19" y2="9" />
  <line x1="5" y1="15" x2="19" y2="15" />
  <line x1="11" y1="4" x2="7" y2="20" />
  <line x1="17" y1="4" x2="13" y2="20" />
</svg>



        </div>
        <h2 class="widget-title section-title">目录</h2>
        
        <div class="widget--toc">
            <nav id="TableOfContents">
  <ol>
    <li><a href="#编译原理">编译原理</a>
      <ol>
        <li><a href="#词法分析和语法分析">词法分析和语法分析</a>
          <ol>
            <li><a href="#词法分析">词法分析</a></li>
            <li><a href="#语法分析">语法分析</a></li>
          </ol>
        </li>
        <li><a href="#类型检查">类型检查</a>
          <ol>
            <li><a href="#强弱类型">强弱类型</a></li>
            <li><a href="#静态类型和动态类型">静态类型和动态类型</a></li>
          </ol>
        </li>
        <li><a href="#中间代码生成">中间代码生成</a></li>
        <li><a href="#机器码生成">机器码生成</a>
          <ol>
            <li><a href="#指令集架构">指令集架构</a></li>
            <li><a href="#机器码生成-1">机器码生成</a></li>
          </ol>
        </li>
      </ol>
    </li>
    <li><a href="#数据结构">数据结构</a>
      <ol>
        <li><a href="#数组">数组</a>
          <ol>
            <li><a href="#初始化">初始化</a></li>
            <li><a href="#访问和赋值">访问和赋值</a></li>
          </ol>
        </li>
        <li><a href="#切片">切片</a>
          <ol>
            <li><a href="#数据结构-1">数据结构</a></li>
            <li><a href="#初始化-1">初始化</a></li>
            <li><a href="#访问元素">访问元素</a></li>
            <li><a href="#追加和扩容">追加和扩容</a></li>
            <li><a href="#拷贝切片">拷贝切片</a></li>
          </ol>
        </li>
        <li><a href="#哈希表">哈希表</a>
          <ol>
            <li><a href="#设计原理">设计原理</a></li>
            <li><a href="#数据结构-2">数据结构</a></li>
            <li><a href="#初始化-2">初始化</a></li>
          </ol>
        </li>
      </ol>
    </li>
  </ol>
</nav>
        </div>
    </section>

            
        
    </aside>


            <main class="main full-width">
    <article class="main-article">
    <header class="article-header">

    <div class="article-details">
    
    <header class="article-category">
        
            <a href="/categories/golang/" >
                golang
            </a>
        
    </header>
    

    <div class="article-title-wrapper">
        <h2 class="article-title">
            <a href="/p/go-%E8%AF%AD%E8%A8%80%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0%E8%AF%BB%E5%90%8E%E7%90%86%E8%A7%A3/">《Go 语言设计与实现》读后理解</a>
        </h2>
    
        
    </div>

    
    
    
    
    <footer class="article-time">
        
            <div>
                <svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-calendar-time" width="56" height="56" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round">
  <path stroke="none" d="M0 0h24v24H0z"/>
  <path d="M11.795 21h-6.795a2 2 0 0 1 -2 -2v-12a2 2 0 0 1 2 -2h12a2 2 0 0 1 2 2v4" />
  <circle cx="18" cy="18" r="4" />
  <path d="M15 3v4" />
  <path d="M7 3v4" />
  <path d="M3 11h16" />
  <path d="M18 16.496v1.504l1 1" />
</svg>
                <time class="article-time--published">Jun 05, 2023</time>
            </div>
        

        
    </footer>
    

    
</div>

</header>

    <section class="article-content">
    
    
    <p><code>此文章为学习 《Go 语言设计与实现》的总结性文章</code></p>
<h2 id="编译原理">编译原理</h2>
<h3 id="词法分析和语法分析">词法分析和语法分析</h3>
<h4 id="词法分析">词法分析</h4>
<p>源代码在计算机眼中其实是一团乱麻，是一个由字符组成的、无法被理解的字符串，为了理解这些字符我们需要做的第一件事情就是 <strong>将字符串分组</strong> ，这能够降低理解字符串的成本，简化源代码的分析过程。</p>
<p>源文件在机器的眼中是很难理解的字符串，词法分析会将这些字符串解析成一个个token序列以便机器理解。使用的就是类似lex之类的词法分析器。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span><span class="lnt">8
</span><span class="lnt">9
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="line"><span class="cl"><span class="nx">PACKAGE</span>  <span class="nx">IDENT</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="nx">IMPORT</span>  <span class="nx">LPAREN</span>
</span></span><span class="line"><span class="cl">	<span class="nx">QUOTE</span> <span class="nx">IDENT</span> <span class="nx">QUOTE</span>
</span></span><span class="line"><span class="cl"><span class="nx">RPAREN</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="nx">IDENT</span>  <span class="nx">IDENT</span> <span class="nx">LPAREN</span> <span class="nx">RPAREN</span>  <span class="nx">LBRACE</span>
</span></span><span class="line"><span class="cl">	<span class="nx">IDENT</span> <span class="nx">DOT</span> <span class="nx">IDENT</span> <span class="nx">LPAREN</span> <span class="nx">QUOTE</span> <span class="nx">IDENT</span> <span class="nx">QUOTE</span> <span class="nx">RPAREN</span>
</span></span><span class="line"><span class="cl"><span class="nx">RBRACE</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>从上面的输出我们能够看到 Go 源代码的影子，lex 生成的词法分析器 lexer 通过正则匹配的方式将机器原本很难理解的字符串进行分解成很多的 Token，有利于后面的处理。</p>
<p>早期Go是使用lex进行词法解析，但是之后还是会用Go自己实现的词法分析器分析解析出的数据。<code>而如今词法解析和词法分析都是用Go自己实现的工具。</code></p>
<h4 id="语法分析">语法分析</h4>
<p>语法分析是根据某种特定的形式文法对 Token 序列构成的输入文本进行分析并确定其语法构成的过程。词法分析器输出的结果Token序列是语法分析器的输入。</p>
<h5 id="文法">文法</h5>
<p>上下文无关文法 是用来形式化、精确描述某种编程语言的工具，我们能够通过文法定义一种语言的语法，它主要包含一系列用于转换字符串的生产规则。上下文无关文法中的每一个生产规则都会将规则左侧的非终结符转换成右侧的字符串，也可以理解为用左侧的规则名来表示右侧的文件具体内容，从下面代码就可以看出来右侧有很多属于Go日常开发中的常用关键词。</p>
<p>从 <a class="link" href="https://github.com/golang/go/blob/master/src/cmd/compile/internal/syntax/parser.go"  target="_blank" rel="noopener"
    ><code>src/cmd/compile/internal/syntax/parser.go</code></a>文件中摘抄一些 Go 语言文法的生产规则：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="line"><span class="cl"><span class="nx">SourceFile</span> <span class="p">=</span> <span class="nx">PackageClause</span> <span class="s">&#34;;&#34;</span> <span class="p">{</span> <span class="nx">ImportDecl</span> <span class="s">&#34;;&#34;</span> <span class="p">}</span> <span class="p">{</span> <span class="nx">TopLevelDecl</span> <span class="s">&#34;;&#34;</span> <span class="p">}</span> <span class="p">.</span>
</span></span><span class="line"><span class="cl"><span class="nx">PackageClause</span>  <span class="p">=</span> <span class="s">&#34;package&#34;</span> <span class="nx">PackageName</span> <span class="p">.</span>
</span></span><span class="line"><span class="cl"><span class="nx">PackageName</span>    <span class="p">=</span> <span class="nx">identifier</span> <span class="p">.</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="nx">ImportDecl</span>       <span class="p">=</span> <span class="s">&#34;import&#34;</span> <span class="p">(</span> <span class="nx">ImportSpec</span> <span class="p">|</span> <span class="s">&#34;(&#34;</span> <span class="p">{</span> <span class="nx">ImportSpec</span> <span class="s">&#34;;&#34;</span> <span class="p">}</span> <span class="s">&#34;)&#34;</span> <span class="p">)</span> <span class="p">.</span>
</span></span><span class="line"><span class="cl"><span class="nx">ImportSpec</span>       <span class="p">=</span> <span class="p">[</span> <span class="s">&#34;.&#34;</span> <span class="p">|</span> <span class="nx">PackageName</span> <span class="p">]</span> <span class="nx">ImportPath</span> <span class="p">.</span>
</span></span><span class="line"><span class="cl"><span class="nx">ImportPath</span>       <span class="p">=</span> <span class="nx">string_lit</span> <span class="p">.</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="nx">TopLevelDecl</span>  <span class="p">=</span> <span class="nx">Declaration</span> <span class="p">|</span> <span class="nx">FunctionDecl</span> <span class="p">|</span> <span class="nx">MethodDecl</span> <span class="p">.</span>
</span></span><span class="line"><span class="cl"><span class="nx">Declaration</span>   <span class="p">=</span> <span class="nx">ConstDecl</span> <span class="p">|</span> <span class="nx">TypeDecl</span> <span class="p">|</span> <span class="nx">VarDecl</span> <span class="p">.</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>因为每个 Go 源代码文件最终都会被解析成一个独立的抽象语法树，所以语法树最顶层的结构或者开始符号都是 SourceFile。</p>
<p>从 SourceFile 相关的生产规则我们可以看出，每一个文件都包含一个 <code>package</code> 的定义以及可选的 <code>import</code> 声明和其他的顶层声明（在花括号中表示可选，类似正则），每一个 SourceFile 在编译器中都对应一个 <a class="link" href="https://draveness.me/golang/tree/cmd/compile/internal/syntax.File"  target="_blank" rel="noopener"
    ><code>cmd/compile/internal/syntax.File</code></a> 结构体，你能从它们的定义中轻松找到两者的联系：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="line"><span class="cl"><span class="kd">type</span> <span class="nx">File</span> <span class="kd">struct</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">	<span class="nx">Pragma</span>   <span class="nx">Pragma</span>
</span></span><span class="line"><span class="cl">	<span class="nx">PkgName</span>  <span class="o">*</span><span class="nx">Name</span>
</span></span><span class="line"><span class="cl">	<span class="nx">DeclList</span> <span class="p">[]</span><span class="nx">Decl</span>
</span></span><span class="line"><span class="cl">	<span class="nx">Lines</span>    <span class="kt">uint</span>
</span></span><span class="line"><span class="cl">	<span class="nx">node</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>顶层声明有五大类型，分别是常量、类型、变量、函数和方法，你可以在文件 <a class="link" href="https://github.com/golang/go/blob/master/src/cmd/compile/internal/syntax/parser.go"  target="_blank" rel="noopener"
    ><code>src/cmd/compile/internal/syntax/parser.go</code></a> 中找到这五大类型的定义。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="line"><span class="cl"><span class="nx">ConstDecl</span> <span class="p">=</span> <span class="s">&#34;const&#34;</span> <span class="p">(</span> <span class="nx">ConstSpec</span> <span class="p">|</span> <span class="s">&#34;(&#34;</span> <span class="p">{</span> <span class="nx">ConstSpec</span> <span class="s">&#34;;&#34;</span> <span class="p">}</span> <span class="s">&#34;)&#34;</span> <span class="p">)</span> <span class="p">.</span>
</span></span><span class="line"><span class="cl"><span class="nx">ConstSpec</span> <span class="p">=</span> <span class="nx">IdentifierList</span> <span class="p">[</span> <span class="p">[</span> <span class="nx">Type</span> <span class="p">]</span> <span class="s">&#34;=&#34;</span> <span class="nx">ExpressionList</span> <span class="p">]</span> <span class="p">.</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="nx">TypeDecl</span>  <span class="p">=</span> <span class="s">&#34;type&#34;</span> <span class="p">(</span> <span class="nx">TypeSpec</span> <span class="p">|</span> <span class="s">&#34;(&#34;</span> <span class="p">{</span> <span class="nx">TypeSpec</span> <span class="s">&#34;;&#34;</span> <span class="p">}</span> <span class="s">&#34;)&#34;</span> <span class="p">)</span> <span class="p">.</span>
</span></span><span class="line"><span class="cl"><span class="nx">TypeSpec</span>  <span class="p">=</span> <span class="nx">AliasDecl</span> <span class="p">|</span> <span class="nx">TypeDef</span> <span class="p">.</span>
</span></span><span class="line"><span class="cl"><span class="nx">AliasDecl</span> <span class="p">=</span> <span class="nx">identifier</span> <span class="s">&#34;=&#34;</span> <span class="nx">Type</span> <span class="p">.</span>
</span></span><span class="line"><span class="cl"><span class="nx">TypeDef</span>   <span class="p">=</span> <span class="nx">identifier</span> <span class="nx">Type</span> <span class="p">.</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="nx">VarDecl</span> <span class="p">=</span> <span class="s">&#34;var&#34;</span> <span class="p">(</span> <span class="nx">VarSpec</span> <span class="p">|</span> <span class="s">&#34;(&#34;</span> <span class="p">{</span> <span class="nx">VarSpec</span> <span class="s">&#34;;&#34;</span> <span class="p">}</span> <span class="s">&#34;)&#34;</span> <span class="p">)</span> <span class="p">.</span>
</span></span><span class="line"><span class="cl"><span class="nx">VarSpec</span> <span class="p">=</span> <span class="nf">IdentifierList</span> <span class="p">(</span> <span class="nx">Type</span> <span class="p">[</span> <span class="s">&#34;=&#34;</span> <span class="nx">ExpressionList</span> <span class="p">]</span> <span class="p">|</span> <span class="s">&#34;=&#34;</span> <span class="nx">ExpressionList</span> <span class="p">)</span> <span class="p">.</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>上述的文法分别定义了 Go 语言中常量、类型和变量三种常见的结构，从文法中可以看到语言中的很多关键字 <code>const</code>、<code>type</code> 和 <code>var</code></p>
<h5 id="分析方法">分析方法</h5>
<p>语法分析的分析方法一般分为自顶向下和自底向上两种，这两种方式会使用不同的方式对输入的 Token 序列进行推导：</p>
<ul>
<li>自顶向下分析：可以被看作找到当前输入流最左推导的过程，对于任意一个输入流，根据当前的输入符号，确定一个生产规则，使用生产规则右侧的符号替代相应的非终结符向下推导。</li>
<li>自底向上分析：语法分析器从输入流开始，每次都尝试重写最右侧的多个符号，这其实是说解析器会从最简单的符号进行推导，在解析的最后合并成开始符号。</li>
</ul>
<p>自顶向下和自底向上都是从开始符号开始解析，直到整个字符串中不存在任何的非终结符，整个解析过程才会结束。个人理解就是从源文件最开始时解析，根据生产规则向下进行逐个匹配。而两者的区别是对于生产规则的匹配一个是从头到尾一个是从尾到头</p>
<p>LL文法是一种使用自顶向下分析方法的文法。常见的四种文法 LR(0)、SLR、LR(1) 和 LALR(1) 则使用了自底向上的处理方式</p>
<h5 id="lookahead">Lookahead</h5>
<p>在语法分析中除了 LL 和 LR 这两种不同类型的语法分析方法之外，还存在另一个非常重要的概念，就是 <code>向前查看</code>，在不同生产规则发生冲突时（当前内容符合多个生产规则），当前解析器需要通过预读一些 Token 判断当前应该用什么生产规则对输入流进行展开或者归约，例如在 LALR(1) 文法中，需要预读一个 Token 保证出现冲突的生产规则能够被正确处理。</p>
<p>Go 语言的解析器使用了 LALR(1) 的文法来解析词法分析过程中输出的 Token 序列，最右推导加向前查看构成了 Go 语言解析器的最基本原理，也是大多数编程语言的选择。<code>语法分析就是将token序列根据各种生产规则解析成抽象语法树</code></p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="line"><span class="cl"><span class="s">&#34;json.go&#34;</span><span class="p">:</span> <span class="nx">SourceFile</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="nx">PackageName</span><span class="p">:</span> <span class="s">&#34;json&#34;</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">    <span class="nx">ImportDecl</span><span class="p">:</span> <span class="p">[]</span><span class="nx">Import</span><span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="s">&#34;io&#34;</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">    <span class="p">},</span>
</span></span><span class="line"><span class="cl">    <span class="nx">TopLevelDecl</span><span class="p">:</span> <span class="o">...</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>在Go中词法分析和语法分析是同时进行的，词法分析获取一个Token后马上对这个Token进行语法分析，然后循环这个步骤直到读完文件。</p>
<h3 id="类型检查">类型检查</h3>
<h4 id="强弱类型">强弱类型</h4>
<p>强类型和弱类型经常会被放在一起讨论，然而这两者并没有一个学术上的严格定义，我们很多时候只能根据现象和特性从直觉上进行判断：</p>
<ul>
<li>强类型的编程语言在编译期间会有更严格的类型限制，也就是编译器会在编译期间发现变量赋值、返回值和函数调用时的类型错误后结束编译。</li>
<li>弱类型的编程语言在出现类型错误时可能会在运行时自动进行隐式的类型转换，在类型转换时可能会造成运行错误，即它对类型的正确与否没有很强的限制，在运行时也只是可能会类型转换失败。</li>
</ul>
<p>因为Go语言会在编译期间发现类型错误，也属于是强类型的编程语言。</p>
<h4 id="静态类型和动态类型">静态类型和动态类型</h4>
<h5 id="静态类型检查">静态类型检查</h5>
<p><code>静态类型检查是基于对源代码的分析来确定运行程序 类型安全的过程，</code>如果代码能够通过静态类型检查，那么当前程序在一定程度上可以满足类型安全的要求，它能够减少程序在运行时的类型检查，也可以被看作是一种代码优化的方式。</p>
<p>静态类型检查可以帮助我们在编译期间发现程序中出现的类型错误，一些动态类型的编程语言都有社区提供的工具为这些编程语言加入静态类型检查功能，比如JS的Flow，这些工具能够在编译期间发现代码中的类型错误。</p>
<p>静态类型检查为代码在编译期间提供了约束，编译器能够在编译期间约束变量的类型。避免类型错误直到运行时才会报错崩溃，要是业务逻辑很复杂且这个错误在判断语句中，那么寻找这个错误就会花费大量的时间（特定情况才出现bug，很难排查），而静态类型检查在编译时就会明明白白的告诉你错误发生在何处，是什么原因。</p>
<p>静态类型检查在重构时能够帮助我们节省大量的时间并避免遗漏，但是如果编程语言仅支持动态类型检查，那么就需要写大量的单元测试保证重构不会出现类型错误。</p>
<h5 id="动态类型检查">动态类型检查</h5>
<p>大部分的动态类型编程语言是解释型的，也就是一边解释一边执行，没有生成中间代码或者二进制文件的过程。所有的语言都需要经过<strong>编译</strong>这一过程，但是不一定有编译器(compiler)这东西，它们可能是在解释器(interpreter)中进行这一过程。</p>
<p><code>动态类型检查是在运行时再确定程序类型安全的过程，</code>它需要编程语言在编译时为所有的对象加入类型标签等信息，运行时可以使用这些存储的类型信息来实现动态派发、向下转型、反射以及其他特性。</p>
<p>动态类型检查能为程序员提供更多的操作空间，可以在运行时获取一些类型相关的上下文并根据对象的类型完成一些动态操作。虽然使用动态类型检查的编程语言在使用上非常灵活也不需要经过编译，但是有问题的代码不会因为更加灵活就减少错误，它在提高灵活性的同时也提高了对程序员开发能力的要求。</p>
<p>静态类型检查和动态类型检查不是完全冲突和对立的，它们一个作用与编译期一个作用与运行时，很多编程语言都会同时使用两种类型检查。例如Java不仅在编译期间检查类型错误，还为对象添加了类型信息，在运行时使用反射根据对象的类型动态地执行方法增强灵活性并减少冗余代码。</p>
<p>golang就属于静态类型检查的编程语言，但通过反射机制提供了一定程度的动态类型检查的能力。这使得Go语言在处理类型信息和实现某些特定的动态行为时更加灵活和强大。但静态类型检查仍然是它的主要特点和设计原则。</p>
<p>golang可以使用 ( := )来进行类型推断，但是这个是在编译期推断的，并不是在运行时，编译期就已经根据 ( := )的初始值确定了变量的类型，后续不能再进行更改，这个只是为了方便变量声明的简洁性和可读性。</p>
<p><strong><code>Go语言的编译器不仅使用静态类型检查来保证程序运行的类型安全，还会和Java一样在编程期间引入类型信息，让程序员可以使用反射来判断参数和变量的类型。当我们想要将 interface{} 转换成具体类型时就会进行动态类型检查(运行时)，如果无法发生转换就会出现程序崩溃。</code></strong></p>
<p>类型检查是Go语言编译的第二个阶段，在词法和语法分析之后我们能得到每个文件对应的抽象语法树，随后的类型检查会遍历抽象语法树中的节点，对每个节点的类型进行检验，找出其中存在的语法错误，并且在这个过程中也会对抽象语法树进行改写，这不仅能够去除一些不会被执行的代码、对代码进行优化以提高执行效率，而且也会修改make、new等关键字对应节点的操作类型。</p>
<p>make和new 这些内置函数其实并不会直接对应某些函数的实现，而是会在编译阶段被转换成真正存在的其他函数。make就会在类型检查阶段根据创建的具体类型(make的第一个参数) 将make 替换成特定的函数 <code>makechan</code>、<code>makeslice</code>、<code>makemap</code>，这样后面 生成中间代码阶段 就不会再处理OMAKE类型的节点了，而是会根据生成的细分类型进行处理。</p>
<h3 id="中间代码生成">中间代码生成</h3>
<p>词法分析和语法分析以及类型检查都属于编译器前端，它们负责对源码进行分析并检查其中存在的词法和语法错误，经过这两个阶段生成的抽象语法树已经不存在语法错误了。而中间代码生成属于编译器后端。</p>
<p>中间代码是编译器或者虚拟机 (JAVA中的JVM) 使用的语言，它可以帮助我们分析计算机程序。在编译过程中，编译器会在 将源码转换为机器码的过程中，先将源码转换成一种中间的表示形式，即中间代码。</p>
<p>很多人可能认为中间代码没有太多价值，可以直接将源码翻译成目标语言，这种看起来可行的办法实际上有很多问题，其中最主要的问题就是它忽略了编译器所面对的复杂场景，很多编译器都需要将源码翻译成多种机器码，那么在这种情况下直接翻译高级编程语言就比较困难，翻译程序会十分庞大。而中间代码是一种更接近机器语言的表达形式，对中间代码的优化和分析相比于直接分析高级语言会更加容易。</p>
<p>中间代码的生成过程是从AST 抽象语法树到 SSA 中间代码的转换过程，在这期间会对语法树中的关键字再进行改写 (defer 及new之类的内置函数)，改写后的语法树会经过 <strong>多轮处理</strong> 转变成最后的SSA中间代码，<strong>而在这多轮处理时就会包含一些针对机器的特定修改，包括根据目标架构对代码进行改写（目标架构不一定是当前电脑，go可以指定编译各种架构的二进制文件）</strong>，相关代码中包含了大量switch语句、复杂的函数和调用栈（部分文件一个switch就占了上千行，正常开发是不允许有这种情况的）。</p>
<p>很多Go关键字和内置函数就是在这个阶段被转换成运行时包中方法的。</p>
<p><img src="/p/go-%E8%AF%AD%E8%A8%80%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0%E8%AF%BB%E5%90%8E%E7%90%86%E8%A7%A3/media/image-1.png"
	width="1084"
	height="869"
	srcset="/p/go-%E8%AF%AD%E8%A8%80%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0%E8%AF%BB%E5%90%8E%E7%90%86%E8%A7%A3/media/image-1_huead841100c3ff60837c925a867773eb3_144316_480x0_resize_box_3.png 480w, /p/go-%E8%AF%AD%E8%A8%80%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0%E8%AF%BB%E5%90%8E%E7%90%86%E8%A7%A3/media/image-1_huead841100c3ff60837c925a867773eb3_144316_1024x0_resize_box_3.png 1024w"
	loading="lazy"
	
		alt="image.png"
	
	
		class="gallery-image" 
		data-flex-grow="124"
		data-flex-basis="299px"
	
></p>
<p><strong>中间代码就是指令集，而在机器码生成阶段会先将 SSA中间代码 转换成汇编语言最终再编译为机器码，而机器码就是最终的二进制文件。中间代码是一种特定于编程语言和平台的中间表示形式，通常比源代码更接近于机器码，但仍不是直接的机器码。</strong></p>
<h3 id="机器码生成">机器码生成</h3>
<p>Go语言编译的最后一个阶段是根据 SSA 中间代码生成机器码，这里谈的机器码是在目标 CPU架构上能够运行的二进制代码，而在中间代码环节的将近50 个生成中间代码的步骤中有一些过程严格上说是属于机器码生成阶段的。</p>
<p>机器码的生成过程其实就是对 SSA 中间代码的降级过程，在SSA中间代码降级的过程中，编译器将一些值重写成了目标CPU架构的特定值，降级的过程 处理了所有 机器特定的重写规则并对代码进行了一定程度的优化；在 SSA 中间代码生成阶段的最后，Go 函数体的代码会被转换成 <a class="link" href="https://draveness.me/golang/tree/cmd/compile/internal/obj.Prog"  target="_blank" rel="noopener"
    ><code>cmd/compile/internal/obj.Prog</code></a> 结构。</p>
<h4 id="指令集架构">指令集架构</h4>
<p>指令集架构是计算机的抽象模型，在很多时候也被称作架构或者计算机架构，它是计算机软件和硬件之间的接口和桥梁；一个为特定指令集架构编写的应用程序能够运行在所有支持这种指令集架构的机器上，也就是说如果当前应用程序支持x86的指令集，那么就可以运行在所有使用x86指令集的机器上，这其实就是抽象层的作用。每一个指令集架构都定义了支持的数据结构、寄存器、管理主内存的硬件支持（例如内存一致、地址模拟以及虚拟内存）、支持的指令集和IO模型，指令集的引入其实就是在软件和硬件之间引入了一个抽象层，让同一个二进制文件能够在不同版本的硬件上运行。</p>
<p>当前这里只是说是可以在同一种指令集机器上运行，并没有考虑系统，系统也是属于软件，不同的系统针对二进制文件可能有不同的处理，例如windows编译后的二进制文件放在linux上可能就无法运行，这是因为他们依赖并不相同。</p>
<p>如果一个编程语言想要在所有的机器上运行，它就可以将中间代码分别转换成使用不同指令集架构的机器码，这可比为不同硬件单独移植要简单的太多了。</p>
<h5 id="复杂指令集cisc和精简指令集risc">复杂指令集（CISC）和精简指令集（RISC）</h5>
<p>最常见的指令集架构分类方法是根据指令的复杂度将其分为 复杂指令集（CISC）和精简指令集（RISC），复杂指令集架构包含了很多特定的指令，但是其中的一些指令很少会被程序使用，但是又不能舍弃。而精简指令集只实现了经常被使用的指令，不常用的操作都会通过组合简单指令来实现。</p>
<p>因此复杂指令集性能更强大，因为它在电路板上焊了特定的指令集，但是这也意味着功耗更高，体积更大，而精简指令集由于是组合而来，它会弱一些，但是它功耗和体积会小点。</p>
<p>复杂指令集的特点就是指令数目多且复杂，每条指令的字节长度并不相等，x86就是常见的复杂指令集处理器，它的指令长度大小范围非常广，从 1 到 15 字节不等，对于长度不固定的指令，计算机必须额外对指令进行判断，这需要付出额外的性能损失。</p>
<p>而精简指令集对指令的数目和寻址方式做了精简，大大减少指令数量的同时也更容易实现，指令集中的每一个指令都使用标准的字节长度、执行时间相比复杂指令集会少很多，处理器在处理指令时也可以流水执行，提高了对并行的支持。</p>
<p>ARM 作为一种常见的精简指令集处理器，使用了 4个字节来作为指令集的固定长度，解决了因判断指令长度造成的性能损失问题。精简指令集其实就是利用了我们耳熟能详的二八原则，用20%的基础指令和它们的组合来解决大部分问题。</p>
<p>其宗旨就是通过优化设计，使得用尽可能少的基础指令可以覆盖尽可能多的操作需求。剩余的少部分特殊问题会在实际情况中通过如微码指令、专门的硬件单元等方法解决。</p>
<p>最开始的计算机使用复杂指令集是因为当时计算机的性能和内存都比较有限，业界需要尽可能地减少机器需要执行的指令，所以更倾向于高度编码、长度不等以及多操作数的指令。不过随着计算机性能的提升，出现了精简指令集这种牺牲代码密度换取简单实现的设计；除此之外，硬件的飞速提升还带来了更多的寄存器和更高的时钟频率，软件开发人员也不用再直接接触汇编代码，而是通过编译器和汇编器生成指令，复杂的机器指令对于编译器来说很难利用，所以精简指令在这种场景下更适合。</p>
<p>复杂指令集和精简指令集的使用是设计上的权衡，经过这么多年的发展，两种指令集也在相互借鉴和学习，与最开始刚被设计出来时已经有了较大的差别。</p>
<h4 id="机器码生成-1">机器码生成</h4>
<p>机器码的生成在 Go 的编译器中主要由两部分协同工作，其中一部分是负责 SSA 中间代码降级和根据目标架构进行特定处理的 <a class="link" href="https://github.com/golang/go/tree/master/src/cmd/compile/internal/ssa"  target="_blank" rel="noopener"
    ><code>cmd/compile/internal/ssa</code></a> 包，另一部分是负责生成机器码的 <a class="link" href="https://github.com/golang/go/tree/master/src/cmd/internal/obj"  target="_blank" rel="noopener"
    ><code>cmd/internal/obj</code></a></p>
<h5 id="ssa降级">SSA降级</h5>
<p>SSA 降级是在中间代码生成的过程中完成的，其中将近 50 轮处理的过程中，<code>lower</code> 以及后面的阶段都属于 SSA 降级这一过程，这么多轮的处理会对架构进行特定的优化和重写并生成 <a class="link" href="https://github.com/golang/go/blob/da54dfb6a1f3bef827b9ec3780c98fde77a97d11/src/cmd/internal/obj/link.go#L284"  target="_blank" rel="noopener"
    ><code>cmd/compile/internal/obj.Prog</code></a> 指令：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span><span class="lnt">8
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="line"><span class="cl"><span class="kd">var</span> <span class="nx">passes</span> <span class="p">=</span> <span class="p">[</span><span class="o">...</span><span class="p">]</span><span class="nx">pass</span><span class="p">{</span>
</span></span><span class="line"><span class="cl">	<span class="o">...</span>
</span></span><span class="line"><span class="cl">	<span class="p">{</span><span class="nx">name</span><span class="p">:</span> <span class="s">&#34;lower&#34;</span><span class="p">,</span> <span class="nx">fn</span><span class="p">:</span> <span class="nx">lower</span><span class="p">,</span> <span class="nx">required</span><span class="p">:</span> <span class="kc">true</span><span class="p">},</span>
</span></span><span class="line"><span class="cl">	<span class="p">{</span><span class="nx">name</span><span class="p">:</span> <span class="s">&#34;lowered deadcode for cse&#34;</span><span class="p">,</span> <span class="nx">fn</span><span class="p">:</span> <span class="nx">deadcode</span><span class="p">},</span> <span class="c1">// deadcode immediately before CSE avoids CSE making dead values live again
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="p">{</span><span class="nx">name</span><span class="p">:</span> <span class="s">&#34;lowered cse&#34;</span><span class="p">,</span> <span class="nx">fn</span><span class="p">:</span> <span class="nx">cse</span><span class="p">},</span>
</span></span><span class="line"><span class="cl">	<span class="o">...</span>
</span></span><span class="line"><span class="cl">	<span class="p">{</span><span class="nx">name</span><span class="p">:</span> <span class="s">&#34;trim&#34;</span><span class="p">,</span> <span class="nx">fn</span><span class="p">:</span> <span class="nx">trim</span><span class="p">},</span> <span class="c1">// remove empty blocks
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="p">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>重写的过程会将通用的 SSA中间代码 转换成目标架构特定的指令。可以通过对指令的压缩和优化减少在目标硬件上执行所需要的时间和资源。而紧接着就会使用obj包将SSA中间代码转换成汇编代码再编译为机器码。</p>
<p><a class="link" href="https://draveness.me/golang/tree/cmd/compile/internal/gc.buildssa"  target="_blank" rel="noopener"
    ><code>cmd/compile/internal/gc.buildssa</code></a> 中的 <code>lower</code> 和随后的多个阶段会对 SSA 进行转换、检查和优化，生成机器特定的中间代码（之前属于中间代码生成阶段）， <code>cmd/compile/internal/gc.compileSSA</code> 中的genssa会创建一个新的 <a class="link" href="https://draveness.me/golang/tree/cmd/compile/internal/gc.Progs"  target="_blank" rel="noopener"
    ><code>cmd/compile/internal/gc.Progs</code></a> 结构并将生成的 SSA 中间代码都存入新建的结构体中，至此SSA降级结束，随后调用的 pp.Flush() - <a class="link" href="https://draveness.me/golang/tree/cmd/compile/internal/gc.Progs.Flush"  target="_blank" rel="noopener"
    ><code>cmd/compile/internal/gc.Progs.Flush</code></a> 会使用 <a class="link" href="https://github.com/golang/go/tree/master/src/cmd/internal/obj"  target="_blank" rel="noopener"
    ><code>cmd/internal/obj</code></a> 包中的汇编器将 SSA 转换成汇编代码并编译成机器码。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span><span class="lnt">8
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="line"><span class="cl"><span class="kd">func</span> <span class="nf">compileSSA</span><span class="p">(</span><span class="nx">fn</span> <span class="o">*</span><span class="nx">Node</span><span class="p">,</span> <span class="nx">worker</span> <span class="kt">int</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">	<span class="nx">f</span> <span class="o">:=</span> <span class="nf">buildssa</span><span class="p">(</span><span class="nx">fn</span><span class="p">,</span> <span class="nx">worker</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">	<span class="nx">pp</span> <span class="o">:=</span> <span class="nf">newProgs</span><span class="p">(</span><span class="nx">fn</span><span class="p">,</span> <span class="nx">worker</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">	<span class="k">defer</span> <span class="nx">pp</span><span class="p">.</span><span class="nf">Free</span><span class="p">()</span>
</span></span><span class="line"><span class="cl">	<span class="nf">genssa</span><span class="p">(</span><span class="nx">f</span><span class="p">,</span> <span class="nx">pp</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">	<span class="nx">pp</span><span class="p">.</span><span class="nf">Flush</span><span class="p">()</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>转换汇编代码和编译成机器码都是由pp.Flush() 中的<a class="link" href="https://draveness.me/golang/tree/cmd/internal/obj.Flushplist"  target="_blank" rel="noopener"
    ><code>cmd/internal/obj.Flushplist</code></a> 中的 <code>Preprocess</code> 和 <code>Assemble</code> 方法组合完成的，这两个方法非常复杂，且会根据不同架构执行不同的方法，比如x86架构就会执行<a class="link" href="https://draveness.me/golang/tree/cmd/internal/obj/x86.preprocess"  target="_blank" rel="noopener"
    ><code>cmd/internal/obj/x86.preprocess</code></a> 和 <a class="link" href="https://draveness.me/golang/tree/cmd/internal/obj/x86.span6"  target="_blank" rel="noopener"
    ><code>cmd/internal/obj/x86.span6</code></a> 。</p>
<h5 id="汇编器">汇编器</h5>
<p>汇编器是将汇编语言翻译为机器语言的程序，Go 语言的汇编器是基于 Plan 9 汇编器的输入类型设计的，不过Go 语言对于汇编语言 Plan 9 和汇编器的资料十分缺乏。</p>
<p>流程为：</p>
<p>源码  -&gt;  词法解析  -&gt;  语法解析  -&gt;  抽象语法树  -&gt;  类型检验  -&gt;  抽象语法树  -&gt;  中间代码  -&gt;  汇编  -&gt;  机器码</p>
<h2 id="数据结构">数据结构</h2>
<h3 id="数组">数组</h3>
<p>数组是由相同类型元素的集合组成的数据结构，计算机会为数组分配一块连续的内存来保存其中的元素，我们可以利用数组中元素的索引来快速访问特定的元素。</p>
<p>数组作为一种基本的数据类型，我们通常会从两个维度描述数组，也就是数组中存储的元素类型和数组最大能存储的元素个数。Go语言中 数组在初始化之后大小就无法改变，它的大小在初始化时就已经确定了，存储元素类型相同、但是大小不同的数组类型在Go 语言看来是两个完全不同的类型，只有两个条件都相同才是同一个类型。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span><span class="lnt">8
</span><span class="lnt">9
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="line"><span class="cl"><span class="kd">func</span> <span class="nf">NewArray</span><span class="p">(</span><span class="nx">elem</span> <span class="o">*</span><span class="nx">Type</span><span class="p">,</span> <span class="nx">bound</span> <span class="kt">int64</span><span class="p">)</span> <span class="o">*</span><span class="nx">Type</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">	<span class="k">if</span> <span class="nx">bound</span> <span class="p">&lt;</span> <span class="mi">0</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">		<span class="nf">Fatalf</span><span class="p">(</span><span class="s">&#34;NewArray: invalid bound %v&#34;</span><span class="p">,</span> <span class="nx">bound</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">	<span class="p">}</span>
</span></span><span class="line"><span class="cl">	<span class="nx">t</span> <span class="o">:=</span> <span class="nf">New</span><span class="p">(</span><span class="nx">TARRAY</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">	<span class="nx">t</span><span class="p">.</span><span class="nx">Extra</span> <span class="p">=</span> <span class="o">&amp;</span><span class="nx">Array</span><span class="p">{</span><span class="nx">Elem</span><span class="p">:</span> <span class="nx">elem</span><span class="p">,</span> <span class="nx">Bound</span><span class="p">:</span> <span class="nx">bound</span><span class="p">}</span>
</span></span><span class="line"><span class="cl">	<span class="nx">t</span><span class="p">.</span><span class="nf">SetNotInHeap</span><span class="p">(</span><span class="nx">elem</span><span class="p">.</span><span class="nf">NotInHeap</span><span class="p">())</span>
</span></span><span class="line"><span class="cl">	<span class="k">return</span> <span class="nx">t</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>编译期间的数组类型是由上述的 <a class="link" href="https://draveness.me/golang/tree/cmd/compile/internal/types.NewArray"  target="_blank" rel="noopener"
    ><code>cmd/compile/internal/types.NewArray</code></a> 函数生成的，该类型包含两个字段，分别是元素类型 <code>Elem</code> 和数组的大小 <code>Bound</code>，这两个字段共同构成了数组类型，而当前数组是否应该在堆栈中初始化也在编译期就确定了。</p>
<h4 id="初始化">初始化</h4>
<p>Go语言的数组有两种不同的创建方式，一种是显式的指定数组大小，另一种是使用 <code>[...]T</code> 声明数组，Go语言会在编译期间通过源码自动推导数组的大小。这两种声明方式在运行期间得到的结果是完全相同的，后一种声明方式在编译期间就会被转换成前一种，这就是编译器对数组大小的推导。</p>
<h5 id="上限推导">上限推导</h5>
<p>这两种不同的声明方式会导致编译器做出完全不同的处理，如果使用 <code>[10]T</code> 的方式，那么变量的类型在编译进行到类型检查阶段就会被提取出来，随后会调用NewArray函数创建包含数组大小的结构体。</p>
<p>如果使用 <code>[...]T</code> 的方式声明数组，编译器会在 <a class="link" href="https://draveness.me/golang/tree/cmd/compile/internal/gc.typecheckcomplit"  target="_blank" rel="noopener"
    ><code>cmd/compile/internal/gc.typecheckcomplit</code></a> 函数中先对该数组的大小进行推导，其中的 <code>typecheckarraylit </code>函数会通过遍历元素的方式来计算数组中元素的数量，再调用NewArray函数创建数组结构体。</p>
<p>所以，<code>[...]T{1, 2, 3}</code> 和 <code>[3]T{1, 2, 3}</code> 在运行时是完全等价的，<code>[...]T</code> 这种初始化方式也只是 Go 语言为我们提供的一种语法糖，当我们不想计算数组中的元素个数时可以通过这种方法减少一些工作量。</p>
<h5 id="语句转换">语句转换</h5>
<p>对于一个由字面量组成的数组（字面量在数组中指的就是初始化时附带的元素集合，即 <code>[4]int{1,2,3,4}</code>中的[1,2,3,4]就是字面量），根据数组初始化的元素数量的不同，编译器会在负责 初始化 字面量的 <a class="link" href="https://draveness.me/golang/tree/cmd/compile/internal/gc.anylit"  target="_blank" rel="noopener"
    ><code>cmd/compile/internal/gc.anylit</code></a> 函数中做两种不同的优化：</p>
<ol>
<li>当元素数量小于或者等于 4 个时，会直接将数组中的元素放置在栈上；</li>
<li>当元素数量大于 4 个时，会将数组中的元素放置到静态区并在运行时取出；</li>
</ol>
<p>大于4个放置在静态区是因为 当数组元素较多时，栈上分配可能导致栈溢出等问题，所以会先在静态存储区初始化然后拷贝到栈上，不要纠结初始化并赋值和先初始化后赋值谁快谁慢的问题，在编译阶段会对 <code>[4]int{1,2,3,4}</code>进行展开，变成先声明后一一赋值的形式，日常开发不用考虑初始化时元素个数的情况。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="line"><span class="cl"><span class="kd">var</span> <span class="nx">arr</span> <span class="p">[</span><span class="mi">5</span><span class="p">]</span><span class="kt">int</span>
</span></span><span class="line"><span class="cl"><span class="nx">statictmp_0</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="p">=</span> <span class="mi">1</span>
</span></span><span class="line"><span class="cl"><span class="nx">statictmp_0</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="p">=</span> <span class="mi">2</span>
</span></span><span class="line"><span class="cl"><span class="nx">statictmp_0</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="p">=</span> <span class="mi">3</span>
</span></span><span class="line"><span class="cl"><span class="nx">statictmp_0</span><span class="p">[</span><span class="mi">3</span><span class="p">]</span> <span class="p">=</span> <span class="mi">4</span>
</span></span><span class="line"><span class="cl"><span class="nx">statictmp_0</span><span class="p">[</span><span class="mi">4</span><span class="p">]</span> <span class="p">=</span> <span class="mi">5</span>
</span></span><span class="line"><span class="cl"><span class="nx">arr</span> <span class="p">=</span> <span class="nx">statictmp_0</span>
</span></span></code></pre></td></tr></table>
</div>
</div><h4 id="访问和赋值">访问和赋值</h4>
<p>无论是在栈上还是静态存储区，数组在内存中都是一连串的内存空间，我们通过指向数组开头的指针、元素的数量以及元素类型占的空间大小表示数组。如果我们不知道数组中元素的数量，访问时可能发生索引越界；而如果不知道数组中元素类型的大小，就没办法知道一次应该取出多少字节的数据，无论丢失了哪个信息，我们都没办法知道这片连续的内存空间到底存储了什么数据。</p>
<p>数组访问越界是非常严重的错误，Go 语言中可以在编译期间的静态类型检查判断数组越界，但是由于切片的大小是动态扩容的，切片就没办法在编译期间判断出是否越界的问题，<a class="link" href="https://draveness.me/golang/tree/cmd/compile/internal/gc.typecheck1"  target="_blank" rel="noopener"
    ><code>cmd/compile/internal/gc.typecheck1</code></a> 会验证访问数组的索引。</p>
<ol>
<li>访问数组的索引是非整数时，报错 “non-integer array index %v”；</li>
<li>访问数组的索引是负数时，报错 “invalid array index %v (index must be non-negative)&quot;；</li>
<li>访问数组的索引越界时，报错 “invalid array index %v (out of bounds for %d-element array)&quot;；</li>
</ol>
<p>数组和字符串的一些简单越界错误都会在编译期间发现，但是如果使用变量去访问数组或者字符串时，编译器就无法提前发现错误，我们需要 Go 语言在运行时来阻止不合法的访问。Go 语言运行时在发现数组、切片和字符串的越界操作会由运行时的 <a class="link" href="https://draveness.me/golang/tree/runtime.panicIndex"  target="_blank" rel="noopener"
    ><code>runtime.panicIndex</code></a> 和 <a class="link" href="https://draveness.me/golang/tree/runtime.goPanicIndex"  target="_blank" rel="noopener"
    ><code>runtime.goPanicIndex</code></a> 触发程序的运行时错误并导致异常崩溃退出。</p>
<p>只有当编译器无法对数组下标是否越界作出判断时才会加入 <code>PanicBounds</code> 指令（即<a class="link" href="https://draveness.me/golang/tree/runtime.panicIndex"  target="_blank" rel="noopener"
    ><code>runtime.panicIndex</code></a> 函数）交给运行时进行判断，在使用常量数组下标时，如果静态类型检查阶段通过就会生成非常简单的中间代码。</p>
<p>生成ssa.html:</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="line"><span class="cl"><span class="kn">package</span> <span class="nx">check</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kd">func</span> <span class="nf">outOfRange</span><span class="p">()</span> <span class="kt">int</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">	<span class="nx">arr</span> <span class="o">:=</span> <span class="p">[</span><span class="mi">3</span><span class="p">]</span><span class="kt">int</span><span class="p">{</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">}</span>
</span></span><span class="line"><span class="cl">	<span class="nx">i</span> <span class="o">:=</span> <span class="mi">4</span>
</span></span><span class="line"><span class="cl">	<span class="nx">elem</span> <span class="o">:=</span> <span class="nx">arr</span><span class="p">[</span><span class="nx">i</span><span class="p">]</span>
</span></span><span class="line"><span class="cl">	<span class="k">return</span> <span class="nx">elem</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="err">$</span> <span class="nx">GOSSAFUNC</span><span class="p">=</span><span class="nx">outOfRange</span> <span class="k">go</span> <span class="nx">build</span> <span class="nx">array</span><span class="p">.</span><span class="k">go</span>
</span></span><span class="line"><span class="cl"><span class="nx">dumped</span> <span class="nx">SSA</span> <span class="nx">to</span> <span class="p">.</span><span class="o">/</span><span class="nx">ssa</span><span class="p">.</span><span class="nx">html</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>访问arr[2]生成的对应的SSA代码(start 阶段)：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="line"><span class="cl"><span class="nx">b1</span><span class="p">:</span>
</span></span><span class="line"><span class="cl">    <span class="nf">v14</span> <span class="p">(</span><span class="err">?</span><span class="p">)</span> <span class="p">=</span> <span class="nx">Const64</span> <span class="p">&lt;</span><span class="kt">int</span><span class="p">&gt;</span> <span class="p">[</span><span class="mi">2</span><span class="p">]</span>
</span></span><span class="line"><span class="cl">    <span class="o">...</span>
</span></span><span class="line"><span class="cl">    <span class="nf">v21</span> <span class="p">(</span><span class="mi">5</span><span class="p">)</span> <span class="p">=</span> <span class="nx">LocalAddr</span> <span class="p">&lt;</span><span class="o">*</span><span class="p">[</span><span class="mi">3</span><span class="p">]</span><span class="kt">int</span><span class="p">&gt;</span> <span class="p">{</span><span class="nx">arr</span><span class="p">}</span> <span class="nx">v2</span> <span class="nx">v20</span>
</span></span><span class="line"><span class="cl">    <span class="nf">v22</span> <span class="p">(</span><span class="mi">5</span><span class="p">)</span> <span class="p">=</span> <span class="nx">PtrIndex</span> <span class="p">&lt;</span><span class="o">*</span><span class="kt">int</span><span class="p">&gt;</span> <span class="nx">v21</span> <span class="nx">v14</span>
</span></span><span class="line"><span class="cl">    <span class="nf">v23</span> <span class="p">(</span><span class="mi">5</span><span class="p">)</span> <span class="p">=</span> <span class="nx">Load</span> <span class="p">&lt;</span><span class="kt">int</span><span class="p">&gt;</span> <span class="nx">v22</span> <span class="nf">v20</span> <span class="p">(</span><span class="nx">elem</span><span class="p">[</span><span class="kt">int</span><span class="p">])</span>
</span></span><span class="line"><span class="cl">    <span class="o">...</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>v21是寻址获取数组地址，v22是利用 <code>PtrIndex</code>  通过数组地址和下标计算出目标元素的地址，最后使用 <code>Load</code> 操作将指针中的元素加载到内存中</p>
<p>Go语言对于数组的访问还是有着比较多的检查的，它不仅会在编译期间提前发现一些简单的越界错误并插入用于检测数组上限的 <code>PanicBounds</code> 函数调用，还会在运行期间通过插入的函数来保证数组不会发生越界。</p>
<p>数组的赋值和更新操作 <code>a[2] = 2</code> 也会生成SSA中间代码：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="line"><span class="cl"><span class="nx">b1</span><span class="p">:</span>
</span></span><span class="line"><span class="cl">    <span class="o">...</span>
</span></span><span class="line"><span class="cl">    <span class="nf">v21</span> <span class="p">(</span><span class="mi">5</span><span class="p">)</span> <span class="p">=</span> <span class="nx">LocalAddr</span> <span class="p">&lt;</span><span class="o">*</span><span class="p">[</span><span class="mi">3</span><span class="p">]</span><span class="kt">int</span><span class="p">&gt;</span> <span class="p">{</span><span class="nx">arr</span><span class="p">}</span> <span class="nx">v2</span> <span class="nx">v19</span>
</span></span><span class="line"><span class="cl">    <span class="nf">v22</span> <span class="p">(</span><span class="mi">5</span><span class="p">)</span> <span class="p">=</span> <span class="nx">PtrIndex</span> <span class="p">&lt;</span><span class="o">*</span><span class="kt">int</span><span class="p">&gt;</span> <span class="nx">v21</span> <span class="nx">v13</span>
</span></span><span class="line"><span class="cl">    <span class="nf">v23</span> <span class="p">(</span><span class="mi">5</span><span class="p">)</span> <span class="p">=</span> <span class="nx">Store</span> <span class="p">&lt;</span><span class="nx">mem</span><span class="p">&gt;</span> <span class="p">{</span><span class="kt">int</span><span class="p">}</span> <span class="nx">v22</span> <span class="nx">v20</span> <span class="nx">v19</span>
</span></span><span class="line"><span class="cl">    <span class="o">...</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>赋值的过程中会先确定目标数组的地址，再通过 <code>PtrIndex</code> 获取目标元素的地址，最后使用 <code>Store</code> 指令将数据存入地址中。而如果下标不是常量也会有 <code>PanicBounds</code> 函数调用来避免越界。</p>
<p>总结一下就是，数组的访问和赋值需要同时依赖编译器和运行时，它的大多数操作在编译期间都会转换成直接读写内存，并在中间代码生成阶段，如果在编译期间无法判断数组是否越界（即下标非常量），编译器还会插入运行时方法 <a class="link" href="https://draveness.me/golang/tree/runtime.panicIndex"  target="_blank" rel="noopener"
    ><code>runtime.panicIndex</code></a> 调用防止发生越界错误。</p>
<h3 id="切片">切片</h3>
<p>数组在Go 语言中没有那么常用，更常用的数据结构是切片，即动态数组，其长度并不固定，可以随时向切片中追加元素，它会在容量不足时自动扩容。</p>
<h4 id="数据结构-1">数据结构</h4>
<p>编译期间的切片是 <a class="link" href="https://github.com/golang/go/blob/3b2a578166bdedd94110698c971ba8990771eb89/src/cmd/compile/internal/types/type.go#L346"  target="_blank" rel="noopener"
    ><code>cmd/compile/internal/types.Slice</code></a> 类型的，但是在运行时切片是由 <a class="link" href="https://github.com/golang/go/blob/41d8e61a6b9d8f9db912626eb2bbc535e929fefc/src/reflect/value.go#L1994"  target="_blank" rel="noopener"
    ><code>reflect.SliceHeader</code></a> 结构体表示，其中:</p>
<ul>
<li><code>Data</code> 是指向底层数组的指针;</li>
<li><code>Len</code> 是当前切片的长度；</li>
<li><code>Cap</code> 是当前切片的容量，即 <code>Data</code> 数组的大小：</li>
</ul>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="line"><span class="cl"><span class="kd">type</span> <span class="nx">SliceHeader</span> <span class="kd">struct</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">	<span class="nx">Data</span> <span class="kt">uintptr</span>
</span></span><span class="line"><span class="cl">	<span class="nx">Len</span>  <span class="kt">int</span>
</span></span><span class="line"><span class="cl">	<span class="nx">Cap</span>  <span class="kt">int</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>Data 是一片连续的内存空间，这片内存空间可以用于存储切片中的全部元素，元素在底层存储时都是连续的，因此可以将切片理解成一片连续的内存空间加上长度与容量的标识。</p>
<p>切片与数组的关系非常密切，切片引入了一个抽象层，提供了对底层数组中部分连续片段的引用，而作为数组的引用，我们可以在运行期间修改它的长度和范围。当切片底层的数组长度不足以存放新增元素时就会触发扩容，扩容会导致其指向另一个新的底层数组，不过在上层看来切片是没有变化的，上层只需要与切片打交道，不需要关心底层数组的变化。</p>
<p>数组的内存布局在编译时就已经确定（长度固定），在运行时可以直接读写内存的特定位置，而切片是在运行时确定结构的，因为切片的长度可能会变化，依赖运行时来支持动态调整大小等操作。</p>
<h4 id="初始化-1">初始化</h4>
<p>Go 语言中包含三种初始化切片的方式：</p>
<ol>
<li>通过下标的方式获得数组或者切片的一部分；</li>
<li>使用字面量初始化新的切片；</li>
<li>使用关键字 <code>make</code> 创建切片：</li>
</ol>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="line"><span class="cl"><span class="nx">arr</span><span class="p">[</span><span class="mi">0</span><span class="p">:</span><span class="mi">3</span><span class="p">]</span> <span class="nx">or</span> <span class="nx">slice</span><span class="p">[</span><span class="mi">0</span><span class="p">:</span><span class="mi">3</span><span class="p">]</span>
</span></span><span class="line"><span class="cl"><span class="nx">slice</span> <span class="o">:=</span> <span class="p">[]</span><span class="kt">int</span><span class="p">{</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="nx">slice</span> <span class="o">:=</span> <span class="nb">make</span><span class="p">([]</span><span class="kt">int</span><span class="p">,</span> <span class="mi">10</span><span class="p">)</span>
</span></span></code></pre></td></tr></table>
</div>
</div><h5 id="使用下标">使用下标</h5>
<p>使用下标创建切片是最原始也是最接近汇编语言的方式，它是所有方法中最为底层的一种，编译器会将 <code>arr[0:3]</code> 或者 <code>slice[0:3]</code> 等语句转换成 <code>OpSliceMake</code> 操作</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span><span class="lnt">8
</span><span class="lnt">9
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="line"><span class="cl"><span class="kn">package</span> <span class="nx">opslicemake</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kd">func</span> <span class="nf">newSlice</span><span class="p">()</span> <span class="p">[]</span><span class="kt">int</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">	<span class="nx">arr</span> <span class="o">:=</span> <span class="p">[</span><span class="mi">3</span><span class="p">]</span><span class="kt">int</span><span class="p">{</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">}</span>
</span></span><span class="line"><span class="cl">	<span class="nx">slice</span> <span class="o">:=</span> <span class="nx">arr</span><span class="p">[</span><span class="mi">0</span><span class="p">:</span><span class="mi">1</span><span class="p">]</span>
</span></span><span class="line"><span class="cl">	<span class="k">return</span> <span class="nx">slice</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="c1">// GOSSAFUNC=newSlice go build arr1.go
</span></span></span></code></pre></td></tr></table>
</div>
</div><p>通过 <code>GOSSAFUNC</code> 变量编译上述代码可以得到一系列 SSA 中间代码，其中 <code>slice := arr[0:1]</code> 语句在 “decompose builtin” 阶段对应的代码如下所示：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span><span class="lnt">8
</span><span class="lnt">9
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="line"><span class="cl"><span class="nf">v9</span> <span class="p">(</span><span class="mi">4</span><span class="p">)</span> <span class="p">=</span> <span class="nx">SelectN</span> <span class="p">&lt;</span><span class="o">*</span><span class="p">[</span><span class="mi">3</span><span class="p">]</span><span class="kt">int</span><span class="p">&gt;</span> <span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="nf">v7</span> <span class="p">(</span><span class="o">&amp;</span><span class="nx">arr</span><span class="p">[</span><span class="o">*</span><span class="p">[</span><span class="mi">3</span><span class="p">]</span><span class="kt">int</span><span class="p">],</span> <span class="nx">slice</span><span class="p">.</span><span class="nx">ptr</span><span class="p">[</span><span class="o">*</span><span class="kt">int</span><span class="p">])</span>
</span></span><span class="line"><span class="cl"><span class="o">...</span>
</span></span><span class="line"><span class="cl"><span class="nf">v12</span> <span class="p">(</span><span class="err">?</span><span class="p">)</span> <span class="p">=</span> <span class="nx">Const64</span> <span class="p">&lt;</span><span class="kt">int</span><span class="p">&gt;</span> <span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="p">(</span><span class="nx">slice</span><span class="p">.</span><span class="nx">len</span><span class="p">[</span><span class="kt">int</span><span class="p">])</span>
</span></span><span class="line"><span class="cl"><span class="nf">v15</span> <span class="p">(</span><span class="err">?</span><span class="p">)</span> <span class="p">=</span> <span class="nx">Const64</span> <span class="p">&lt;</span><span class="kt">int</span><span class="p">&gt;</span> <span class="p">[</span><span class="mi">3</span><span class="p">]</span> <span class="p">(</span><span class="nx">slice</span><span class="p">.</span><span class="nx">cap</span><span class="p">[</span><span class="kt">int</span><span class="p">])</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="nx">name</span> <span class="o">&amp;</span><span class="nx">arr</span><span class="p">[</span><span class="o">*</span><span class="p">[</span><span class="mi">3</span><span class="p">]</span><span class="kt">int</span><span class="p">]:</span> <span class="nx">v9</span>
</span></span><span class="line"><span class="cl"><span class="nx">name</span> <span class="nx">slice</span><span class="p">.</span><span class="nx">ptr</span><span class="p">[</span><span class="o">*</span><span class="kt">int</span><span class="p">]:</span> <span class="nx">v9</span>
</span></span><span class="line"><span class="cl"><span class="nx">name</span> <span class="nx">slice</span><span class="p">.</span><span class="nx">len</span><span class="p">[</span><span class="kt">int</span><span class="p">]:</span> <span class="nx">v12</span>
</span></span><span class="line"><span class="cl"><span class="nx">name</span> <span class="nx">slice</span><span class="p">.</span><span class="nx">cap</span><span class="p">[</span><span class="kt">int</span><span class="p">]:</span> <span class="nx">v15</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p><code>SliceMake</code> 操作会接受四个参数创建新的切片，元素类型、数组指针、切片大小和容量，从 <code>ssa.html</code> 中可以发现它的ptr指针指向的依然是原arr数组，而不是重新创建一个新的底层数组，<strong>因此使用下标来初始化切片不会拷贝原数组或者原切片中的数据，它只会创建一个指向原数组的切片结构体，因此修改新切片的数据也会修改到原切片（两者指针指向同一片内存）。</strong></p>
<h5 id="字面量">字面量</h5>
<p>当我们使用字面量 <code>[]int{1, 2, 3}</code> 创建新的切片时，<a class="link" href="https://github.com/golang/go/blob/3b2a578166bdedd94110698c971ba8990771eb89/src/cmd/compile/internal/gc/sinit.go#L590"  target="_blank" rel="noopener"
    ><code>cmd/compile/internal/gc.slicelit</code></a> 函数会在编译期间将它展开成如下所示的代码片段：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="line"><span class="cl"><span class="c1">// 声明底层数组
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="kd">var</span> <span class="nx">vstat</span> <span class="p">[</span><span class="mi">3</span><span class="p">]</span><span class="kt">int</span>
</span></span><span class="line"><span class="cl"><span class="c1">// 赋值
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="nx">vstat</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="p">=</span> <span class="mi">1</span>
</span></span><span class="line"><span class="cl"><span class="nx">vstat</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="p">=</span> <span class="mi">2</span>
</span></span><span class="line"><span class="cl"><span class="nx">vstat</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="p">=</span> <span class="mi">3</span>
</span></span><span class="line"><span class="cl"><span class="c1">// 创建底层数组指针
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="kd">var</span> <span class="nx">vauto</span> <span class="o">*</span><span class="p">[</span><span class="mi">3</span><span class="p">]</span><span class="kt">int</span> <span class="p">=</span> <span class="nb">new</span><span class="p">([</span><span class="mi">3</span><span class="p">]</span><span class="kt">int</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="c1">// 指针指向底层数组
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="o">*</span><span class="nx">vauto</span> <span class="p">=</span> <span class="nx">vstat</span>
</span></span><span class="line"><span class="cl"><span class="nx">slice</span> <span class="o">:=</span> <span class="nx">vauto</span><span class="p">[:]</span>
</span></span></code></pre></td></tr></table>
</div>
</div><ol>
<li>根据切片中的元素数量对底层数组的大小进行推断并创建一个数组；</li>
<li>将这些字面量元素存储到初始化的数组中；</li>
<li>创建一个同样指向 <code>[3]int</code> 类型的数组指针；</li>
<li>将静态存储区的数组 <code>vstat</code> 赋值给 <code>vauto</code> 指针所在的地址；</li>
<li>通过 <code>[:]</code> 操作获取一个底层使用 <code>vauto</code> 的切片；</li>
</ol>
<p>第 5 步中的 <code>[:]</code> 就是使用下标创建切片的方法，从这一点我们也能看出 <code>[:]</code> 操作是创建切片最底层的一种方法。</p>
<h5 id="关键字">关键字</h5>
<p>如果使用字面量的方式创建切片，大部分的工作都会在编译期间完成。但是当我们使用 make 关键字来创建切片时，很多工作都需要运行时的参与；调用方必须向 make 函数传入切片的大小以及可选的容量，类型检查阶段时会校验入参（判断len必须，且cap&gt;=len）并将 <code>OMAKE</code> 节点转换成 <code>OMAKESLICE</code>，然后在中间代码生成阶段会依据两个条件来转换 <code>OMAKESLICE</code> 类型的节点：</p>
<ol>
<li>切片的大小和容量是否足够小；</li>
<li>切片是否发生了内存逃逸；</li>
</ol>
<p>当切片发生内存逃逸或者非常大时，切片的初始化会延后至运行时的<a class="link" href="https://github.com/golang/go/blob/3b2a578166bdedd94110698c971ba8990771eb89/src/runtime/slice.go#L83"  target="_blank" rel="noopener"
    ><code>runtime.makeslice</code></a> 在堆上初始化切片（即汇编语言代码中不会有初始化切片的代码，而是一个调用 <code> runtime.makeslice</code> 的函数），如果切片不会发生内存逃逸且非常小的时候，它会在编译阶段直接转换初始化切片的代码。例如  <code>make([]int, 3, 4)</code> 会被直接转换成如下所示的代码：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="line"><span class="cl"><span class="kd">var</span> <span class="nx">arr</span> <span class="p">[</span><span class="mi">4</span><span class="p">]</span><span class="kt">int</span>
</span></span><span class="line"><span class="cl"><span class="nx">n</span> <span class="o">:=</span> <span class="nx">arr</span><span class="p">[:</span><span class="mi">3</span><span class="p">]</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>上述代码会初始化数组并通过下标 <code>[:3]</code> 得到数组对应的切片，这两部分操作都会在编译阶段完成（只是生成代码，内存分配肯定还是在程序运行时，但是不会再调用 <code>runtime.makeslice</code>初始化切片），而这种方式初始化的切片会放在栈上，其底层数组会根据数组的规则放在栈或者静态存储区中。</p>
<p>运行时函数 <code>runtime.makeslice</code>的实现很简单：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="line"><span class="cl"><span class="kd">func</span> <span class="nf">makeslice</span><span class="p">(</span><span class="nx">et</span> <span class="o">*</span><span class="nx">_type</span><span class="p">,</span> <span class="nx">len</span><span class="p">,</span> <span class="nx">cap</span> <span class="kt">int</span><span class="p">)</span> <span class="nx">unsafe</span><span class="p">.</span><span class="nx">Pointer</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">	<span class="nx">mem</span><span class="p">,</span> <span class="nx">overflow</span> <span class="o">:=</span> <span class="nx">math</span><span class="p">.</span><span class="nf">MulUintptr</span><span class="p">(</span><span class="nx">et</span><span class="p">.</span><span class="nx">size</span><span class="p">,</span> <span class="nb">uintptr</span><span class="p">(</span><span class="nx">cap</span><span class="p">))</span>
</span></span><span class="line"><span class="cl">	<span class="k">if</span> <span class="nx">overflow</span> <span class="o">||</span> <span class="nx">mem</span> <span class="p">&gt;</span> <span class="nx">maxAlloc</span> <span class="o">||</span> <span class="nx">len</span> <span class="p">&lt;</span> <span class="mi">0</span> <span class="o">||</span> <span class="nx">len</span> <span class="p">&gt;</span> <span class="nx">cap</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">		<span class="nx">mem</span><span class="p">,</span> <span class="nx">overflow</span> <span class="o">:=</span> <span class="nx">math</span><span class="p">.</span><span class="nf">MulUintptr</span><span class="p">(</span><span class="nx">et</span><span class="p">.</span><span class="nx">size</span><span class="p">,</span> <span class="nb">uintptr</span><span class="p">(</span><span class="nx">len</span><span class="p">))</span>
</span></span><span class="line"><span class="cl">		<span class="k">if</span> <span class="nx">overflow</span> <span class="o">||</span> <span class="nx">mem</span> <span class="p">&gt;</span> <span class="nx">maxAlloc</span> <span class="o">||</span> <span class="nx">len</span> <span class="p">&lt;</span> <span class="mi">0</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">			<span class="nf">panicmakeslicelen</span><span class="p">()</span>
</span></span><span class="line"><span class="cl">		<span class="p">}</span>
</span></span><span class="line"><span class="cl">		<span class="nf">panicmakeslicecap</span><span class="p">()</span>
</span></span><span class="line"><span class="cl">	<span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">	<span class="k">return</span> <span class="nf">mallocgc</span><span class="p">(</span><span class="nx">mem</span><span class="p">,</span> <span class="nx">et</span><span class="p">,</span> <span class="kc">true</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>上述函数的主要工作是计算切片需要占用的内存空间并在堆上申请一片连续的内存供切片使用。它的计算方式是：</p>
<p><em><strong>内存空间 = 切片中单个元素大小 * 切片容量</strong></em></p>
<p>当然实际情况中还需要考虑内存对齐、垃圾回收的情况，最终切片申请的内存不一样是公式计算出来的内存，但是肯定会大于等于公式值。</p>
<p>编译期间可以检查出很多错误，不过有些问题在编译器是检查不出来的。在运行时创建切片的过程中如果发生了以下错误会直接触发运行时错误并崩溃：</p>
<ol>
<li>内存空间的大小发生了溢出；</li>
<li>申请的内存大于最大可分配的内存；</li>
<li>传入的长度小于 0 或者长度大于容量（传入的len是变量时，编译阶段无法判断是否小于cap）；</li>
</ol>
<p><a class="link" href="https://draveness.me/golang/tree/runtime.makeslice"  target="_blank" rel="noopener"
    ><code>runtime.makeslice</code></a> 在最后调用的 <a class="link" href="https://draveness.me/golang/tree/runtime.mallocgc"  target="_blank" rel="noopener"
    ><code>runtime.mallocgc</code></a> 是用于申请内存的函数，这个函数的实现比较复杂，如果遇到了比较小的对象会直接初始化在 Go 语言调度器里面的 P 结构中（不只是针对于切片），而大于 32KB 的对象会在堆上初始化。在Go语言的调度器中，对于较小的对象，为了减少内存分配的开销，会将这些对象直接初始化在P的本地内存池中，而不是在堆上分配。这个过程称为&quot;P本地对象缓存&quot;，而对于大于32KB的对象，它们往往会直接在堆上进行初始化，因为对于较大的对象，为它们分配独立的堆内存比较合理，这可以更好地管理内存碎片和利用堆的垃圾回收机制。</p>
<p>总结一下切片的分配逻辑：</p>
<p><strong>如果切片容量非常小且没有发生内存逃逸时，它会存储在栈中，其底层数组会根据数组的规则放在栈或者静态存储区中；如果切片容量大或者发生了内存逃逸，此时会判断其申请的内存是否大于32KB，大于则会分配在堆上，小于则会分配到P的本地内存池中。当然这只是简单的理解，实际上还需要考虑到内存管理机制等情况。</strong></p>
<p>使用下标方式创建切片，其底层数组由开发者自己创建；而字面量和关键字的方式创建底层数组都是由编译期或运行时声明创建。</p>
<h4 id="访问元素">访问元素</h4>
<p>使用 <code>len</code> 和 <code>cap</code> 获取长度或者容量是切片最常见的操作，编译器会将它们看成两种特殊操作，即 <code>OLEN</code> 和 <code>OCAP</code>，<a class="link" href="https://github.com/golang/go/blob/41d8e61a6b9d8f9db912626eb2bbc535e929fefc/src/cmd/compile/internal/gc/ssa.go#L2054"  target="_blank" rel="noopener"
    ><code>gc.state.expr</code></a> 函数会在 <code>SSA中间代码生成阶段</code> 将它们分别转换成 <code>OpSliceLen </code>和 <code>OpSliceCap</code></p>
<p>访问切片结构中的字段可能会触发 “decompose builtin” 阶段的优化，<code>len(slice)</code> 或者 <code>cap(slice)</code> 在某些情况下会直接替换成切片的长度或者容量 （<code>v13 (?) = Const64 &lt;int&gt;`` [5]</code>），不需要在运行时获取。</p>
<p>除了获取切片的长度和容量之外，访问切片中元素使用的 <code>OINDEX</code> 操作也会在中间代码生成期间转换成对地址的直接访问。除此之外，编译期间也会将包含 <code>range</code> 关键字的遍历转换成形式更简单的循环</p>
<p><strong>测试发现直接替换成切片长度或容量以及访问元素只会出现在切片定义在函数内部且它没有发生内存逃逸的情况，如果发生了内存逃逸或者直接定义在外部，编译期是无法判断它的长度容量以及是否会扩容导致切片移动到其他内存区的（其他函数也可以使用或扩容它）</strong></p>
<h4 id="追加和扩容">追加和扩容</h4>
<p>使用 <code>append</code> 关键字向切片中追加元素也是常见的切片操作，中间代码生成阶段的<a class="link" href="https://github.com/golang/go/blob/ac0ba6707c1655ea4316b41d06571a0303cc60eb/src/cmd/compile/internal/gc/ssa.go#L2841"  target="_blank" rel="noopener"
    ><code>gc.state.append</code></a> 方法会根据返回值是否会覆盖原变量来选择进入两种流程</p>
<p>如果 <code>append</code> 返回的新切片不需要赋值回原有的变量（即没有变量接收append后新切片的指针），就会进入如下的处理流程：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="line"><span class="cl"><span class="c1">// append(slice, 1, 2, 3)
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="nx">ptr</span><span class="p">,</span> <span class="nx">len</span><span class="p">,</span> <span class="nx">cap</span> <span class="o">:=</span> <span class="nx">slice</span>
</span></span><span class="line"><span class="cl"><span class="nx">newlen</span> <span class="o">:=</span> <span class="nx">len</span> <span class="o">+</span> <span class="mi">3</span>
</span></span><span class="line"><span class="cl"><span class="k">if</span> <span class="nx">newlen</span> <span class="p">&gt;</span> <span class="nx">cap</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="nx">ptr</span><span class="p">,</span> <span class="nx">len</span><span class="p">,</span> <span class="nx">cap</span> <span class="p">=</span> <span class="nf">growslice</span><span class="p">(</span><span class="nx">slice</span><span class="p">,</span> <span class="nx">newlen</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">    <span class="nx">newlen</span> <span class="p">=</span> <span class="nx">len</span> <span class="o">+</span> <span class="mi">3</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="o">*</span><span class="p">(</span><span class="nx">ptr</span><span class="o">+</span><span class="nx">len</span><span class="p">)</span> <span class="p">=</span> <span class="mi">1</span>
</span></span><span class="line"><span class="cl"><span class="o">*</span><span class="p">(</span><span class="nx">ptr</span><span class="o">+</span><span class="nx">len</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span> <span class="p">=</span> <span class="mi">2</span>
</span></span><span class="line"><span class="cl"><span class="o">*</span><span class="p">(</span><span class="nx">ptr</span><span class="o">+</span><span class="nx">len</span><span class="o">+</span><span class="mi">2</span><span class="p">)</span> <span class="p">=</span> <span class="mi">3</span>
</span></span><span class="line"><span class="cl"><span class="k">return</span> <span class="nf">makeslice</span><span class="p">(</span><span class="nx">ptr</span><span class="p">,</span> <span class="nx">newlen</span><span class="p">,</span> <span class="nx">cap</span><span class="p">)</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>首先会解构切片结构体获取它的数组指针、大小和容量，如果在追加元素后切片的大小大于容量，那么就会调用 <code>runtime.growslice </code> 对切片进行扩容并将旧的元素依次加入切片。</p>
<p>如果使用 <code>slice = append(slice, 1, 2, 3)</code> 语句，那么 <code>append</code> 后的新切片会覆盖原切片变量，这时 <code>gc.state.append</code> 方法会使用另一种方式展开关键字：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="line"><span class="cl"><span class="c1">// slice = append(slice, 1, 2, 3)
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="nx">a</span> <span class="o">:=</span> <span class="o">&amp;</span><span class="nx">slice</span>
</span></span><span class="line"><span class="cl"><span class="nx">ptr</span><span class="p">,</span> <span class="nx">len</span><span class="p">,</span> <span class="nx">cap</span> <span class="o">:=</span> <span class="nx">slice</span>
</span></span><span class="line"><span class="cl"><span class="nx">newlen</span> <span class="o">:=</span> <span class="nx">len</span> <span class="o">+</span> <span class="mi">3</span>
</span></span><span class="line"><span class="cl"><span class="k">if</span> <span class="nb">uint</span><span class="p">(</span><span class="nx">newlen</span><span class="p">)</span> <span class="p">&gt;</span> <span class="nb">uint</span><span class="p">(</span><span class="nx">cap</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">   <span class="nx">newptr</span><span class="p">,</span> <span class="nx">len</span><span class="p">,</span> <span class="nx">newcap</span> <span class="p">=</span> <span class="nf">growslice</span><span class="p">(</span><span class="nx">slice</span><span class="p">,</span> <span class="nx">newlen</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">   <span class="nf">vardef</span><span class="p">(</span><span class="nx">a</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">   <span class="o">*</span><span class="nx">a</span><span class="p">.</span><span class="nx">cap</span> <span class="p">=</span> <span class="nx">newcap</span>
</span></span><span class="line"><span class="cl">   <span class="o">*</span><span class="nx">a</span><span class="p">.</span><span class="nx">ptr</span> <span class="p">=</span> <span class="nx">newptr</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="nx">newlen</span> <span class="p">=</span> <span class="nx">len</span> <span class="o">+</span> <span class="mi">3</span>
</span></span><span class="line"><span class="cl"><span class="o">*</span><span class="nx">a</span><span class="p">.</span><span class="nx">len</span> <span class="p">=</span> <span class="nx">newlen</span>
</span></span><span class="line"><span class="cl"><span class="o">*</span><span class="p">(</span><span class="nx">ptr</span><span class="o">+</span><span class="nx">len</span><span class="p">)</span> <span class="p">=</span> <span class="mi">1</span>
</span></span><span class="line"><span class="cl"><span class="o">*</span><span class="p">(</span><span class="nx">ptr</span><span class="o">+</span><span class="nx">len</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span> <span class="p">=</span> <span class="mi">2</span>
</span></span><span class="line"><span class="cl"><span class="o">*</span><span class="p">(</span><span class="nx">ptr</span><span class="o">+</span><span class="nx">len</span><span class="o">+</span><span class="mi">2</span><span class="p">)</span> <span class="p">=</span> <span class="mi">3</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>它与前面逻辑最大的区别在于得到的新切片是否会赋值给原变量，首先会定义一个 a 临时变量，它指向的就是原切片，然后获取原切片的数组指针、大小和容量，如果扩容后的大小大于原cap就会发生扩容并更新原切片的cap和指针为新切片，无论是否发生扩容都会更新len和元素数据。</p>
<p>如果选择覆盖原有变量就不需要担心切片发生拷贝影响性能，编译期对这种常见情况进行了优化。</p>
<p>当切片的容量不足时，我们会调用 <code>runtime.growslice</code> 函数为切片扩容，扩容是为切片分配新的内存空间并拷贝原切片中元素的过程，在分配内存空间之前需要先缺点新的切片容量，运行时根据切片的当前容量选择不同的策略进行扩容 (go 1.18版本及以后更新的扩容机制)：</p>
<ol>
<li>如果当前容量扩大两倍后依然小于期望容量就会直接使用期望容量；</li>
<li>如果当前切片的长度小于 256 就会将容量翻倍；</li>
<li>如果当前切片的长度大于 256 就会每次以 <code>newcap += (newcap + 3*256) / 4</code> 的方式缓慢增长，直到新容量大于期望容量；之前版本中超过了阈值之后，基本为恒定的1.25倍增长，而现在超过了阈值之后，增长比例是会动态调整的，增长比例会从2倍逐渐向1.25倍靠拢。</li>
</ol>
<p>但是这仅仅会确定切片的大致容量，下面还需要根据切片中的元素大小进行内存对齐，<a class="link" href="https://github.com/golang/go/blob/ac0ba6707c1655ea4316b41d06571a0303cc60eb/src/runtime/msize.go#L13"  target="_blank" rel="noopener"
    ><code>runtime.roundupsize</code></a> 函数会将<strong>待申请的内存向上取整</strong>，取整时会使用 <a class="link" href="https://github.com/golang/go/blob/b634f5d97a6e65f19057c00ed2095a1a872c7fa8/src/runtime/sizeclasses.go#L84"  target="_blank" rel="noopener"
    ><code>runtime.class_to_size</code></a> 数组()，使用该数组中的整数可以提高内存的分配效率并减少内存碎片。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">var class_to_size = [_NumSizeClasses]uint16{0, 8, 16, 24, 32, 48, 64, ...}
</span></span></code></pre></td></tr></table>
</div>
</div><p>我们申请内存时，内存管理模块会根据这个数组帮我们匹配到足够大且最接近的规格，比如切片要申请40字节，但是没有这个规模的，就会申请到48字节。</p>
<p>如果计算新容量时发生了内存溢出或者请求的内存超过了上限就会发生panic 退出程序。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="line"><span class="cl"><span class="kd">var</span> <span class="nx">arr</span> <span class="p">[]</span><span class="kt">int64</span>
</span></span><span class="line"><span class="cl"><span class="nx">arr</span> <span class="p">=</span> <span class="nb">append</span><span class="p">(</span><span class="nx">arr</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">5</span><span class="p">)</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>当我们执行上述代码时，会触发 <code>runtime.growslice</code> 函数扩容 <code>arr</code> 切片并传入期望的新容量 5，int64占8字节，所以这时期望分配的内存大小为 40 字节；由于没有这个字节规模，考虑到内存对齐，运行时会调用 <a class="link" href="https://github.com/golang/go/blob/ac0ba6707c1655ea4316b41d06571a0303cc60eb/src/runtime/msize.go#L13"  target="_blank" rel="noopener"
    ><code>runtime.roundupsize</code></a>向上取整内存的大小到 48 字节，所以新切片的容量为 48 / 8 = 6。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="line"><span class="cl">    <span class="c1">// a 底层是一个slice结构体，此时len=4 cap=8，len和cap只会在make和append时发生修改
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="nx">a</span> <span class="o">:=</span> <span class="nb">make</span><span class="p">([]</span><span class="kt">int</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">8</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">    <span class="c1">// b 是另一个slice结构体，此时len=7 cap=8，由于没有超过cap，不会扩容，ab指向的依然是相同的底层数组
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="nx">b</span> <span class="o">:=</span> <span class="nb">append</span><span class="p">(</span><span class="nx">a</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">3</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">    <span class="c1">// a根据a扩容，由于a记录的len为4，因此会从第5个数扩容，那么3就会变成4，而不是从第8位开始
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1">// 源码append函数是根据SliceHeader结构的len来进行扩容赋值的
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1">//  newlen = len + 3
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1">// *a.len = newlen
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1">// *(ptr+len) = 1
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1">// *(ptr+len+1) = 2
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1">// *(ptr+len+2) = 3
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="nx">a</span> <span class="p">=</span> <span class="nb">append</span><span class="p">(</span><span class="nx">a</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">4</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">    <span class="nb">println</span><span class="p">(</span><span class="nx">b</span><span class="p">)</span>
</span></span></code></pre></td></tr></table>
</div>
</div><h4 id="拷贝切片">拷贝切片</h4>
<p>当我们使用 <code>copy(a, b)</code> 的形式对切片进行拷贝时，编译期间的 <a class="link" href="https://github.com/golang/go/blob/ac0ba6707c1655ea4316b41d06571a0303cc60eb/src/cmd/compile/internal/gc/walk.go#L3093"  target="_blank" rel="noopener"
    ><code>cmd/compile/internal/gc.copyany</code></a> 也会分两种情况处理拷贝操作，如果当前 <code>copy</code> 不是在运行时调用的，<code>copy(a, b)</code> 会被直接转换成下面的代码 (常用的拷贝情况)：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="line"><span class="cl"><span class="nx">n</span> <span class="o">:=</span> <span class="nb">len</span><span class="p">(</span><span class="nx">a</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="k">if</span> <span class="nx">n</span> <span class="p">&gt;</span> <span class="nb">len</span><span class="p">(</span><span class="nx">b</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="nx">n</span> <span class="p">=</span> <span class="nb">len</span><span class="p">(</span><span class="nx">b</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="k">if</span> <span class="nx">a</span><span class="p">.</span><span class="nx">ptr</span> <span class="o">!=</span> <span class="nx">b</span><span class="p">.</span><span class="nx">ptr</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="nf">memmove</span><span class="p">(</span><span class="nx">a</span><span class="p">.</span><span class="nx">ptr</span><span class="p">,</span> <span class="nx">b</span><span class="p">.</span><span class="nx">ptr</span><span class="p">,</span> <span class="nx">n</span><span class="o">*</span><span class="nf">sizeof</span><span class="p">(</span><span class="nf">elem</span><span class="p">(</span><span class="nx">a</span><span class="p">)))</span> 
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>上述代码中的 <code>runtime.memmove</code> 会负责拷贝内存。而如果拷贝是在运行时发生的，例如：<code>go copy(a, b)</code> (根据go关键字的特性可以知道，copy函数会先获取ab的值，执行到时才会调用具体函数)，编译器会使用 <code>runtime.slicecopy </code>替换运行期间调用的 <code>copy</code>。</p>
<p>无论是在编译期间拷贝还是运行时拷贝，两种拷贝方式都会通过 <code>runtime.memmove</code> 函数将整块内存的内容拷贝到目标的内存区域中。相比于依次拷贝元素，<code>runtime.memmove</code> 能够提供更好的性能。不过需要注意的是，整块拷贝内存仍然会占用非常多的资源，对大切片进行拷贝操作时一定要注意对性能的影响。</p>
<p>扩容切片时如果容量不够也会使用 <code>runtime.memmove</code> 将原切片拷贝至扩容后的新切片，然后再依次加入要新增的元素。</p>
<p>切片的很多功能都是在运行时执行的，无论是初始化切片，还是对切片进行追加和扩容都是需要运行时的支持的，因此在遇见大切片扩容或者拷贝时就可能会发生大规模的内存拷贝，一定要减少类似操作（如提前设置容量避免扩容时容量不够发生切片拷贝），避免影响程序性能。</p>
<h3 id="哈希表">哈希表</h3>
<p>哈希是除了数组之外最常见的数据结构，它表示的是键值对之间的映射关系。它是计算机科学中最重要的数据结构之一，这不仅因为它 O(1) 的读写性能非常优秀，还因为它提供了键值之间的映射。想要实现一个性能优异的哈希表，需要注意两个关键点 —— 哈希函数和冲突解决方法。</p>
<h4 id="设计原理">设计原理</h4>
<h5 id="哈希函数">哈希函数</h5>
<p>实现哈希表的关键点在于哈希函数的选择，哈希函数的选择在很大程度上能够决定哈希表的读写性能。在理想情况下，哈希函数应该能够将不同键映射到不同的索引上，这要求 <strong>哈希函数的输出范围（取)大于输入范围（存)</strong> ，但是由于键的数量会远远大于能映射的范围，所以在实际使用时，这个理想的效果是不可能实现的。</p>
<p>比较实际的方式是让哈希函数的结果能够尽可能的均匀分布，然后通过工程上的手段解决哈希碰撞的问题。哈希函数映射的结果一定要尽可能均匀，结果不均匀的哈希函数会带来更多的哈希冲突以及更差的读写性能。</p>
<p>如果使用结果分布较为均匀的哈希函数，那么哈希的增删改查的时间复杂度为 <strong>O</strong>(<strong>1</strong>)；但是如果哈希函数的结果分布不均匀，那么所有操作的时间复杂度可能会达到 <strong>O</strong>(<strong>n</strong>) （查询任何一个值都会遍历一遍map)，由此看来，使用好的哈希函数是至关重要的。</p>
<h5 id="解决冲突">解决冲突</h5>
<p>在通常情况下，哈希函数输入的范围一定会远远大于输出的范围，所以在使用哈希表时一定会遇到冲突，哪怕我们使用了完美的哈希函数，当输入的键足够多也会产生冲突。然而多数的哈希函数都是不够完美的，所以仍然存在发生哈希碰撞的可能，这时就需要一些方法来解决哈希碰撞的问题，常见方法的就是开放寻址法和拉链法。</p>
<blockquote>
<p>需要注意的是，这里提到的哈希碰撞不一定是多个键对应的哈希完全相等，可能是多个哈希的部分相等，例如：两个键对应哈希的前四个字节相同。</p>
</blockquote>
<h6 id="开放寻址法">开放寻址法</h6>
<p>这种方法的核心思想是 <strong>依次 探测和比较 底层数组中的元素 来判断目标键值对是否存在于哈希表中</strong> ，如果我们使用开放寻址法来实现哈希表，那么实现哈希表底层的数据结构就是数组，不过因为数组的长度有限，向哈希表写入 [ author, draven] 这个键值对时会从如下的索引开始遍历：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="line"><span class="cl"><span class="nx">index</span> <span class="o">:=</span> <span class="nf">hash</span><span class="p">(</span><span class="s">&#34;author&#34;</span><span class="p">)</span> <span class="o">%</span> <span class="nx">array</span><span class="p">.</span><span class="nx">len</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>当我们向当前哈希表写入新的数据时，如果发生了冲突，就会将键值对写入到下一个内存为空的位置。如果向下遍历时发现这个key存在就会修改其值。当我们读取数据时，就会先获取键的哈希并取模，如果获取到的索引对应的key与比对的key不相等，就会继续查找后面的元素，直到找到目标元素或者内存为空。</p>
<p>开放寻址法中对性能影响最大的是 负<strong>载因子</strong> ，它是数组中元素的数量与数组大小的比值。随着负载因子的增加，线性探测的平均用时就会逐渐增加（碰撞几率增加导致每次查询需要向后移动查询的次数增加)，这会影响哈希表的读写性能。当负载率超过 70% 之后，哈希表的性能就会急剧下降，而一旦负载率达到 100%，整个哈希表就会完全失效，这时查找和插入任意元素的时间复杂度都是 <strong>O</strong>(<strong>n</strong>) ，这时需要遍历数组中的全部元素，所以在实现哈希表时一定要关注负载因子的变化。</p>
<h6 id="拉链法">拉链法</h6>
<p>与开放寻址法相比，拉链法才是哈希表最常见的实现方法，大多数编程语言都是用拉链法来实现哈希表，它的实现比较开放寻址法稍微复杂一些，但是平均查找的长度也比较短，各个用于存储节点的内存都是动态申请的，可以节省比较多的存储空间（拉链的形式，发生冲突时才会申请内存存储冲突kv)。</p>
<p>实现拉链法一般会使用数组加上链表，不过一些编程语言会在拉链法的哈希中引入红黑树以优化性能，拉链法会使用链表数组作为哈希底层的数据结构，我们可以将它看成可以扩展的二维数组：
<img src="/p/go-%E8%AF%AD%E8%A8%80%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0%E8%AF%BB%E5%90%8E%E7%90%86%E8%A7%A3/media/image-2.png"
	width="1200"
	height="630"
	srcset="/p/go-%E8%AF%AD%E8%A8%80%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0%E8%AF%BB%E5%90%8E%E7%90%86%E8%A7%A3/media/image-2_hu317b262f90599d075b7c6aae3bb455b6_34692_480x0_resize_box_3.png 480w, /p/go-%E8%AF%AD%E8%A8%80%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0%E8%AF%BB%E5%90%8E%E7%90%86%E8%A7%A3/media/image-2_hu317b262f90599d075b7c6aae3bb455b6_34692_1024x0_resize_box_3.png 1024w"
	loading="lazy"
	
		alt="image2.png"
	
	
		class="gallery-image" 
		data-flex-grow="190"
		data-flex-basis="457px"
	
></p>
<p>如上图所示，当我们需要将一个键值对 (Key6, Value6) 写入哈希表时，键值对中的键 Key6 都会先经过一个哈希函数，哈希函数返回的哈希会帮助我们选择一个桶，和开放寻址法一样，选择桶的方式是直接对哈希返回的结果取模：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="line"><span class="cl"><span class="nx">index</span> <span class="o">:=</span> <span class="nf">hash</span><span class="p">(</span><span class="s">&#34;Key6&#34;</span><span class="p">)</span> <span class="o">%</span> <span class="nx">array</span><span class="p">.</span><span class="nx">len</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>选择了 2 号桶后就可以遍历当前桶中的链表了，在遍历链表的过程中会遇到以下两种情况：</p>
<ol>
<li>找到键相同的键值对 — 更新键对应的值；</li>
<li>没有找到键相同的键值对 — 在链表的末尾追加新的键值对；</li>
</ol>
<p>如果要在哈希表中获取某个键对应的值，首先取模命中相应的桶，然后依次遍历桶中的链表，遍历到相同key则返回值，如果遍历到链表的末尾也没有找到期望的键，就表示哈希表中没有该键对应的值。</p>
<p>在一个性能比较好的哈希表中，每一个桶中都应该有 0 ～ 1 个元素，有时会有 2 ~ 3 个，很少会超过这个数量。计算哈希、定位桶和遍历链表三个过程是哈希表读写操作的主要开销，使用拉链法实现的哈希也有装载因子这一概念：</p>
<blockquote>
<p>装载因子 <strong>:=元素数量</strong> ÷桶数量</p>
</blockquote>
<p>与开放地址法一样，拉链法的装载因子越大，哈希的读写性能就越差。在一般情况下使用拉链法的哈希表装载因子都不会超过 1，当哈希表的装载因子较大时会触发哈希的扩容，创建更多的桶来存储哈希中的元素，保证性能不会出现严重的下降。如果有 1000 个桶的哈希表存储了 10000 个键值对，它的性能是保存 1000 个键值对的 1/10，但是仍然比在链表中直接读写好 1000 倍 (从1000个桶里面读取10000个数据，最差读取一个数据需要链表查10次，而直接从链表中读取数据，最差需要链表查10000次，每个数据都要查询，因此比链表直接读写好1000 倍)。</p>
<h4 id="数据结构-2">数据结构</h4>
<p>Go语言运行时同时使用了</p>
<p>Go 语言运行时同时使用了多个数据结构组合来表示哈希表，其中 <a class="link" href="https://github.com/golang/go/blob/41d8e61a6b9d8f9db912626eb2bbc535e929fefc/src/runtime/map.go#L115"  target="_blank" rel="noopener"
    ><code>runtime.hmap</code></a> 是最核心的结构体：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="line"><span class="cl"><span class="kd">type</span> <span class="nx">hmap</span> <span class="kd">struct</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">	<span class="nx">count</span>     <span class="kt">int</span>
</span></span><span class="line"><span class="cl">	<span class="nx">flags</span>     <span class="kt">uint8</span>
</span></span><span class="line"><span class="cl">	<span class="nx">B</span>         <span class="kt">uint8</span>
</span></span><span class="line"><span class="cl">	<span class="nx">noverflow</span> <span class="kt">uint16</span>
</span></span><span class="line"><span class="cl">	<span class="nx">hash0</span>     <span class="kt">uint32</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">	<span class="nx">buckets</span>    <span class="nx">unsafe</span><span class="p">.</span><span class="nx">Pointer</span>
</span></span><span class="line"><span class="cl">	<span class="nx">oldbuckets</span> <span class="nx">unsafe</span><span class="p">.</span><span class="nx">Pointer</span>
</span></span><span class="line"><span class="cl">	<span class="nx">nevacuate</span>  <span class="kt">uintptr</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">	<span class="nx">extra</span> <span class="o">*</span><span class="nx">mapextra</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kd">type</span> <span class="nx">mapextra</span> <span class="kd">struct</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">	<span class="nx">overflow</span>    <span class="o">*</span><span class="p">[]</span><span class="o">*</span><span class="nx">bmap</span>
</span></span><span class="line"><span class="cl">	<span class="nx">oldoverflow</span> <span class="o">*</span><span class="p">[]</span><span class="o">*</span><span class="nx">bmap</span>
</span></span><span class="line"><span class="cl">	<span class="nx">nextOverflow</span> <span class="o">*</span><span class="nx">bmap</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div><ol>
<li><code>count</code> 表示当前哈希表中的元素数量；</li>
<li><code>B</code> 表示当前哈希表持有的 <code>buckets</code> 数量，但是因为哈希表中桶的数量都 2 的倍数，所以该字段会存储对数，也就是 <code>len(buckets) == 2^B</code>；</li>
<li><code>hash0</code> 是哈希的种子，它能为哈希函数的结果引入随机性，这个值在创建哈希表时确定，并在调用哈希函数时作为参数传入；</li>
<li><code>oldbuckets</code> 是哈希在扩容时用于保存之前 <code>buckets</code> 的字段；</li>
<li><code>noverflow</code> 为map中溢出桶的数量。当溢出桶太多时，map 会进行 same-size map growth，其实质是避免桶过大导致内存泄露。<code>extra</code> 存储map中的溢出桶；</li>
</ol>
<p>哈希表 <code>runtime.hmap</code> 的桶是 <code>runtime.bmap</code>。每一个 <code>runtime.bmap</code> 都能存储8个键值对，当哈希表中存储的数据过多时，单个桶已经装满就会使用 <code>extra.nextOverflow</code> 中的桶来存储溢出的数据。</p>
<p>上面两种不同的桶在内存中是连续存储的（即底层是一个数组，正常桶集和排列，然后溢出桶集和排列），它们分别被称为正常桶和溢出桶，溢出桶是在Go语言还使用C语言实现时使用的设计，由于它能够减少扩容的频率所以一直使用至今。</p>
<p><code>runtime.bmap</code> 在go源代码中的定义只包含一个简单的 <code>tophash</code> 字段，它存储了键的哈希的高8位，通过比较不同键的哈希的高8位可以减少访问键值对次数以提高性能（从判断键整体的不同变为了先判断高8位，符合再继续判断）。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="line"><span class="cl"><span class="kd">type</span> <span class="nx">bmap</span> <span class="kd">struct</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">	<span class="nx">tophash</span> <span class="p">[</span><span class="nx">bucketCnt</span><span class="p">]</span><span class="kt">uint8</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>随着哈希表存储的数据逐渐增多，我们会扩容哈希表或者使用溢出桶来存储溢出的数据，不会让单个桶中的数据超过8个，不过溢出桶只是临时的解决方案，创建过多的溢出桶最终也会导致哈希的扩容（溢出桶以链表的形式存在，不扩容的话，查询的速率就会变的非常慢）。</p>
<h4 id="初始化-2">初始化</h4>
<h5 id="字面量-1">字面量</h5>
<p>现代的编程语言基本都支持使用字面量的方式来初始化哈希，一般都会使用 <code>key: value</code> 的语法来表示键值对，Go 语言中也不例外：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="line"><span class="cl"><span class="nx">hash</span> <span class="o">:=</span> <span class="kd">map</span><span class="p">[</span><span class="kt">string</span><span class="p">]</span><span class="kt">int</span><span class="p">{</span>
</span></span><span class="line"><span class="cl">	<span class="s">&#34;1&#34;</span><span class="p">:</span> <span class="mi">2</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">	<span class="s">&#34;3&#34;</span><span class="p">:</span> <span class="mi">4</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">	<span class="s">&#34;5&#34;</span><span class="p">:</span> <span class="mi">6</span><span class="p">,</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>我们需要在初始化哈希时声明键值对的类型，这种使用字面量初始化的方式最终都会通过 <a class="link" href="https://github.com/golang/go/blob/ac0ba6707c1655ea4316b41d06571a0303cc60eb/src/cmd/compile/internal/gc/sinit.go#L753"  target="_blank" rel="noopener"
    ><code>cmd/compile/internal/gc.maplit</code></a> 初始化，我们来分析一下该函数初始化哈希的过程：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="line"><span class="cl"><span class="kd">func</span> <span class="nf">maplit</span><span class="p">(</span><span class="nx">n</span> <span class="o">*</span><span class="nx">Node</span><span class="p">,</span> <span class="nx">m</span> <span class="o">*</span><span class="nx">Node</span><span class="p">,</span> <span class="nx">init</span> <span class="o">*</span><span class="nx">Nodes</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">	<span class="nx">a</span> <span class="o">:=</span> <span class="nf">nod</span><span class="p">(</span><span class="nx">OMAKE</span><span class="p">,</span> <span class="kc">nil</span><span class="p">,</span> <span class="kc">nil</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">	<span class="nx">a</span><span class="p">.</span><span class="nx">Esc</span> <span class="p">=</span> <span class="nx">n</span><span class="p">.</span><span class="nx">Esc</span>
</span></span><span class="line"><span class="cl">	<span class="nx">a</span><span class="p">.</span><span class="nx">List</span><span class="p">.</span><span class="nf">Set2</span><span class="p">(</span><span class="nf">typenod</span><span class="p">(</span><span class="nx">n</span><span class="p">.</span><span class="nx">Type</span><span class="p">),</span> <span class="nf">nodintconst</span><span class="p">(</span><span class="nb">int64</span><span class="p">(</span><span class="nx">n</span><span class="p">.</span><span class="nx">List</span><span class="p">.</span><span class="nf">Len</span><span class="p">())))</span>
</span></span><span class="line"><span class="cl">	<span class="nf">litas</span><span class="p">(</span><span class="nx">m</span><span class="p">,</span> <span class="nx">a</span><span class="p">,</span> <span class="nx">init</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">	<span class="nx">entries</span> <span class="o">:=</span> <span class="nx">n</span><span class="p">.</span><span class="nx">List</span><span class="p">.</span><span class="nf">Slice</span><span class="p">()</span>
</span></span><span class="line"><span class="cl">	<span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="nx">entries</span><span class="p">)</span> <span class="p">&gt;</span> <span class="mi">25</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">		<span class="o">...</span>
</span></span><span class="line"><span class="cl">		<span class="k">return</span>
</span></span><span class="line"><span class="cl">	<span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">	<span class="c1">// Build list of var[c] = expr.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="c1">// Use temporaries so that mapassign1 can have addressable key, elem.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="o">...</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>当哈希表中的元素数量少于或者等于25个时，编译器会将字面量初始化的结构体转换成以下的代码，将所有的键值对一次性加入到哈希表中：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="line"><span class="cl"><span class="nx">hash</span> <span class="o">:=</span> <span class="nb">make</span><span class="p">(</span><span class="kd">map</span><span class="p">[</span><span class="kt">string</span><span class="p">]</span><span class="kt">int</span><span class="p">,</span> <span class="mi">3</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="nx">hash</span><span class="p">[</span><span class="s">&#34;1&#34;</span><span class="p">]</span> <span class="p">=</span> <span class="mi">2</span>
</span></span><span class="line"><span class="cl"><span class="nx">hash</span><span class="p">[</span><span class="s">&#34;3&#34;</span><span class="p">]</span> <span class="p">=</span> <span class="mi">4</span>
</span></span><span class="line"><span class="cl"><span class="nx">hash</span><span class="p">[</span><span class="s">&#34;5&#34;</span><span class="p">]</span> <span class="p">=</span> <span class="mi">6</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>这种初始化字面量的方式与数组和切片几乎完全相同，由此看来集和类型的初始化在Go 语言中有着相同的处理逻辑。</p>
<p>但是一旦哈希表中的元素数量超过25个，编译器会创建两个数组分别存储键和值，这些键值对会通过如下所示的for循环加入哈希：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="line"><span class="cl"><span class="nx">hash</span> <span class="o">:=</span> <span class="nb">make</span><span class="p">(</span><span class="kd">map</span><span class="p">[</span><span class="kt">string</span><span class="p">]</span><span class="kt">int</span><span class="p">,</span> <span class="mi">26</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="nx">vstatk</span> <span class="o">:=</span> <span class="p">[]</span><span class="kt">string</span><span class="p">{</span><span class="s">&#34;1&#34;</span><span class="p">,</span> <span class="s">&#34;2&#34;</span><span class="p">,</span> <span class="s">&#34;3&#34;</span><span class="p">,</span> <span class="o">...</span> <span class="err">，</span> <span class="s">&#34;26&#34;</span><span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="nx">vstatv</span> <span class="o">:=</span> <span class="p">[]</span><span class="kt">int</span><span class="p">{</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="o">...</span> <span class="p">,</span> <span class="mi">26</span><span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="k">for</span> <span class="nx">i</span> <span class="o">:=</span> <span class="mi">0</span><span class="p">;</span> <span class="nx">i</span> <span class="p">&lt;</span> <span class="nb">len</span><span class="p">(</span><span class="nx">vstak</span><span class="p">);</span> <span class="nx">i</span><span class="o">++</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="nx">hash</span><span class="p">[</span><span class="nx">vstatk</span><span class="p">[</span><span class="nx">i</span><span class="p">]]</span> <span class="p">=</span> <span class="nx">vstatv</span><span class="p">[</span><span class="nx">i</span><span class="p">]</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>这里的 <code>vstatk</code> 和 <code>vstatv</code> 还会根据切片字面量的初始化被编辑器继续展开。无论哈希使用哪种方法，使用字面量初始化的过程都会使用Go 语言中的关键字 <code>make</code> 来创建新的哈希并通过最原始的 <code>[ ]</code> 语法向哈希表中追加元素。</p>

</section>


    <footer class="article-footer">
    

    
    <section class="article-copyright">
        <svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-copyright" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round">
  <path stroke="none" d="M0 0h24v24H0z"/>
  <circle cx="12" cy="12" r="9" />
  <path d="M14.5 9a3.5 4 0 1 0 0 6" />
</svg>



        <span>Licensed under CC BY-NC-SA 4.0</span>
    </section>
    </footer>


    
</article>

    

    

     
    
        
    

    <footer class="site-footer">
    <section class="copyright">
        &copy; 
        
            2022 - 
        
        2023 笑傩
    </section>
    
    <section class="powerby">
        Built with <a href="https://gohugo.io/" target="_blank" rel="noopener">Hugo</a> <br />
        主题 <b><a href="https://github.com/CaiJimmy/hugo-theme-stack" target="_blank" rel="noopener" data-version="3.16.0">Stack</a></b> 由 <a href="https://jimmycai.com" target="_blank" rel="noopener">Jimmy</a> 设计
    </section>
</footer>


    
<div class="pswp" tabindex="-1" role="dialog" aria-hidden="true">

    
    <div class="pswp__bg"></div>

    
    <div class="pswp__scroll-wrap">

        
        <div class="pswp__container">
            <div class="pswp__item"></div>
            <div class="pswp__item"></div>
            <div class="pswp__item"></div>
        </div>

        
        <div class="pswp__ui pswp__ui--hidden">

            <div class="pswp__top-bar">

                

                <div class="pswp__counter"></div>

                <button class="pswp__button pswp__button--close" title="Close (Esc)"></button>

                <button class="pswp__button pswp__button--share" title="Share"></button>

                <button class="pswp__button pswp__button--fs" title="Toggle fullscreen"></button>

                <button class="pswp__button pswp__button--zoom" title="Zoom in/out"></button>

                
                
                <div class="pswp__preloader">
                    <div class="pswp__preloader__icn">
                        <div class="pswp__preloader__cut">
                            <div class="pswp__preloader__donut"></div>
                        </div>
                    </div>
                </div>
            </div>

            <div class="pswp__share-modal pswp__share-modal--hidden pswp__single-tap">
                <div class="pswp__share-tooltip"></div>
            </div>

            <button class="pswp__button pswp__button--arrow--left" title="Previous (arrow left)">
            </button>

            <button class="pswp__button pswp__button--arrow--right" title="Next (arrow right)">
            </button>

            <div class="pswp__caption">
                <div class="pswp__caption__center"></div>
            </div>

        </div>

    </div>

</div><script 
                src="https://cdn.jsdelivr.net/npm/photoswipe@4.1.3/dist/photoswipe.min.js"integrity="sha256-ePwmChbbvXbsO02lbM3HoHbSHTHFAeChekF1xKJdleo="crossorigin="anonymous"
                defer
                >
            </script><script 
                src="https://cdn.jsdelivr.net/npm/photoswipe@4.1.3/dist/photoswipe-ui-default.min.js"integrity="sha256-UKkzOn/w1mBxRmLLGrSeyB4e1xbrp4xylgAWb3M42pU="crossorigin="anonymous"
                defer
                >
            </script><link 
                rel="stylesheet" 
                href="https://cdn.jsdelivr.net/npm/photoswipe@4.1.3/dist/default-skin/default-skin.min.css"crossorigin="anonymous"
            ><link 
                rel="stylesheet" 
                href="https://cdn.jsdelivr.net/npm/photoswipe@4.1.3/dist/photoswipe.min.css"crossorigin="anonymous"
            >

            </main>
        </div>
        <script 
                src="https://cdn.jsdelivr.net/npm/node-vibrant@3.1.6/dist/vibrant.min.js"integrity="sha256-awcR2jno4kI5X0zL8ex0vi2z&#43;KMkF24hUW8WePSA9HM="crossorigin="anonymous"
                
                >
            </script><script type="text/javascript" src="/ts/main.js" defer></script>


<link rel="preconnect" href="https://fonts.googleapis.com">
<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
<link href="https://fonts.googleapis.com/css2?family=Long+Cang&family=Ma+Shan+Zheng&family=Noto+Sans+SC:wght@300&family=Noto+Serif+SC:wght@300&family=Zhi+Mang+Xing&display=swap" rel="stylesheet">

    </body>
</html>
