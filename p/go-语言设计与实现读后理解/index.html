<!DOCTYPE html>
<html lang="zh-cn" dir="ltr">
    <head><meta charset='utf-8'>
<meta name='viewport' content='width=device-width, initial-scale=1'><meta name='description' content='此文章为学习 《Go 语言设计与实现》的总结性文章 编译原理 词法分析和语法分析 词法分析 源代码在计算机眼中其实是一团乱麻，是一个由字符组成的、无法被'>
<title>《Go 语言设计与实现》读后理解</title>

<link rel='canonical' href='https://xiaonuoz.github.io/p/go-%E8%AF%AD%E8%A8%80%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0%E8%AF%BB%E5%90%8E%E7%90%86%E8%A7%A3/'>

<link rel="stylesheet" href="/scss/style.min.5470349c9ee04f592bc7c1dcd2e028072cd1dec2a37467ccfd4c5ecaf180dcaa.css"><meta property='og:title' content='《Go 语言设计与实现》读后理解'>
<meta property='og:description' content='此文章为学习 《Go 语言设计与实现》的总结性文章 编译原理 词法分析和语法分析 词法分析 源代码在计算机眼中其实是一团乱麻，是一个由字符组成的、无法被'>
<meta property='og:url' content='https://xiaonuoz.github.io/p/go-%E8%AF%AD%E8%A8%80%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0%E8%AF%BB%E5%90%8E%E7%90%86%E8%A7%A3/'>
<meta property='og:site_name' content='笑傩'>
<meta property='og:type' content='article'><meta property='article:section' content='Post' /><meta property='article:published_time' content='2023-06-05T00:00:00&#43;00:00'/><meta property='article:modified_time' content='2023-06-05T00:00:00&#43;00:00'/>
<meta name="twitter:title" content="《Go 语言设计与实现》读后理解">
<meta name="twitter:description" content="此文章为学习 《Go 语言设计与实现》的总结性文章 编译原理 词法分析和语法分析 词法分析 源代码在计算机眼中其实是一团乱麻，是一个由字符组成的、无法被">
    <link rel="shortcut icon" href="/favicon.ico" />

    </head>
    <body class="
    article-page
    ">
    <script>
        (function() {
            const colorSchemeKey = 'StackColorScheme';
            if(!localStorage.getItem(colorSchemeKey)){
                localStorage.setItem(colorSchemeKey, "auto");
            }
        })();
    </script><script>
    (function() {
        const colorSchemeKey = 'StackColorScheme';
        const colorSchemeItem = localStorage.getItem(colorSchemeKey);
        const supportDarkMode = window.matchMedia('(prefers-color-scheme: dark)').matches === true;

        if (colorSchemeItem == 'dark' || colorSchemeItem === 'auto' && supportDarkMode) {
            

            document.documentElement.dataset.scheme = 'dark';
        } else {
            document.documentElement.dataset.scheme = 'light';
        }
    })();
</script>
<div class="container main-container flex on-phone--column extended"><aside class="sidebar left-sidebar sticky ">
    <button class="hamburger hamburger--spin" type="button" id="toggle-menu" aria-label="切换菜单">
        <span class="hamburger-box">
            <span class="hamburger-inner"></span>
        </span>
    </button>

    <header>
        
            
            <figure class="site-avatar">
                <a href="/">
                
                    
                    
                    
                        
                        <img src="/img/avatar_hu89d70501dbd1e038dcbf309839bfe7a9_213951_300x0_resize_box_3.png" width="300"
                            height="300" class="site-logo" loading="lazy" alt="Avatar">
                    
                
                </a>
                
            </figure>
            
        
        
        <div class="site-meta">
            <h1 class="site-name"><a href="/">笑傩</a></h1>
            <h2 class="site-description">永远不要高估自己~</h2>
        </div>
    </header><ol class="social-menu">
            
                <li>
                    <a 
                        href='https://github.com/xiaonuoz'
                        target="_blank"
                        title="GitHub"
                        rel="me"
                    >
                        
                        
                            <svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-brand-github" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round">
  <path stroke="none" d="M0 0h24v24H0z" fill="none"/>
  <path d="M9 19c-4.3 1.4 -4.3 -2.5 -6 -3m12 5v-3.5c0 -1 .1 -1.4 -.5 -2c2.8 -.3 5.5 -1.4 5.5 -6a4.6 4.6 0 0 0 -1.3 -3.2a4.2 4.2 0 0 0 -.1 -3.2s-1.1 -.3 -3.5 1.3a12.3 12.3 0 0 0 -6.2 0c-2.4 -1.6 -3.5 -1.3 -3.5 -1.3a4.2 4.2 0 0 0 -.1 3.2a4.6 4.6 0 0 0 -1.3 3.2c0 4.6 2.7 5.7 5.5 6c-.6 .6 -.6 1.2 -.5 2v3.5" />
</svg>



                        
                    </a>
                </li>
            
        </ol><ol class="menu" id="main-menu">
        
        
        
        <li >
            <a href='/' >
                
                
                
                    <svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-home" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round">
  <path stroke="none" d="M0 0h24v24H0z"/>
  <polyline points="5 12 3 12 12 3 21 12 19 12" />
  <path d="M5 12v7a2 2 0 0 0 2 2h10a2 2 0 0 0 2 -2v-7" />
  <path d="M9 21v-6a2 2 0 0 1 2 -2h2a2 2 0 0 1 2 2v6" />
</svg>



                
                <span>主页</span>
            </a>
        </li>
        
        
        <li >
            <a href='/search/' >
                
                
                
                    <svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-search" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round">
  <path stroke="none" d="M0 0h24v24H0z"/>
  <circle cx="10" cy="10" r="7" />
  <line x1="21" y1="21" x2="15" y2="15" />
</svg>



                
                <span>搜索</span>
            </a>
        </li>
        

        <div class="menu-bottom-section">
            
            
                <li id="dark-mode-toggle">
                    <svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-toggle-left" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round">
  <path stroke="none" d="M0 0h24v24H0z"/>
  <circle cx="8" cy="12" r="2" />
  <rect x="2" y="6" width="20" height="12" rx="6" />
</svg>



                    <svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-toggle-right" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round">
  <path stroke="none" d="M0 0h24v24H0z"/>
  <circle cx="16" cy="12" r="2" />
  <rect x="2" y="6" width="20" height="12" rx="6" />
</svg>



                    <span>暗色模式</span>
                </li>
            
        </div>
    </ol>
</aside>

    <aside class="sidebar right-sidebar sticky">
        
            
                
    <section class="widget archives">
        <div class="widget-icon">
            <svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-hash" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round">
  <path stroke="none" d="M0 0h24v24H0z"/>
  <line x1="5" y1="9" x2="19" y2="9" />
  <line x1="5" y1="15" x2="19" y2="15" />
  <line x1="11" y1="4" x2="7" y2="20" />
  <line x1="17" y1="4" x2="13" y2="20" />
</svg>



        </div>
        <h2 class="widget-title section-title">目录</h2>
        
        <div class="widget--toc">
            <nav id="TableOfContents">
  <ol>
    <li><a href="#编译原理">编译原理</a>
      <ol>
        <li><a href="#词法分析和语法分析">词法分析和语法分析</a>
          <ol>
            <li><a href="#词法分析">词法分析</a></li>
            <li><a href="#语法分析">语法分析</a></li>
          </ol>
        </li>
        <li><a href="#类型检查">类型检查</a>
          <ol>
            <li><a href="#强弱类型">强弱类型</a></li>
            <li><a href="#静态类型和动态类型">静态类型和动态类型</a></li>
          </ol>
        </li>
        <li><a href="#中间代码生成">中间代码生成</a></li>
        <li><a href="#机器码生成">机器码生成</a>
          <ol>
            <li><a href="#指令集架构">指令集架构</a></li>
            <li><a href="#机器码生成-1">机器码生成</a></li>
          </ol>
        </li>
      </ol>
    </li>
    <li><a href="#数据结构">数据结构</a>
      <ol>
        <li><a href="#数组">数组</a>
          <ol>
            <li><a href="#初始化">初始化</a></li>
            <li><a href="#访问和赋值">访问和赋值</a></li>
          </ol>
        </li>
        <li><a href="#切片">切片</a>
          <ol>
            <li><a href="#数据结构-1">数据结构</a></li>
            <li><a href="#初始化-1">初始化</a></li>
            <li><a href="#访问元素">访问元素</a></li>
            <li><a href="#追加和扩容">追加和扩容</a></li>
            <li><a href="#拷贝切片">拷贝切片</a></li>
          </ol>
        </li>
        <li><a href="#哈希表">哈希表</a>
          <ol>
            <li><a href="#设计原理">设计原理</a></li>
            <li><a href="#数据结构-2">数据结构</a></li>
            <li><a href="#初始化-2">初始化</a></li>
            <li><a href="#读写操作">读写操作</a></li>
            <li><a href="#总结">总结</a></li>
          </ol>
        </li>
        <li><a href="#字符串">字符串</a>
          <ol>
            <li><a href="#数据结构-3">数据结构</a></li>
            <li><a href="#解析过程">解析过程</a></li>
            <li><a href="#拼接">拼接</a></li>
            <li><a href="#类型转换">类型转换</a></li>
          </ol>
        </li>
      </ol>
    </li>
    <li><a href="#语言基础">语言基础</a>
      <ol>
        <li><a href="#函数调用">函数调用</a>
          <ol>
            <li><a href="#调用惯例">调用惯例</a></li>
            <li><a href="#参数传递">参数传递</a></li>
          </ol>
        </li>
      </ol>
    </li>
  </ol>
</nav>
        </div>
    </section>

            
        
    </aside>


            <main class="main full-width">
    <article class="main-article">
    <header class="article-header">

    <div class="article-details">
    
    <header class="article-category">
        
            <a href="/categories/golang/" >
                golang
            </a>
        
    </header>
    

    <div class="article-title-wrapper">
        <h2 class="article-title">
            <a href="/p/go-%E8%AF%AD%E8%A8%80%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0%E8%AF%BB%E5%90%8E%E7%90%86%E8%A7%A3/">《Go 语言设计与实现》读后理解</a>
        </h2>
    
        
    </div>

    
    
    
    
    <footer class="article-time">
        
            <div>
                <svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-calendar-time" width="56" height="56" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round">
  <path stroke="none" d="M0 0h24v24H0z"/>
  <path d="M11.795 21h-6.795a2 2 0 0 1 -2 -2v-12a2 2 0 0 1 2 -2h12a2 2 0 0 1 2 2v4" />
  <circle cx="18" cy="18" r="4" />
  <path d="M15 3v4" />
  <path d="M7 3v4" />
  <path d="M3 11h16" />
  <path d="M18 16.496v1.504l1 1" />
</svg>
                <time class="article-time--published">Jun 05, 2023</time>
            </div>
        

        
    </footer>
    

    
</div>

</header>

    <section class="article-content">
    
    
    <p><code>此文章为学习 《Go 语言设计与实现》的总结性文章</code></p>
<h2 id="编译原理">编译原理</h2>
<h3 id="词法分析和语法分析">词法分析和语法分析</h3>
<h4 id="词法分析">词法分析</h4>
<p>源代码在计算机眼中其实是一团乱麻，是一个由字符组成的、无法被理解的字符串，为了理解这些字符我们需要做的第一件事情就是 <strong>将字符串分组</strong> ，这能够降低理解字符串的成本，简化源代码的分析过程。</p>
<p>源文件在机器的眼中是很难理解的字符串，词法分析会将这些字符串解析成一个个token序列以便机器理解。使用的就是类似lex之类的词法分析器。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span><span class="lnt">8
</span><span class="lnt">9
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="line"><span class="cl"><span class="nx">PACKAGE</span>  <span class="nx">IDENT</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="nx">IMPORT</span>  <span class="nx">LPAREN</span>
</span></span><span class="line"><span class="cl">	<span class="nx">QUOTE</span> <span class="nx">IDENT</span> <span class="nx">QUOTE</span>
</span></span><span class="line"><span class="cl"><span class="nx">RPAREN</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="nx">IDENT</span>  <span class="nx">IDENT</span> <span class="nx">LPAREN</span> <span class="nx">RPAREN</span>  <span class="nx">LBRACE</span>
</span></span><span class="line"><span class="cl">	<span class="nx">IDENT</span> <span class="nx">DOT</span> <span class="nx">IDENT</span> <span class="nx">LPAREN</span> <span class="nx">QUOTE</span> <span class="nx">IDENT</span> <span class="nx">QUOTE</span> <span class="nx">RPAREN</span>
</span></span><span class="line"><span class="cl"><span class="nx">RBRACE</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>从上面的输出我们能够看到 Go 源代码的影子，lex 生成的词法分析器 lexer 通过正则匹配的方式将机器原本很难理解的字符串进行分解成很多的 Token，有利于后面的处理。</p>
<p>早期Go是使用lex进行词法解析，但是之后还是会用Go自己实现的词法分析器分析解析出的数据。<code>而如今词法解析和词法分析都是用Go自己实现的工具。</code></p>
<h4 id="语法分析">语法分析</h4>
<p>语法分析是根据某种特定的形式文法对 Token 序列构成的输入文本进行分析并确定其语法构成的过程。词法分析器输出的结果Token序列是语法分析器的输入。</p>
<h5 id="文法">文法</h5>
<p>上下文无关文法 是用来形式化、精确描述某种编程语言的工具，我们能够通过文法定义一种语言的语法，它主要包含一系列用于转换字符串的生产规则。上下文无关文法中的每一个生产规则都会将规则左侧的非终结符转换成右侧的字符串，也可以理解为用左侧的规则名来表示右侧的文件具体内容，从下面代码就可以看出来右侧有很多属于Go日常开发中的常用关键词。</p>
<p>从 <a class="link" href="https://github.com/golang/go/blob/master/src/cmd/compile/internal/syntax/parser.go"  target="_blank" rel="noopener"
    ><code>src/cmd/compile/internal/syntax/parser.go</code></a>文件中摘抄一些 Go 语言文法的生产规则：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="line"><span class="cl"><span class="nx">SourceFile</span> <span class="p">=</span> <span class="nx">PackageClause</span> <span class="s">&#34;;&#34;</span> <span class="p">{</span> <span class="nx">ImportDecl</span> <span class="s">&#34;;&#34;</span> <span class="p">}</span> <span class="p">{</span> <span class="nx">TopLevelDecl</span> <span class="s">&#34;;&#34;</span> <span class="p">}</span> <span class="p">.</span>
</span></span><span class="line"><span class="cl"><span class="nx">PackageClause</span>  <span class="p">=</span> <span class="s">&#34;package&#34;</span> <span class="nx">PackageName</span> <span class="p">.</span>
</span></span><span class="line"><span class="cl"><span class="nx">PackageName</span>    <span class="p">=</span> <span class="nx">identifier</span> <span class="p">.</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="nx">ImportDecl</span>       <span class="p">=</span> <span class="s">&#34;import&#34;</span> <span class="p">(</span> <span class="nx">ImportSpec</span> <span class="p">|</span> <span class="s">&#34;(&#34;</span> <span class="p">{</span> <span class="nx">ImportSpec</span> <span class="s">&#34;;&#34;</span> <span class="p">}</span> <span class="s">&#34;)&#34;</span> <span class="p">)</span> <span class="p">.</span>
</span></span><span class="line"><span class="cl"><span class="nx">ImportSpec</span>       <span class="p">=</span> <span class="p">[</span> <span class="s">&#34;.&#34;</span> <span class="p">|</span> <span class="nx">PackageName</span> <span class="p">]</span> <span class="nx">ImportPath</span> <span class="p">.</span>
</span></span><span class="line"><span class="cl"><span class="nx">ImportPath</span>       <span class="p">=</span> <span class="nx">string_lit</span> <span class="p">.</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="nx">TopLevelDecl</span>  <span class="p">=</span> <span class="nx">Declaration</span> <span class="p">|</span> <span class="nx">FunctionDecl</span> <span class="p">|</span> <span class="nx">MethodDecl</span> <span class="p">.</span>
</span></span><span class="line"><span class="cl"><span class="nx">Declaration</span>   <span class="p">=</span> <span class="nx">ConstDecl</span> <span class="p">|</span> <span class="nx">TypeDecl</span> <span class="p">|</span> <span class="nx">VarDecl</span> <span class="p">.</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>因为每个 Go 源代码文件最终都会被解析成一个独立的抽象语法树，所以语法树最顶层的结构或者开始符号都是 SourceFile。</p>
<p>从 SourceFile 相关的生产规则我们可以看出，每一个文件都包含一个 <code>package</code> 的定义以及可选的 <code>import</code> 声明和其他的顶层声明（在花括号中表示可选，类似正则），每一个 SourceFile 在编译器中都对应一个 <a class="link" href="https://draveness.me/golang/tree/cmd/compile/internal/syntax.File"  target="_blank" rel="noopener"
    ><code>cmd/compile/internal/syntax.File</code></a> 结构体，你能从它们的定义中轻松找到两者的联系：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="line"><span class="cl"><span class="kd">type</span> <span class="nx">File</span> <span class="kd">struct</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">	<span class="nx">Pragma</span>   <span class="nx">Pragma</span>
</span></span><span class="line"><span class="cl">	<span class="nx">PkgName</span>  <span class="o">*</span><span class="nx">Name</span>
</span></span><span class="line"><span class="cl">	<span class="nx">DeclList</span> <span class="p">[]</span><span class="nx">Decl</span>
</span></span><span class="line"><span class="cl">	<span class="nx">Lines</span>    <span class="kt">uint</span>
</span></span><span class="line"><span class="cl">	<span class="nx">node</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>顶层声明有五大类型，分别是常量、类型、变量、函数和方法，你可以在文件 <a class="link" href="https://github.com/golang/go/blob/master/src/cmd/compile/internal/syntax/parser.go"  target="_blank" rel="noopener"
    ><code>src/cmd/compile/internal/syntax/parser.go</code></a> 中找到这五大类型的定义。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="line"><span class="cl"><span class="nx">ConstDecl</span> <span class="p">=</span> <span class="s">&#34;const&#34;</span> <span class="p">(</span> <span class="nx">ConstSpec</span> <span class="p">|</span> <span class="s">&#34;(&#34;</span> <span class="p">{</span> <span class="nx">ConstSpec</span> <span class="s">&#34;;&#34;</span> <span class="p">}</span> <span class="s">&#34;)&#34;</span> <span class="p">)</span> <span class="p">.</span>
</span></span><span class="line"><span class="cl"><span class="nx">ConstSpec</span> <span class="p">=</span> <span class="nx">IdentifierList</span> <span class="p">[</span> <span class="p">[</span> <span class="nx">Type</span> <span class="p">]</span> <span class="s">&#34;=&#34;</span> <span class="nx">ExpressionList</span> <span class="p">]</span> <span class="p">.</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="nx">TypeDecl</span>  <span class="p">=</span> <span class="s">&#34;type&#34;</span> <span class="p">(</span> <span class="nx">TypeSpec</span> <span class="p">|</span> <span class="s">&#34;(&#34;</span> <span class="p">{</span> <span class="nx">TypeSpec</span> <span class="s">&#34;;&#34;</span> <span class="p">}</span> <span class="s">&#34;)&#34;</span> <span class="p">)</span> <span class="p">.</span>
</span></span><span class="line"><span class="cl"><span class="nx">TypeSpec</span>  <span class="p">=</span> <span class="nx">AliasDecl</span> <span class="p">|</span> <span class="nx">TypeDef</span> <span class="p">.</span>
</span></span><span class="line"><span class="cl"><span class="nx">AliasDecl</span> <span class="p">=</span> <span class="nx">identifier</span> <span class="s">&#34;=&#34;</span> <span class="nx">Type</span> <span class="p">.</span>
</span></span><span class="line"><span class="cl"><span class="nx">TypeDef</span>   <span class="p">=</span> <span class="nx">identifier</span> <span class="nx">Type</span> <span class="p">.</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="nx">VarDecl</span> <span class="p">=</span> <span class="s">&#34;var&#34;</span> <span class="p">(</span> <span class="nx">VarSpec</span> <span class="p">|</span> <span class="s">&#34;(&#34;</span> <span class="p">{</span> <span class="nx">VarSpec</span> <span class="s">&#34;;&#34;</span> <span class="p">}</span> <span class="s">&#34;)&#34;</span> <span class="p">)</span> <span class="p">.</span>
</span></span><span class="line"><span class="cl"><span class="nx">VarSpec</span> <span class="p">=</span> <span class="nf">IdentifierList</span> <span class="p">(</span> <span class="nx">Type</span> <span class="p">[</span> <span class="s">&#34;=&#34;</span> <span class="nx">ExpressionList</span> <span class="p">]</span> <span class="p">|</span> <span class="s">&#34;=&#34;</span> <span class="nx">ExpressionList</span> <span class="p">)</span> <span class="p">.</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>上述的文法分别定义了 Go 语言中常量、类型和变量三种常见的结构，从文法中可以看到语言中的很多关键字 <code>const</code>、<code>type</code> 和 <code>var</code></p>
<h5 id="分析方法">分析方法</h5>
<p>语法分析的分析方法一般分为自顶向下和自底向上两种，这两种方式会使用不同的方式对输入的 Token 序列进行推导：</p>
<ul>
<li>自顶向下分析：可以被看作找到当前输入流最左推导的过程，对于任意一个输入流，根据当前的输入符号，确定一个生产规则，使用生产规则右侧的符号替代相应的非终结符向下推导。</li>
<li>自底向上分析：语法分析器从输入流开始，每次都尝试重写最右侧的多个符号，这其实是说解析器会从最简单的符号进行推导，在解析的最后合并成开始符号。</li>
</ul>
<p>自顶向下和自底向上都是从开始符号开始解析，直到整个字符串中不存在任何的非终结符，整个解析过程才会结束。个人理解就是从源文件最开始时解析，根据生产规则向下进行逐个匹配。而两者的区别是对于生产规则的匹配一个是从头到尾一个是从尾到头</p>
<p>LL文法是一种使用自顶向下分析方法的文法。常见的四种文法 LR(0)、SLR、LR(1) 和 LALR(1) 则使用了自底向上的处理方式</p>
<h5 id="lookahead">Lookahead</h5>
<p>在语法分析中除了 LL 和 LR 这两种不同类型的语法分析方法之外，还存在另一个非常重要的概念，就是 <code>向前查看</code>，在不同生产规则发生冲突时（当前内容符合多个生产规则），当前解析器需要通过预读一些 Token 判断当前应该用什么生产规则对输入流进行展开或者归约，例如在 LALR(1) 文法中，需要预读一个 Token 保证出现冲突的生产规则能够被正确处理。</p>
<p>Go 语言的解析器使用了 LALR(1) 的文法来解析词法分析过程中输出的 Token 序列，最右推导加向前查看构成了 Go 语言解析器的最基本原理，也是大多数编程语言的选择。<code>语法分析就是将token序列根据各种生产规则解析成抽象语法树</code></p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="line"><span class="cl"><span class="s">&#34;json.go&#34;</span><span class="p">:</span> <span class="nx">SourceFile</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="nx">PackageName</span><span class="p">:</span> <span class="s">&#34;json&#34;</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">    <span class="nx">ImportDecl</span><span class="p">:</span> <span class="p">[]</span><span class="nx">Import</span><span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="s">&#34;io&#34;</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">    <span class="p">},</span>
</span></span><span class="line"><span class="cl">    <span class="nx">TopLevelDecl</span><span class="p">:</span> <span class="o">...</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>在Go中词法分析和语法分析是同时进行的，词法分析获取一个Token后马上对这个Token进行语法分析，然后循环这个步骤直到读完文件。</p>
<h3 id="类型检查">类型检查</h3>
<h4 id="强弱类型">强弱类型</h4>
<p>强类型和弱类型经常会被放在一起讨论，然而这两者并没有一个学术上的严格定义，我们很多时候只能根据现象和特性从直觉上进行判断：</p>
<ul>
<li>强类型的编程语言在编译期间会有更严格的类型限制，也就是编译器会在编译期间发现变量赋值、返回值和函数调用时的类型错误后结束编译。</li>
<li>弱类型的编程语言在出现类型错误时可能会在运行时自动进行隐式的类型转换，在类型转换时可能会造成运行错误，即它对类型的正确与否没有很强的限制，在运行时也只是可能会类型转换失败。</li>
</ul>
<p>因为Go语言会在编译期间发现类型错误，也属于是强类型的编程语言。</p>
<h4 id="静态类型和动态类型">静态类型和动态类型</h4>
<h5 id="静态类型检查">静态类型检查</h5>
<p><code>静态类型检查是基于对源代码的分析来确定运行程序 类型安全的过程，</code>如果代码能够通过静态类型检查，那么当前程序在一定程度上可以满足类型安全的要求，它能够减少程序在运行时的类型检查，也可以被看作是一种代码优化的方式。</p>
<p>静态类型检查可以帮助我们在编译期间发现程序中出现的类型错误，一些动态类型的编程语言都有社区提供的工具为这些编程语言加入静态类型检查功能，比如JS的Flow，这些工具能够在编译期间发现代码中的类型错误。</p>
<p>静态类型检查为代码在编译期间提供了约束，编译器能够在编译期间约束变量的类型。避免类型错误直到运行时才会报错崩溃，要是业务逻辑很复杂且这个错误在判断语句中，那么寻找这个错误就会花费大量的时间（特定情况才出现bug，很难排查），而静态类型检查在编译时就会明明白白的告诉你错误发生在何处，是什么原因。</p>
<p>静态类型检查在重构时能够帮助我们节省大量的时间并避免遗漏，但是如果编程语言仅支持动态类型检查，那么就需要写大量的单元测试保证重构不会出现类型错误。</p>
<h5 id="动态类型检查">动态类型检查</h5>
<p>大部分的动态类型编程语言是解释型的，也就是一边解释一边执行，没有生成中间代码或者二进制文件的过程。所有的语言都需要经过<strong>编译</strong>这一过程，但是不一定有编译器(compiler)这东西，它们可能是在解释器(interpreter)中进行这一过程。</p>
<p><code>动态类型检查是在运行时再确定程序类型安全的过程，</code>它需要编程语言在编译时为所有的对象加入类型标签等信息，运行时可以使用这些存储的类型信息来实现动态派发、向下转型、反射以及其他特性。</p>
<p>动态类型检查能为程序员提供更多的操作空间，可以在运行时获取一些类型相关的上下文并根据对象的类型完成一些动态操作。虽然使用动态类型检查的编程语言在使用上非常灵活也不需要经过编译，但是有问题的代码不会因为更加灵活就减少错误，它在提高灵活性的同时也提高了对程序员开发能力的要求。</p>
<p>静态类型检查和动态类型检查不是完全冲突和对立的，它们一个作用与编译期一个作用与运行时，很多编程语言都会同时使用两种类型检查。例如Java不仅在编译期间检查类型错误，还为对象添加了类型信息，在运行时使用反射根据对象的类型动态地执行方法增强灵活性并减少冗余代码。</p>
<p>golang就属于静态类型检查的编程语言，但通过反射机制提供了一定程度的动态类型检查的能力。这使得Go语言在处理类型信息和实现某些特定的动态行为时更加灵活和强大。但静态类型检查仍然是它的主要特点和设计原则。</p>
<p>golang可以使用 ( := )来进行类型推断，但是这个是在编译期推断的，并不是在运行时，编译期就已经根据 ( := )的初始值确定了变量的类型，后续不能再进行更改，这个只是为了方便变量声明的简洁性和可读性。</p>
<p><strong><code>Go语言的编译器不仅使用静态类型检查来保证程序运行的类型安全，还会和Java一样在编程期间引入类型信息，让程序员可以使用反射来判断参数和变量的类型。当我们想要将 interface{} 转换成具体类型时就会进行动态类型检查(运行时)，如果无法发生转换就会出现程序崩溃。</code></strong></p>
<p>类型检查是Go语言编译的第二个阶段，在词法和语法分析之后我们能得到每个文件对应的抽象语法树，随后的类型检查会遍历抽象语法树中的节点，对每个节点的类型进行检验，找出其中存在的语法错误，并且在这个过程中也会对抽象语法树进行改写，这不仅能够去除一些不会被执行的代码、对代码进行优化以提高执行效率，而且也会修改make、new等关键字对应节点的操作类型。</p>
<p>make和new 这些内置函数其实并不会直接对应某些函数的实现，而是会在编译阶段被转换成真正存在的其他函数。make就会在类型检查阶段根据创建的具体类型(make的第一个参数) 将make 替换成特定的函数 <code>makechan</code>、<code>makeslice</code>、<code>makemap</code>，这样后面 生成中间代码阶段 就不会再处理OMAKE类型的节点了，而是会根据生成的细分类型进行处理。</p>
<h3 id="中间代码生成">中间代码生成</h3>
<p>词法分析和语法分析以及类型检查都属于编译器前端，它们负责对源码进行分析并检查其中存在的词法和语法错误，经过这两个阶段生成的抽象语法树已经不存在语法错误了。而中间代码生成属于编译器后端。</p>
<p>中间代码是编译器或者虚拟机 (JAVA中的JVM) 使用的语言，它可以帮助我们分析计算机程序。在编译过程中，编译器会在 将源码转换为机器码的过程中，先将源码转换成一种中间的表示形式，即中间代码。</p>
<p>很多人可能认为中间代码没有太多价值，可以直接将源码翻译成目标语言，这种看起来可行的办法实际上有很多问题，其中最主要的问题就是它忽略了编译器所面对的复杂场景，很多编译器都需要将源码翻译成多种机器码，那么在这种情况下直接翻译高级编程语言就比较困难，翻译程序会十分庞大。而中间代码是一种更接近机器语言的表达形式，对中间代码的优化和分析相比于直接分析高级语言会更加容易。</p>
<p>中间代码的生成过程是从AST 抽象语法树到 SSA 中间代码的转换过程，在这期间会对语法树中的关键字再进行改写 (defer 及new之类的内置函数)，改写后的语法树会经过 <strong>多轮处理</strong> 转变成最后的SSA中间代码，<strong>而在这多轮处理时就会包含一些针对机器的特定修改，包括根据目标架构对代码进行改写（目标架构不一定是当前电脑，go可以指定编译各种架构的二进制文件）</strong>，相关代码中包含了大量switch语句、复杂的函数和调用栈（部分文件一个switch就占了上千行，正常开发是不允许有这种情况的）。</p>
<p>很多Go关键字和内置函数就是在这个阶段被转换成运行时包中方法的。</p>
<p><img src="/p/go-%E8%AF%AD%E8%A8%80%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0%E8%AF%BB%E5%90%8E%E7%90%86%E8%A7%A3/media/image-1.png"
	width="1084"
	height="869"
	srcset="/p/go-%E8%AF%AD%E8%A8%80%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0%E8%AF%BB%E5%90%8E%E7%90%86%E8%A7%A3/media/image-1_huead841100c3ff60837c925a867773eb3_144316_480x0_resize_box_3.png 480w, /p/go-%E8%AF%AD%E8%A8%80%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0%E8%AF%BB%E5%90%8E%E7%90%86%E8%A7%A3/media/image-1_huead841100c3ff60837c925a867773eb3_144316_1024x0_resize_box_3.png 1024w"
	loading="lazy"
	
		alt="image.png"
	
	
		class="gallery-image" 
		data-flex-grow="124"
		data-flex-basis="299px"
	
></p>
<p><strong>中间代码就是指令集，而在机器码生成阶段会先将 SSA中间代码 转换成汇编语言最终再编译为机器码，而机器码就是最终的二进制文件。中间代码是一种特定于编程语言和平台的中间表示形式，通常比源代码更接近于机器码，但仍不是直接的机器码。</strong></p>
<h3 id="机器码生成">机器码生成</h3>
<p>Go语言编译的最后一个阶段是根据 SSA 中间代码生成机器码，这里谈的机器码是在目标 CPU架构上能够运行的二进制代码，而在中间代码环节的将近50 个生成中间代码的步骤中有一些过程严格上说是属于机器码生成阶段的。</p>
<p>机器码的生成过程其实就是对 SSA 中间代码的降级过程，在SSA中间代码降级的过程中，编译器将一些值重写成了目标CPU架构的特定值，降级的过程 处理了所有 机器特定的重写规则并对代码进行了一定程度的优化；在 SSA 中间代码生成阶段的最后，Go 函数体的代码会被转换成 <a class="link" href="https://draveness.me/golang/tree/cmd/compile/internal/obj.Prog"  target="_blank" rel="noopener"
    ><code>cmd/compile/internal/obj.Prog</code></a> 结构。</p>
<h4 id="指令集架构">指令集架构</h4>
<p>指令集架构是计算机的抽象模型，在很多时候也被称作架构或者计算机架构，它是计算机软件和硬件之间的接口和桥梁；一个为特定指令集架构编写的应用程序能够运行在所有支持这种指令集架构的机器上，也就是说如果当前应用程序支持x86的指令集，那么就可以运行在所有使用x86指令集的机器上，这其实就是抽象层的作用。每一个指令集架构都定义了支持的数据结构、寄存器、管理主内存的硬件支持（例如内存一致、地址模拟以及虚拟内存）、支持的指令集和IO模型，指令集的引入其实就是在软件和硬件之间引入了一个抽象层，让同一个二进制文件能够在不同版本的硬件上运行。</p>
<p>当前这里只是说是可以在同一种指令集机器上运行，并没有考虑系统，系统也是属于软件，不同的系统针对二进制文件可能有不同的处理，例如windows编译后的二进制文件放在linux上可能就无法运行，这是因为他们依赖并不相同。</p>
<p>如果一个编程语言想要在所有的机器上运行，它就可以将中间代码分别转换成使用不同指令集架构的机器码，这可比为不同硬件单独移植要简单的太多了。</p>
<h5 id="复杂指令集cisc和精简指令集risc">复杂指令集（CISC）和精简指令集（RISC）</h5>
<p>最常见的指令集架构分类方法是根据指令的复杂度将其分为 复杂指令集（CISC）和精简指令集（RISC），复杂指令集架构包含了很多特定的指令，但是其中的一些指令很少会被程序使用，但是又不能舍弃。而精简指令集只实现了经常被使用的指令，不常用的操作都会通过组合简单指令来实现。</p>
<p>因此复杂指令集性能更强大，因为它在电路板上焊了特定的指令集，但是这也意味着功耗更高，体积更大，而精简指令集由于是组合而来，它会弱一些，但是它功耗和体积会小点。</p>
<p>复杂指令集的特点就是指令数目多且复杂，每条指令的字节长度并不相等，x86就是常见的复杂指令集处理器，它的指令长度大小范围非常广，从 1 到 15 字节不等，对于长度不固定的指令，计算机必须额外对指令进行判断，这需要付出额外的性能损失。</p>
<p>而精简指令集对指令的数目和寻址方式做了精简，大大减少指令数量的同时也更容易实现，指令集中的每一个指令都使用标准的字节长度、执行时间相比复杂指令集会少很多，处理器在处理指令时也可以流水执行，提高了对并行的支持。</p>
<p>ARM 作为一种常见的精简指令集处理器，使用了 4个字节来作为指令集的固定长度，解决了因判断指令长度造成的性能损失问题。精简指令集其实就是利用了我们耳熟能详的二八原则，用20%的基础指令和它们的组合来解决大部分问题。</p>
<p>其宗旨就是通过优化设计，使得用尽可能少的基础指令可以覆盖尽可能多的操作需求。剩余的少部分特殊问题会在实际情况中通过如微码指令、专门的硬件单元等方法解决。</p>
<p>最开始的计算机使用复杂指令集是因为当时计算机的性能和内存都比较有限，业界需要尽可能地减少机器需要执行的指令，所以更倾向于高度编码、长度不等以及多操作数的指令。不过随着计算机性能的提升，出现了精简指令集这种牺牲代码密度换取简单实现的设计；除此之外，硬件的飞速提升还带来了更多的寄存器和更高的时钟频率，软件开发人员也不用再直接接触汇编代码，而是通过编译器和汇编器生成指令，复杂的机器指令对于编译器来说很难利用，所以精简指令在这种场景下更适合。</p>
<p>复杂指令集和精简指令集的使用是设计上的权衡，经过这么多年的发展，两种指令集也在相互借鉴和学习，与最开始刚被设计出来时已经有了较大的差别。</p>
<h4 id="机器码生成-1">机器码生成</h4>
<p>机器码的生成在 Go 的编译器中主要由两部分协同工作，其中一部分是负责 SSA 中间代码降级和根据目标架构进行特定处理的 <a class="link" href="https://github.com/golang/go/tree/master/src/cmd/compile/internal/ssa"  target="_blank" rel="noopener"
    ><code>cmd/compile/internal/ssa</code></a> 包，另一部分是负责生成机器码的 <a class="link" href="https://github.com/golang/go/tree/master/src/cmd/internal/obj"  target="_blank" rel="noopener"
    ><code>cmd/internal/obj</code></a></p>
<h5 id="ssa降级">SSA降级</h5>
<p>SSA 降级是在中间代码生成的过程中完成的，其中将近 50 轮处理的过程中，<code>lower</code> 以及后面的阶段都属于 SSA 降级这一过程，这么多轮的处理会对架构进行特定的优化和重写并生成 <a class="link" href="https://github.com/golang/go/blob/da54dfb6a1f3bef827b9ec3780c98fde77a97d11/src/cmd/internal/obj/link.go#L284"  target="_blank" rel="noopener"
    ><code>cmd/compile/internal/obj.Prog</code></a> 指令：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span><span class="lnt">8
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="line"><span class="cl"><span class="kd">var</span> <span class="nx">passes</span> <span class="p">=</span> <span class="p">[</span><span class="o">...</span><span class="p">]</span><span class="nx">pass</span><span class="p">{</span>
</span></span><span class="line"><span class="cl">	<span class="o">...</span>
</span></span><span class="line"><span class="cl">	<span class="p">{</span><span class="nx">name</span><span class="p">:</span> <span class="s">&#34;lower&#34;</span><span class="p">,</span> <span class="nx">fn</span><span class="p">:</span> <span class="nx">lower</span><span class="p">,</span> <span class="nx">required</span><span class="p">:</span> <span class="kc">true</span><span class="p">},</span>
</span></span><span class="line"><span class="cl">	<span class="p">{</span><span class="nx">name</span><span class="p">:</span> <span class="s">&#34;lowered deadcode for cse&#34;</span><span class="p">,</span> <span class="nx">fn</span><span class="p">:</span> <span class="nx">deadcode</span><span class="p">},</span> <span class="c1">// deadcode immediately before CSE avoids CSE making dead values live again
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="p">{</span><span class="nx">name</span><span class="p">:</span> <span class="s">&#34;lowered cse&#34;</span><span class="p">,</span> <span class="nx">fn</span><span class="p">:</span> <span class="nx">cse</span><span class="p">},</span>
</span></span><span class="line"><span class="cl">	<span class="o">...</span>
</span></span><span class="line"><span class="cl">	<span class="p">{</span><span class="nx">name</span><span class="p">:</span> <span class="s">&#34;trim&#34;</span><span class="p">,</span> <span class="nx">fn</span><span class="p">:</span> <span class="nx">trim</span><span class="p">},</span> <span class="c1">// remove empty blocks
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="p">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>重写的过程会将通用的 SSA中间代码 转换成目标架构特定的指令。可以通过对指令的压缩和优化减少在目标硬件上执行所需要的时间和资源。而紧接着就会使用obj包将SSA中间代码转换成汇编代码再编译为机器码。</p>
<p><a class="link" href="https://draveness.me/golang/tree/cmd/compile/internal/gc.buildssa"  target="_blank" rel="noopener"
    ><code>cmd/compile/internal/gc.buildssa</code></a> 中的 <code>lower</code> 和随后的多个阶段会对 SSA 进行转换、检查和优化，生成机器特定的中间代码（之前属于中间代码生成阶段）， <code>cmd/compile/internal/gc.compileSSA</code> 中的genssa会创建一个新的 <a class="link" href="https://draveness.me/golang/tree/cmd/compile/internal/gc.Progs"  target="_blank" rel="noopener"
    ><code>cmd/compile/internal/gc.Progs</code></a> 结构并将生成的 SSA 中间代码都存入新建的结构体中，至此SSA降级结束，随后调用的 pp.Flush() - <a class="link" href="https://draveness.me/golang/tree/cmd/compile/internal/gc.Progs.Flush"  target="_blank" rel="noopener"
    ><code>cmd/compile/internal/gc.Progs.Flush</code></a> 会使用 <a class="link" href="https://github.com/golang/go/tree/master/src/cmd/internal/obj"  target="_blank" rel="noopener"
    ><code>cmd/internal/obj</code></a> 包中的汇编器将 SSA 转换成汇编代码并编译成机器码。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span><span class="lnt">8
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="line"><span class="cl"><span class="kd">func</span> <span class="nf">compileSSA</span><span class="p">(</span><span class="nx">fn</span> <span class="o">*</span><span class="nx">Node</span><span class="p">,</span> <span class="nx">worker</span> <span class="kt">int</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">	<span class="nx">f</span> <span class="o">:=</span> <span class="nf">buildssa</span><span class="p">(</span><span class="nx">fn</span><span class="p">,</span> <span class="nx">worker</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">	<span class="nx">pp</span> <span class="o">:=</span> <span class="nf">newProgs</span><span class="p">(</span><span class="nx">fn</span><span class="p">,</span> <span class="nx">worker</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">	<span class="k">defer</span> <span class="nx">pp</span><span class="p">.</span><span class="nf">Free</span><span class="p">()</span>
</span></span><span class="line"><span class="cl">	<span class="nf">genssa</span><span class="p">(</span><span class="nx">f</span><span class="p">,</span> <span class="nx">pp</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">	<span class="nx">pp</span><span class="p">.</span><span class="nf">Flush</span><span class="p">()</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>转换汇编代码和编译成机器码都是由pp.Flush() 中的<a class="link" href="https://draveness.me/golang/tree/cmd/internal/obj.Flushplist"  target="_blank" rel="noopener"
    ><code>cmd/internal/obj.Flushplist</code></a> 中的 <code>Preprocess</code> 和 <code>Assemble</code> 方法组合完成的，这两个方法非常复杂，且会根据不同架构执行不同的方法，比如x86架构就会执行<a class="link" href="https://draveness.me/golang/tree/cmd/internal/obj/x86.preprocess"  target="_blank" rel="noopener"
    ><code>cmd/internal/obj/x86.preprocess</code></a> 和 <a class="link" href="https://draveness.me/golang/tree/cmd/internal/obj/x86.span6"  target="_blank" rel="noopener"
    ><code>cmd/internal/obj/x86.span6</code></a> 。</p>
<h5 id="汇编器">汇编器</h5>
<p>汇编器是将汇编语言翻译为机器语言的程序，Go 语言的汇编器是基于 Plan 9 汇编器的输入类型设计的，不过Go 语言对于汇编语言 Plan 9 和汇编器的资料十分缺乏。</p>
<p>流程为：</p>
<p>源码  -&gt;  词法解析  -&gt;  语法解析  -&gt;  抽象语法树  -&gt;  类型检验  -&gt;  抽象语法树  -&gt;  中间代码  -&gt;  汇编  -&gt;  机器码</p>
<h2 id="数据结构">数据结构</h2>
<h3 id="数组">数组</h3>
<p>数组是由相同类型元素的集合组成的数据结构，计算机会为数组分配一块连续的内存来保存其中的元素，我们可以利用数组中元素的索引来快速访问特定的元素。</p>
<p>数组作为一种基本的数据类型，我们通常会从两个维度描述数组，也就是数组中存储的元素类型和数组最大能存储的元素个数。Go语言中 数组在初始化之后大小就无法改变，它的大小在初始化时就已经确定了，存储元素类型相同、但是大小不同的数组类型在Go 语言看来是两个完全不同的类型，只有两个条件都相同才是同一个类型。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span><span class="lnt">8
</span><span class="lnt">9
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="line"><span class="cl"><span class="kd">func</span> <span class="nf">NewArray</span><span class="p">(</span><span class="nx">elem</span> <span class="o">*</span><span class="nx">Type</span><span class="p">,</span> <span class="nx">bound</span> <span class="kt">int64</span><span class="p">)</span> <span class="o">*</span><span class="nx">Type</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">	<span class="k">if</span> <span class="nx">bound</span> <span class="p">&lt;</span> <span class="mi">0</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">		<span class="nf">Fatalf</span><span class="p">(</span><span class="s">&#34;NewArray: invalid bound %v&#34;</span><span class="p">,</span> <span class="nx">bound</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">	<span class="p">}</span>
</span></span><span class="line"><span class="cl">	<span class="nx">t</span> <span class="o">:=</span> <span class="nf">New</span><span class="p">(</span><span class="nx">TARRAY</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">	<span class="nx">t</span><span class="p">.</span><span class="nx">Extra</span> <span class="p">=</span> <span class="o">&amp;</span><span class="nx">Array</span><span class="p">{</span><span class="nx">Elem</span><span class="p">:</span> <span class="nx">elem</span><span class="p">,</span> <span class="nx">Bound</span><span class="p">:</span> <span class="nx">bound</span><span class="p">}</span>
</span></span><span class="line"><span class="cl">	<span class="nx">t</span><span class="p">.</span><span class="nf">SetNotInHeap</span><span class="p">(</span><span class="nx">elem</span><span class="p">.</span><span class="nf">NotInHeap</span><span class="p">())</span>
</span></span><span class="line"><span class="cl">	<span class="k">return</span> <span class="nx">t</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>编译期间的数组类型是由上述的 <a class="link" href="https://draveness.me/golang/tree/cmd/compile/internal/types.NewArray"  target="_blank" rel="noopener"
    ><code>cmd/compile/internal/types.NewArray</code></a> 函数生成的，该类型包含两个字段，分别是元素类型 <code>Elem</code> 和数组的大小 <code>Bound</code>，这两个字段共同构成了数组类型，而当前数组是否应该在堆栈中初始化也在编译期就确定了。</p>
<h4 id="初始化">初始化</h4>
<p>Go语言的数组有两种不同的创建方式，一种是显式的指定数组大小，另一种是使用 <code>[...]T</code> 声明数组，Go语言会在编译期间通过源码自动推导数组的大小。这两种声明方式在运行期间得到的结果是完全相同的，后一种声明方式在编译期间就会被转换成前一种，这就是编译器对数组大小的推导。</p>
<h5 id="上限推导">上限推导</h5>
<p>这两种不同的声明方式会导致编译器做出完全不同的处理，如果使用 <code>[10]T</code> 的方式，那么变量的类型在编译进行到类型检查阶段就会被提取出来，随后会调用NewArray函数创建包含数组大小的结构体。</p>
<p>如果使用 <code>[...]T</code> 的方式声明数组，编译器会在 <a class="link" href="https://draveness.me/golang/tree/cmd/compile/internal/gc.typecheckcomplit"  target="_blank" rel="noopener"
    ><code>cmd/compile/internal/gc.typecheckcomplit</code></a> 函数中先对该数组的大小进行推导，其中的 <code>typecheckarraylit </code>函数会通过遍历元素的方式来计算数组中元素的数量，再调用NewArray函数创建数组结构体。</p>
<p>所以，<code>[...]T{1, 2, 3}</code> 和 <code>[3]T{1, 2, 3}</code> 在运行时是完全等价的，<code>[...]T</code> 这种初始化方式也只是 Go 语言为我们提供的一种语法糖，当我们不想计算数组中的元素个数时可以通过这种方法减少一些工作量。</p>
<h5 id="语句转换">语句转换</h5>
<p>对于一个由字面量组成的数组（字面量在数组中指的就是初始化时附带的元素集合，即 <code>[4]int{1,2,3,4}</code>中的[1,2,3,4]就是字面量），根据数组初始化的元素数量的不同，编译器会在负责 初始化 字面量的 <a class="link" href="https://draveness.me/golang/tree/cmd/compile/internal/gc.anylit"  target="_blank" rel="noopener"
    ><code>cmd/compile/internal/gc.anylit</code></a> 函数中做两种不同的优化：</p>
<ol>
<li>当元素数量小于或者等于 4 个时，会直接将数组中的元素放置在栈上；</li>
<li>当元素数量大于 4 个时，会将数组中的元素放置到静态区并在运行时取出；</li>
</ol>
<p>大于4个放置在静态区是因为 当数组元素较多时，栈上分配可能导致栈溢出等问题，所以会先在静态存储区初始化然后拷贝到栈上，不要纠结初始化并赋值和先初始化后赋值谁快谁慢的问题，在编译阶段会对 <code>[4]int{1,2,3,4}</code>进行展开，变成先声明后一一赋值的形式，日常开发不用考虑初始化时元素个数的情况。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="line"><span class="cl"><span class="kd">var</span> <span class="nx">arr</span> <span class="p">[</span><span class="mi">5</span><span class="p">]</span><span class="kt">int</span>
</span></span><span class="line"><span class="cl"><span class="nx">statictmp_0</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="p">=</span> <span class="mi">1</span>
</span></span><span class="line"><span class="cl"><span class="nx">statictmp_0</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="p">=</span> <span class="mi">2</span>
</span></span><span class="line"><span class="cl"><span class="nx">statictmp_0</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="p">=</span> <span class="mi">3</span>
</span></span><span class="line"><span class="cl"><span class="nx">statictmp_0</span><span class="p">[</span><span class="mi">3</span><span class="p">]</span> <span class="p">=</span> <span class="mi">4</span>
</span></span><span class="line"><span class="cl"><span class="nx">statictmp_0</span><span class="p">[</span><span class="mi">4</span><span class="p">]</span> <span class="p">=</span> <span class="mi">5</span>
</span></span><span class="line"><span class="cl"><span class="nx">arr</span> <span class="p">=</span> <span class="nx">statictmp_0</span>
</span></span></code></pre></td></tr></table>
</div>
</div><h4 id="访问和赋值">访问和赋值</h4>
<p>无论是在栈上还是静态存储区，数组在内存中都是一连串的内存空间，我们通过指向数组开头的指针、元素的数量以及元素类型占的空间大小表示数组。如果我们不知道数组中元素的数量，访问时可能发生索引越界；而如果不知道数组中元素类型的大小，就没办法知道一次应该取出多少字节的数据，无论丢失了哪个信息，我们都没办法知道这片连续的内存空间到底存储了什么数据。</p>
<p>数组访问越界是非常严重的错误，Go 语言中可以在编译期间的静态类型检查判断数组越界，但是由于切片的大小是动态扩容的，切片就没办法在编译期间判断出是否越界的问题，<a class="link" href="https://draveness.me/golang/tree/cmd/compile/internal/gc.typecheck1"  target="_blank" rel="noopener"
    ><code>cmd/compile/internal/gc.typecheck1</code></a> 会验证访问数组的索引。</p>
<ol>
<li>访问数组的索引是非整数时，报错 “non-integer array index %v”；</li>
<li>访问数组的索引是负数时，报错 “invalid array index %v (index must be non-negative)&quot;；</li>
<li>访问数组的索引越界时，报错 “invalid array index %v (out of bounds for %d-element array)&quot;；</li>
</ol>
<p>数组和字符串的一些简单越界错误都会在编译期间发现，但是如果使用变量去访问数组或者字符串时，编译器就无法提前发现错误，我们需要 Go 语言在运行时来阻止不合法的访问。Go 语言运行时在发现数组、切片和字符串的越界操作会由运行时的 <a class="link" href="https://draveness.me/golang/tree/runtime.panicIndex"  target="_blank" rel="noopener"
    ><code>runtime.panicIndex</code></a> 和 <a class="link" href="https://draveness.me/golang/tree/runtime.goPanicIndex"  target="_blank" rel="noopener"
    ><code>runtime.goPanicIndex</code></a> 触发程序的运行时错误并导致异常崩溃退出。</p>
<p>只有当编译器无法对数组下标是否越界作出判断时才会加入 <code>PanicBounds</code> 指令（即<a class="link" href="https://draveness.me/golang/tree/runtime.panicIndex"  target="_blank" rel="noopener"
    ><code>runtime.panicIndex</code></a> 函数）交给运行时进行判断，在使用常量数组下标时，如果静态类型检查阶段通过就会生成非常简单的中间代码。</p>
<p>生成ssa.html:</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="line"><span class="cl"><span class="kn">package</span> <span class="nx">check</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kd">func</span> <span class="nf">outOfRange</span><span class="p">()</span> <span class="kt">int</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">	<span class="nx">arr</span> <span class="o">:=</span> <span class="p">[</span><span class="mi">3</span><span class="p">]</span><span class="kt">int</span><span class="p">{</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">}</span>
</span></span><span class="line"><span class="cl">	<span class="nx">i</span> <span class="o">:=</span> <span class="mi">4</span>
</span></span><span class="line"><span class="cl">	<span class="nx">elem</span> <span class="o">:=</span> <span class="nx">arr</span><span class="p">[</span><span class="nx">i</span><span class="p">]</span>
</span></span><span class="line"><span class="cl">	<span class="k">return</span> <span class="nx">elem</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="err">$</span> <span class="nx">GOSSAFUNC</span><span class="p">=</span><span class="nx">outOfRange</span> <span class="k">go</span> <span class="nx">build</span> <span class="nx">array</span><span class="p">.</span><span class="k">go</span>
</span></span><span class="line"><span class="cl"><span class="nx">dumped</span> <span class="nx">SSA</span> <span class="nx">to</span> <span class="p">.</span><span class="o">/</span><span class="nx">ssa</span><span class="p">.</span><span class="nx">html</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>访问arr[2]生成的对应的SSA代码(start 阶段)：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="line"><span class="cl"><span class="nx">b1</span><span class="p">:</span>
</span></span><span class="line"><span class="cl">    <span class="nf">v14</span> <span class="p">(</span><span class="err">?</span><span class="p">)</span> <span class="p">=</span> <span class="nx">Const64</span> <span class="p">&lt;</span><span class="kt">int</span><span class="p">&gt;</span> <span class="p">[</span><span class="mi">2</span><span class="p">]</span>
</span></span><span class="line"><span class="cl">    <span class="o">...</span>
</span></span><span class="line"><span class="cl">    <span class="nf">v21</span> <span class="p">(</span><span class="mi">5</span><span class="p">)</span> <span class="p">=</span> <span class="nx">LocalAddr</span> <span class="p">&lt;</span><span class="o">*</span><span class="p">[</span><span class="mi">3</span><span class="p">]</span><span class="kt">int</span><span class="p">&gt;</span> <span class="p">{</span><span class="nx">arr</span><span class="p">}</span> <span class="nx">v2</span> <span class="nx">v20</span>
</span></span><span class="line"><span class="cl">    <span class="nf">v22</span> <span class="p">(</span><span class="mi">5</span><span class="p">)</span> <span class="p">=</span> <span class="nx">PtrIndex</span> <span class="p">&lt;</span><span class="o">*</span><span class="kt">int</span><span class="p">&gt;</span> <span class="nx">v21</span> <span class="nx">v14</span>
</span></span><span class="line"><span class="cl">    <span class="nf">v23</span> <span class="p">(</span><span class="mi">5</span><span class="p">)</span> <span class="p">=</span> <span class="nx">Load</span> <span class="p">&lt;</span><span class="kt">int</span><span class="p">&gt;</span> <span class="nx">v22</span> <span class="nf">v20</span> <span class="p">(</span><span class="nx">elem</span><span class="p">[</span><span class="kt">int</span><span class="p">])</span>
</span></span><span class="line"><span class="cl">    <span class="o">...</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>v21是寻址获取数组地址，v22是利用 <code>PtrIndex</code>  通过数组地址和下标计算出目标元素的地址，最后使用 <code>Load</code> 操作将指针中的元素加载到内存中</p>
<p>Go语言对于数组的访问还是有着比较多的检查的，它不仅会在编译期间提前发现一些简单的越界错误并插入用于检测数组上限的 <code>PanicBounds</code> 函数调用，还会在运行期间通过插入的函数来保证数组不会发生越界。</p>
<p>数组的赋值和更新操作 <code>a[2] = 2</code> 也会生成SSA中间代码：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="line"><span class="cl"><span class="nx">b1</span><span class="p">:</span>
</span></span><span class="line"><span class="cl">    <span class="o">...</span>
</span></span><span class="line"><span class="cl">    <span class="nf">v21</span> <span class="p">(</span><span class="mi">5</span><span class="p">)</span> <span class="p">=</span> <span class="nx">LocalAddr</span> <span class="p">&lt;</span><span class="o">*</span><span class="p">[</span><span class="mi">3</span><span class="p">]</span><span class="kt">int</span><span class="p">&gt;</span> <span class="p">{</span><span class="nx">arr</span><span class="p">}</span> <span class="nx">v2</span> <span class="nx">v19</span>
</span></span><span class="line"><span class="cl">    <span class="nf">v22</span> <span class="p">(</span><span class="mi">5</span><span class="p">)</span> <span class="p">=</span> <span class="nx">PtrIndex</span> <span class="p">&lt;</span><span class="o">*</span><span class="kt">int</span><span class="p">&gt;</span> <span class="nx">v21</span> <span class="nx">v13</span>
</span></span><span class="line"><span class="cl">    <span class="nf">v23</span> <span class="p">(</span><span class="mi">5</span><span class="p">)</span> <span class="p">=</span> <span class="nx">Store</span> <span class="p">&lt;</span><span class="nx">mem</span><span class="p">&gt;</span> <span class="p">{</span><span class="kt">int</span><span class="p">}</span> <span class="nx">v22</span> <span class="nx">v20</span> <span class="nx">v19</span>
</span></span><span class="line"><span class="cl">    <span class="o">...</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>赋值的过程中会先确定目标数组的地址，再通过 <code>PtrIndex</code> 获取目标元素的地址，最后使用 <code>Store</code> 指令将数据存入地址中。而如果下标不是常量也会有 <code>PanicBounds</code> 函数调用来避免越界。</p>
<p>总结一下就是，数组的访问和赋值需要同时依赖编译器和运行时，它的大多数操作在编译期间都会转换成直接读写内存，并在中间代码生成阶段，如果在编译期间无法判断数组是否越界（即下标非常量），编译器还会插入运行时方法 <a class="link" href="https://draveness.me/golang/tree/runtime.panicIndex"  target="_blank" rel="noopener"
    ><code>runtime.panicIndex</code></a> 调用防止发生越界错误。</p>
<h3 id="切片">切片</h3>
<p>数组在Go 语言中没有那么常用，更常用的数据结构是切片，即动态数组，其长度并不固定，可以随时向切片中追加元素，它会在容量不足时自动扩容。</p>
<h4 id="数据结构-1">数据结构</h4>
<p>编译期间的切片是 <a class="link" href="https://github.com/golang/go/blob/3b2a578166bdedd94110698c971ba8990771eb89/src/cmd/compile/internal/types/type.go#L346"  target="_blank" rel="noopener"
    ><code>cmd/compile/internal/types.Slice</code></a> 类型的，但是在运行时切片是由 <a class="link" href="https://github.com/golang/go/blob/41d8e61a6b9d8f9db912626eb2bbc535e929fefc/src/reflect/value.go#L1994"  target="_blank" rel="noopener"
    ><code>reflect.SliceHeader</code></a> 结构体表示，其中:</p>
<ul>
<li><code>Data</code> 是指向底层数组的指针;</li>
<li><code>Len</code> 是当前切片的长度；</li>
<li><code>Cap</code> 是当前切片的容量，即 <code>Data</code> 数组的大小：</li>
</ul>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="line"><span class="cl"><span class="kd">type</span> <span class="nx">SliceHeader</span> <span class="kd">struct</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">	<span class="nx">Data</span> <span class="kt">uintptr</span>
</span></span><span class="line"><span class="cl">	<span class="nx">Len</span>  <span class="kt">int</span>
</span></span><span class="line"><span class="cl">	<span class="nx">Cap</span>  <span class="kt">int</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>Data 是一片连续的内存空间，这片内存空间可以用于存储切片中的全部元素，元素在底层存储时都是连续的，因此可以将切片理解成一片连续的内存空间加上长度与容量的标识。</p>
<p>切片与数组的关系非常密切，切片引入了一个抽象层，提供了对底层数组中部分连续片段的引用，而作为数组的引用，我们可以在运行期间修改它的长度和范围。当切片底层的数组长度不足以存放新增元素时就会触发扩容，扩容会导致其指向另一个新的底层数组，不过在上层看来切片是没有变化的，上层只需要与切片打交道，不需要关心底层数组的变化。</p>
<p>数组的内存布局在编译时就已经确定（长度固定），在运行时可以直接读写内存的特定位置，而切片是在运行时确定结构的，因为切片的长度可能会变化，依赖运行时来支持动态调整大小等操作。</p>
<h4 id="初始化-1">初始化</h4>
<p>Go 语言中包含三种初始化切片的方式：</p>
<ol>
<li>通过下标的方式获得数组或者切片的一部分；</li>
<li>使用字面量初始化新的切片；</li>
<li>使用关键字 <code>make</code> 创建切片：</li>
</ol>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="line"><span class="cl"><span class="nx">arr</span><span class="p">[</span><span class="mi">0</span><span class="p">:</span><span class="mi">3</span><span class="p">]</span> <span class="nx">or</span> <span class="nx">slice</span><span class="p">[</span><span class="mi">0</span><span class="p">:</span><span class="mi">3</span><span class="p">]</span>
</span></span><span class="line"><span class="cl"><span class="nx">slice</span> <span class="o">:=</span> <span class="p">[]</span><span class="kt">int</span><span class="p">{</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="nx">slice</span> <span class="o">:=</span> <span class="nb">make</span><span class="p">([]</span><span class="kt">int</span><span class="p">,</span> <span class="mi">10</span><span class="p">)</span>
</span></span></code></pre></td></tr></table>
</div>
</div><h5 id="使用下标">使用下标</h5>
<p>使用下标创建切片是最原始也是最接近汇编语言的方式，它是所有方法中最为底层的一种，编译器会将 <code>arr[0:3]</code> 或者 <code>slice[0:3]</code> 等语句转换成 <code>OpSliceMake</code> 操作</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span><span class="lnt">8
</span><span class="lnt">9
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="line"><span class="cl"><span class="kn">package</span> <span class="nx">opslicemake</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kd">func</span> <span class="nf">newSlice</span><span class="p">()</span> <span class="p">[]</span><span class="kt">int</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">	<span class="nx">arr</span> <span class="o">:=</span> <span class="p">[</span><span class="mi">3</span><span class="p">]</span><span class="kt">int</span><span class="p">{</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">}</span>
</span></span><span class="line"><span class="cl">	<span class="nx">slice</span> <span class="o">:=</span> <span class="nx">arr</span><span class="p">[</span><span class="mi">0</span><span class="p">:</span><span class="mi">1</span><span class="p">]</span>
</span></span><span class="line"><span class="cl">	<span class="k">return</span> <span class="nx">slice</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="c1">// GOSSAFUNC=newSlice go build arr1.go
</span></span></span></code></pre></td></tr></table>
</div>
</div><p>通过 <code>GOSSAFUNC</code> 变量编译上述代码可以得到一系列 SSA 中间代码，其中 <code>slice := arr[0:1]</code> 语句在 “decompose builtin” 阶段对应的代码如下所示：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span><span class="lnt">8
</span><span class="lnt">9
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="line"><span class="cl"><span class="nf">v9</span> <span class="p">(</span><span class="mi">4</span><span class="p">)</span> <span class="p">=</span> <span class="nx">SelectN</span> <span class="p">&lt;</span><span class="o">*</span><span class="p">[</span><span class="mi">3</span><span class="p">]</span><span class="kt">int</span><span class="p">&gt;</span> <span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="nf">v7</span> <span class="p">(</span><span class="o">&amp;</span><span class="nx">arr</span><span class="p">[</span><span class="o">*</span><span class="p">[</span><span class="mi">3</span><span class="p">]</span><span class="kt">int</span><span class="p">],</span> <span class="nx">slice</span><span class="p">.</span><span class="nx">ptr</span><span class="p">[</span><span class="o">*</span><span class="kt">int</span><span class="p">])</span>
</span></span><span class="line"><span class="cl"><span class="o">...</span>
</span></span><span class="line"><span class="cl"><span class="nf">v12</span> <span class="p">(</span><span class="err">?</span><span class="p">)</span> <span class="p">=</span> <span class="nx">Const64</span> <span class="p">&lt;</span><span class="kt">int</span><span class="p">&gt;</span> <span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="p">(</span><span class="nx">slice</span><span class="p">.</span><span class="nx">len</span><span class="p">[</span><span class="kt">int</span><span class="p">])</span>
</span></span><span class="line"><span class="cl"><span class="nf">v15</span> <span class="p">(</span><span class="err">?</span><span class="p">)</span> <span class="p">=</span> <span class="nx">Const64</span> <span class="p">&lt;</span><span class="kt">int</span><span class="p">&gt;</span> <span class="p">[</span><span class="mi">3</span><span class="p">]</span> <span class="p">(</span><span class="nx">slice</span><span class="p">.</span><span class="nx">cap</span><span class="p">[</span><span class="kt">int</span><span class="p">])</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="nx">name</span> <span class="o">&amp;</span><span class="nx">arr</span><span class="p">[</span><span class="o">*</span><span class="p">[</span><span class="mi">3</span><span class="p">]</span><span class="kt">int</span><span class="p">]:</span> <span class="nx">v9</span>
</span></span><span class="line"><span class="cl"><span class="nx">name</span> <span class="nx">slice</span><span class="p">.</span><span class="nx">ptr</span><span class="p">[</span><span class="o">*</span><span class="kt">int</span><span class="p">]:</span> <span class="nx">v9</span>
</span></span><span class="line"><span class="cl"><span class="nx">name</span> <span class="nx">slice</span><span class="p">.</span><span class="nx">len</span><span class="p">[</span><span class="kt">int</span><span class="p">]:</span> <span class="nx">v12</span>
</span></span><span class="line"><span class="cl"><span class="nx">name</span> <span class="nx">slice</span><span class="p">.</span><span class="nx">cap</span><span class="p">[</span><span class="kt">int</span><span class="p">]:</span> <span class="nx">v15</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p><code>SliceMake</code> 操作会接受四个参数创建新的切片，元素类型、数组指针、切片大小和容量，从 <code>ssa.html</code> 中可以发现它的ptr指针指向的依然是原arr数组，而不是重新创建一个新的底层数组，<strong>因此使用下标来初始化切片不会拷贝原数组或者原切片中的数据，它只会创建一个指向原数组的切片结构体，因此修改新切片的数据也会修改到原切片（两者指针指向同一片内存）。</strong></p>
<h5 id="字面量">字面量</h5>
<p>当我们使用字面量 <code>[]int{1, 2, 3}</code> 创建新的切片时，<a class="link" href="https://github.com/golang/go/blob/3b2a578166bdedd94110698c971ba8990771eb89/src/cmd/compile/internal/gc/sinit.go#L590"  target="_blank" rel="noopener"
    ><code>cmd/compile/internal/gc.slicelit</code></a> 函数会在编译期间将它展开成如下所示的代码片段：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="line"><span class="cl"><span class="c1">// 声明底层数组
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="kd">var</span> <span class="nx">vstat</span> <span class="p">[</span><span class="mi">3</span><span class="p">]</span><span class="kt">int</span>
</span></span><span class="line"><span class="cl"><span class="c1">// 赋值
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="nx">vstat</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="p">=</span> <span class="mi">1</span>
</span></span><span class="line"><span class="cl"><span class="nx">vstat</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="p">=</span> <span class="mi">2</span>
</span></span><span class="line"><span class="cl"><span class="nx">vstat</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="p">=</span> <span class="mi">3</span>
</span></span><span class="line"><span class="cl"><span class="c1">// 创建底层数组指针
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="kd">var</span> <span class="nx">vauto</span> <span class="o">*</span><span class="p">[</span><span class="mi">3</span><span class="p">]</span><span class="kt">int</span> <span class="p">=</span> <span class="nb">new</span><span class="p">([</span><span class="mi">3</span><span class="p">]</span><span class="kt">int</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="c1">// 指针指向底层数组
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="o">*</span><span class="nx">vauto</span> <span class="p">=</span> <span class="nx">vstat</span>
</span></span><span class="line"><span class="cl"><span class="nx">slice</span> <span class="o">:=</span> <span class="nx">vauto</span><span class="p">[:]</span>
</span></span></code></pre></td></tr></table>
</div>
</div><ol>
<li>根据切片中的元素数量对底层数组的大小进行推断并创建一个数组；</li>
<li>将这些字面量元素存储到初始化的数组中；</li>
<li>创建一个同样指向 <code>[3]int</code> 类型的数组指针；</li>
<li>将静态存储区的数组 <code>vstat</code> 赋值给 <code>vauto</code> 指针所在的地址；</li>
<li>通过 <code>[:]</code> 操作获取一个底层使用 <code>vauto</code> 的切片；</li>
</ol>
<p>第 5 步中的 <code>[:]</code> 就是使用下标创建切片的方法，从这一点我们也能看出 <code>[:]</code> 操作是创建切片最底层的一种方法。</p>
<h5 id="关键字">关键字</h5>
<p>如果使用字面量的方式创建切片，大部分的工作都会在编译期间完成。但是当我们使用 make 关键字来创建切片时，很多工作都需要运行时的参与；调用方必须向 make 函数传入切片的大小以及可选的容量，类型检查阶段时会校验入参（判断len必须，且cap&gt;=len）并将 <code>OMAKE</code> 节点转换成 <code>OMAKESLICE</code>，然后在中间代码生成阶段会依据两个条件来转换 <code>OMAKESLICE</code> 类型的节点：</p>
<ol>
<li>切片的大小和容量是否足够小；</li>
<li>切片是否发生了内存逃逸；</li>
</ol>
<p>当切片发生内存逃逸或者非常大时，切片的初始化会延后至运行时的<a class="link" href="https://github.com/golang/go/blob/3b2a578166bdedd94110698c971ba8990771eb89/src/runtime/slice.go#L83"  target="_blank" rel="noopener"
    ><code>runtime.makeslice</code></a> 在堆上初始化切片（即汇编语言代码中不会有初始化切片的代码，而是一个调用 <code> runtime.makeslice</code> 的函数），如果切片不会发生内存逃逸且非常小的时候，它会在编译阶段直接转换初始化切片的代码。例如  <code>make([]int, 3, 4)</code> 会被直接转换成如下所示的代码：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="line"><span class="cl"><span class="kd">var</span> <span class="nx">arr</span> <span class="p">[</span><span class="mi">4</span><span class="p">]</span><span class="kt">int</span>
</span></span><span class="line"><span class="cl"><span class="nx">n</span> <span class="o">:=</span> <span class="nx">arr</span><span class="p">[:</span><span class="mi">3</span><span class="p">]</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>上述代码会初始化数组并通过下标 <code>[:3]</code> 得到数组对应的切片，这两部分操作都会在编译阶段完成（只是生成代码，内存分配肯定还是在程序运行时，但是不会再调用 <code>runtime.makeslice</code>初始化切片），而这种方式初始化的切片会放在栈上，其底层数组会根据数组的规则放在栈或者静态存储区中。</p>
<p>运行时函数 <code>runtime.makeslice</code>的实现很简单：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="line"><span class="cl"><span class="kd">func</span> <span class="nf">makeslice</span><span class="p">(</span><span class="nx">et</span> <span class="o">*</span><span class="nx">_type</span><span class="p">,</span> <span class="nx">len</span><span class="p">,</span> <span class="nx">cap</span> <span class="kt">int</span><span class="p">)</span> <span class="nx">unsafe</span><span class="p">.</span><span class="nx">Pointer</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">	<span class="nx">mem</span><span class="p">,</span> <span class="nx">overflow</span> <span class="o">:=</span> <span class="nx">math</span><span class="p">.</span><span class="nf">MulUintptr</span><span class="p">(</span><span class="nx">et</span><span class="p">.</span><span class="nx">size</span><span class="p">,</span> <span class="nb">uintptr</span><span class="p">(</span><span class="nx">cap</span><span class="p">))</span>
</span></span><span class="line"><span class="cl">	<span class="k">if</span> <span class="nx">overflow</span> <span class="o">||</span> <span class="nx">mem</span> <span class="p">&gt;</span> <span class="nx">maxAlloc</span> <span class="o">||</span> <span class="nx">len</span> <span class="p">&lt;</span> <span class="mi">0</span> <span class="o">||</span> <span class="nx">len</span> <span class="p">&gt;</span> <span class="nx">cap</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">		<span class="nx">mem</span><span class="p">,</span> <span class="nx">overflow</span> <span class="o">:=</span> <span class="nx">math</span><span class="p">.</span><span class="nf">MulUintptr</span><span class="p">(</span><span class="nx">et</span><span class="p">.</span><span class="nx">size</span><span class="p">,</span> <span class="nb">uintptr</span><span class="p">(</span><span class="nx">len</span><span class="p">))</span>
</span></span><span class="line"><span class="cl">		<span class="k">if</span> <span class="nx">overflow</span> <span class="o">||</span> <span class="nx">mem</span> <span class="p">&gt;</span> <span class="nx">maxAlloc</span> <span class="o">||</span> <span class="nx">len</span> <span class="p">&lt;</span> <span class="mi">0</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">			<span class="nf">panicmakeslicelen</span><span class="p">()</span>
</span></span><span class="line"><span class="cl">		<span class="p">}</span>
</span></span><span class="line"><span class="cl">		<span class="nf">panicmakeslicecap</span><span class="p">()</span>
</span></span><span class="line"><span class="cl">	<span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">	<span class="k">return</span> <span class="nf">mallocgc</span><span class="p">(</span><span class="nx">mem</span><span class="p">,</span> <span class="nx">et</span><span class="p">,</span> <span class="kc">true</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>上述函数的主要工作是计算切片需要占用的内存空间并在堆上申请一片连续的内存供切片使用。它的计算方式是：</p>
<p><em><strong>内存空间 = 切片中单个元素大小 * 切片容量</strong></em></p>
<p>当然实际情况中还需要考虑内存对齐、垃圾回收的情况，最终切片申请的内存不一样是公式计算出来的内存，但是肯定会大于等于公式值。</p>
<p>编译期间可以检查出很多错误，不过有些问题在编译器是检查不出来的。在运行时创建切片的过程中如果发生了以下错误会直接触发运行时错误并崩溃：</p>
<ol>
<li>内存空间的大小发生了溢出；</li>
<li>申请的内存大于最大可分配的内存；</li>
<li>传入的长度小于 0 或者长度大于容量（传入的len是变量时，编译阶段无法判断是否小于cap）；</li>
</ol>
<p><a class="link" href="https://draveness.me/golang/tree/runtime.makeslice"  target="_blank" rel="noopener"
    ><code>runtime.makeslice</code></a> 在最后调用的 <a class="link" href="https://draveness.me/golang/tree/runtime.mallocgc"  target="_blank" rel="noopener"
    ><code>runtime.mallocgc</code></a> 是用于申请内存的函数，这个函数的实现比较复杂，如果遇到了比较小的对象会直接初始化在 Go 语言调度器里面的 P 结构中（不只是针对于切片），而大于 32KB 的对象会在堆上初始化。在Go语言的调度器中，对于较小的对象，为了减少内存分配的开销，会将这些对象直接初始化在P的本地内存池中，而不是在堆上分配。这个过程称为&quot;P本地对象缓存&quot;，而对于大于32KB的对象，它们往往会直接在堆上进行初始化，因为对于较大的对象，为它们分配独立的堆内存比较合理，这可以更好地管理内存碎片和利用堆的垃圾回收机制。</p>
<p>总结一下切片的分配逻辑：</p>
<p><strong>如果切片容量非常小且没有发生内存逃逸时，它会存储在栈中，其底层数组会根据数组的规则放在栈或者静态存储区中；如果切片容量大或者发生了内存逃逸，此时会判断其申请的内存是否大于32KB，大于则会分配在堆上，小于则会分配到P的本地内存池中。当然这只是简单的理解，实际上还需要考虑到内存管理机制等情况。</strong></p>
<p>使用下标方式创建切片，其底层数组由开发者自己创建；而字面量和关键字的方式创建底层数组都是由编译期或运行时声明创建。</p>
<h4 id="访问元素">访问元素</h4>
<p>使用 <code>len</code> 和 <code>cap</code> 获取长度或者容量是切片最常见的操作，编译器会将它们看成两种特殊操作，即 <code>OLEN</code> 和 <code>OCAP</code>，<a class="link" href="https://github.com/golang/go/blob/41d8e61a6b9d8f9db912626eb2bbc535e929fefc/src/cmd/compile/internal/gc/ssa.go#L2054"  target="_blank" rel="noopener"
    ><code>gc.state.expr</code></a> 函数会在 <code>SSA中间代码生成阶段</code> 将它们分别转换成 <code>OpSliceLen </code>和 <code>OpSliceCap</code></p>
<p>访问切片结构中的字段可能会触发 “decompose builtin” 阶段的优化，<code>len(slice)</code> 或者 <code>cap(slice)</code> 在某些情况下会直接替换成切片的长度或者容量 （<code>v13 (?) = Const64 &lt;int&gt;`` [5]</code>），不需要在运行时获取。</p>
<p>除了获取切片的长度和容量之外，访问切片中元素使用的 <code>OINDEX</code> 操作也会在中间代码生成期间转换成对地址的直接访问。除此之外，编译期间也会将包含 <code>range</code> 关键字的遍历转换成形式更简单的循环</p>
<p><strong>测试发现直接替换成切片长度或容量以及访问元素只会出现在切片定义在函数内部且它没有发生内存逃逸的情况，如果发生了内存逃逸或者直接定义在外部，编译期是无法判断它的长度容量以及是否会扩容导致切片移动到其他内存区的（其他函数也可以使用或扩容它）</strong></p>
<h4 id="追加和扩容">追加和扩容</h4>
<p>使用 <code>append</code> 关键字向切片中追加元素也是常见的切片操作，中间代码生成阶段的<a class="link" href="https://github.com/golang/go/blob/ac0ba6707c1655ea4316b41d06571a0303cc60eb/src/cmd/compile/internal/gc/ssa.go#L2841"  target="_blank" rel="noopener"
    ><code>gc.state.append</code></a> 方法会根据返回值是否会覆盖原变量来选择进入两种流程</p>
<p>如果 <code>append</code> 返回的新切片不需要赋值回原有的变量（即没有变量接收append后新切片的指针），就会进入如下的处理流程：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="line"><span class="cl"><span class="c1">// append(slice, 1, 2, 3)
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="nx">ptr</span><span class="p">,</span> <span class="nx">len</span><span class="p">,</span> <span class="nx">cap</span> <span class="o">:=</span> <span class="nx">slice</span>
</span></span><span class="line"><span class="cl"><span class="nx">newlen</span> <span class="o">:=</span> <span class="nx">len</span> <span class="o">+</span> <span class="mi">3</span>
</span></span><span class="line"><span class="cl"><span class="k">if</span> <span class="nx">newlen</span> <span class="p">&gt;</span> <span class="nx">cap</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="nx">ptr</span><span class="p">,</span> <span class="nx">len</span><span class="p">,</span> <span class="nx">cap</span> <span class="p">=</span> <span class="nf">growslice</span><span class="p">(</span><span class="nx">slice</span><span class="p">,</span> <span class="nx">newlen</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">    <span class="nx">newlen</span> <span class="p">=</span> <span class="nx">len</span> <span class="o">+</span> <span class="mi">3</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="o">*</span><span class="p">(</span><span class="nx">ptr</span><span class="o">+</span><span class="nx">len</span><span class="p">)</span> <span class="p">=</span> <span class="mi">1</span>
</span></span><span class="line"><span class="cl"><span class="o">*</span><span class="p">(</span><span class="nx">ptr</span><span class="o">+</span><span class="nx">len</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span> <span class="p">=</span> <span class="mi">2</span>
</span></span><span class="line"><span class="cl"><span class="o">*</span><span class="p">(</span><span class="nx">ptr</span><span class="o">+</span><span class="nx">len</span><span class="o">+</span><span class="mi">2</span><span class="p">)</span> <span class="p">=</span> <span class="mi">3</span>
</span></span><span class="line"><span class="cl"><span class="k">return</span> <span class="nf">makeslice</span><span class="p">(</span><span class="nx">ptr</span><span class="p">,</span> <span class="nx">newlen</span><span class="p">,</span> <span class="nx">cap</span><span class="p">)</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>首先会解构切片结构体获取它的数组指针、大小和容量，如果在追加元素后切片的大小大于容量，那么就会调用 <code>runtime.growslice </code> 对切片进行扩容并将旧的元素依次加入切片。</p>
<p>如果使用 <code>slice = append(slice, 1, 2, 3)</code> 语句，那么 <code>append</code> 后的新切片会覆盖原切片变量，这时 <code>gc.state.append</code> 方法会使用另一种方式展开关键字：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="line"><span class="cl"><span class="c1">// slice = append(slice, 1, 2, 3)
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="nx">a</span> <span class="o">:=</span> <span class="o">&amp;</span><span class="nx">slice</span>
</span></span><span class="line"><span class="cl"><span class="nx">ptr</span><span class="p">,</span> <span class="nx">len</span><span class="p">,</span> <span class="nx">cap</span> <span class="o">:=</span> <span class="nx">slice</span>
</span></span><span class="line"><span class="cl"><span class="nx">newlen</span> <span class="o">:=</span> <span class="nx">len</span> <span class="o">+</span> <span class="mi">3</span>
</span></span><span class="line"><span class="cl"><span class="k">if</span> <span class="nb">uint</span><span class="p">(</span><span class="nx">newlen</span><span class="p">)</span> <span class="p">&gt;</span> <span class="nb">uint</span><span class="p">(</span><span class="nx">cap</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">   <span class="nx">newptr</span><span class="p">,</span> <span class="nx">len</span><span class="p">,</span> <span class="nx">newcap</span> <span class="p">=</span> <span class="nf">growslice</span><span class="p">(</span><span class="nx">slice</span><span class="p">,</span> <span class="nx">newlen</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">   <span class="nf">vardef</span><span class="p">(</span><span class="nx">a</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">   <span class="o">*</span><span class="nx">a</span><span class="p">.</span><span class="nx">cap</span> <span class="p">=</span> <span class="nx">newcap</span>
</span></span><span class="line"><span class="cl">   <span class="o">*</span><span class="nx">a</span><span class="p">.</span><span class="nx">ptr</span> <span class="p">=</span> <span class="nx">newptr</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="nx">newlen</span> <span class="p">=</span> <span class="nx">len</span> <span class="o">+</span> <span class="mi">3</span>
</span></span><span class="line"><span class="cl"><span class="o">*</span><span class="nx">a</span><span class="p">.</span><span class="nx">len</span> <span class="p">=</span> <span class="nx">newlen</span>
</span></span><span class="line"><span class="cl"><span class="o">*</span><span class="p">(</span><span class="nx">ptr</span><span class="o">+</span><span class="nx">len</span><span class="p">)</span> <span class="p">=</span> <span class="mi">1</span>
</span></span><span class="line"><span class="cl"><span class="o">*</span><span class="p">(</span><span class="nx">ptr</span><span class="o">+</span><span class="nx">len</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span> <span class="p">=</span> <span class="mi">2</span>
</span></span><span class="line"><span class="cl"><span class="o">*</span><span class="p">(</span><span class="nx">ptr</span><span class="o">+</span><span class="nx">len</span><span class="o">+</span><span class="mi">2</span><span class="p">)</span> <span class="p">=</span> <span class="mi">3</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>它与前面逻辑最大的区别在于得到的新切片是否会赋值给原变量，首先会定义一个 a 临时变量，它指向的就是原切片，然后获取原切片的数组指针、大小和容量，如果扩容后的大小大于原cap就会发生扩容并更新原切片的cap和指针为新切片，无论是否发生扩容都会更新len和元素数据。</p>
<p>如果选择覆盖原有变量就不需要担心切片发生拷贝影响性能，编译期对这种常见情况进行了优化。</p>
<p>当切片的容量不足时，我们会调用 <code>runtime.growslice</code> 函数为切片扩容，扩容是为切片分配新的内存空间并拷贝原切片中元素的过程，在分配内存空间之前需要先缺点新的切片容量，运行时根据切片的当前容量选择不同的策略进行扩容 (go 1.18版本及以后更新的扩容机制)：</p>
<ol>
<li>如果当前容量扩大两倍后依然小于期望容量就会直接使用期望容量；</li>
<li>如果当前切片的长度小于 256 就会将容量翻倍；</li>
<li>如果当前切片的长度大于 256 就会每次以 <code>newcap += (newcap + 3*256) / 4</code> 的方式缓慢增长，直到新容量大于期望容量；之前版本中超过了阈值之后，基本为恒定的1.25倍增长，而现在超过了阈值之后，增长比例是会动态调整的，增长比例会从2倍逐渐向1.25倍靠拢。</li>
</ol>
<p>但是这仅仅会确定切片的大致容量，下面还需要根据切片中的元素大小进行内存对齐，<a class="link" href="https://github.com/golang/go/blob/ac0ba6707c1655ea4316b41d06571a0303cc60eb/src/runtime/msize.go#L13"  target="_blank" rel="noopener"
    ><code>runtime.roundupsize</code></a> 函数会将<strong>待申请的内存向上取整</strong>，取整时会使用 <a class="link" href="https://github.com/golang/go/blob/b634f5d97a6e65f19057c00ed2095a1a872c7fa8/src/runtime/sizeclasses.go#L84"  target="_blank" rel="noopener"
    ><code>runtime.class_to_size</code></a> 数组()，使用该数组中的整数可以提高内存的分配效率并减少内存碎片。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">var class_to_size = [_NumSizeClasses]uint16{0, 8, 16, 24, 32, 48, 64, ...}
</span></span></code></pre></td></tr></table>
</div>
</div><p>我们申请内存时，内存管理模块会根据这个数组帮我们匹配到足够大且最接近的规格，比如切片要申请40字节，但是没有这个规模的，就会申请到48字节。</p>
<p>如果计算新容量时发生了内存溢出或者请求的内存超过了上限就会发生panic 退出程序。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="line"><span class="cl"><span class="kd">var</span> <span class="nx">arr</span> <span class="p">[]</span><span class="kt">int64</span>
</span></span><span class="line"><span class="cl"><span class="nx">arr</span> <span class="p">=</span> <span class="nb">append</span><span class="p">(</span><span class="nx">arr</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">5</span><span class="p">)</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>当我们执行上述代码时，会触发 <code>runtime.growslice</code> 函数扩容 <code>arr</code> 切片并传入期望的新容量 5，int64占8字节，所以这时期望分配的内存大小为 40 字节；由于没有这个字节规模，考虑到内存对齐，运行时会调用 <a class="link" href="https://github.com/golang/go/blob/ac0ba6707c1655ea4316b41d06571a0303cc60eb/src/runtime/msize.go#L13"  target="_blank" rel="noopener"
    ><code>runtime.roundupsize</code></a>向上取整内存的大小到 48 字节，所以新切片的容量为 48 / 8 = 6。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="line"><span class="cl">    <span class="c1">// a 底层是一个slice结构体，此时len=4 cap=8，len和cap只会在make和append时发生修改
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="nx">a</span> <span class="o">:=</span> <span class="nb">make</span><span class="p">([]</span><span class="kt">int</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">8</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">    <span class="c1">// b 是另一个slice结构体，此时len=7 cap=8，由于没有超过cap，不会扩容，ab指向的依然是相同的底层数组
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="nx">b</span> <span class="o">:=</span> <span class="nb">append</span><span class="p">(</span><span class="nx">a</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">3</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">    <span class="c1">// a根据a扩容，由于a记录的len为4，因此会从第5个数扩容，那么3就会变成4，而不是从第8位开始
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1">// 源码append函数是根据SliceHeader结构的len来进行扩容赋值的
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1">//  newlen = len + 3
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1">// *a.len = newlen
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1">// *(ptr+len) = 1
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1">// *(ptr+len+1) = 2
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1">// *(ptr+len+2) = 3
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="nx">a</span> <span class="p">=</span> <span class="nb">append</span><span class="p">(</span><span class="nx">a</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">4</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">    <span class="nb">println</span><span class="p">(</span><span class="nx">b</span><span class="p">)</span>
</span></span></code></pre></td></tr></table>
</div>
</div><h4 id="拷贝切片">拷贝切片</h4>
<p>当我们使用 <code>copy(a, b)</code> 的形式对切片进行拷贝时，编译期间的 <a class="link" href="https://github.com/golang/go/blob/ac0ba6707c1655ea4316b41d06571a0303cc60eb/src/cmd/compile/internal/gc/walk.go#L3093"  target="_blank" rel="noopener"
    ><code>cmd/compile/internal/gc.copyany</code></a> 也会分两种情况处理拷贝操作，如果当前 <code>copy</code> 不是在运行时调用的，<code>copy(a, b)</code> 会被直接转换成下面的代码 (常用的拷贝情况)：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="line"><span class="cl"><span class="nx">n</span> <span class="o">:=</span> <span class="nb">len</span><span class="p">(</span><span class="nx">a</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="k">if</span> <span class="nx">n</span> <span class="p">&gt;</span> <span class="nb">len</span><span class="p">(</span><span class="nx">b</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="nx">n</span> <span class="p">=</span> <span class="nb">len</span><span class="p">(</span><span class="nx">b</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="k">if</span> <span class="nx">a</span><span class="p">.</span><span class="nx">ptr</span> <span class="o">!=</span> <span class="nx">b</span><span class="p">.</span><span class="nx">ptr</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="nf">memmove</span><span class="p">(</span><span class="nx">a</span><span class="p">.</span><span class="nx">ptr</span><span class="p">,</span> <span class="nx">b</span><span class="p">.</span><span class="nx">ptr</span><span class="p">,</span> <span class="nx">n</span><span class="o">*</span><span class="nf">sizeof</span><span class="p">(</span><span class="nf">elem</span><span class="p">(</span><span class="nx">a</span><span class="p">)))</span> 
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>上述代码中的 <code>runtime.memmove</code> 会负责拷贝内存。而如果拷贝是在运行时发生的，例如：<code>go copy(a, b)</code> (根据go关键字的特性可以知道，copy函数会先获取ab的值，执行到时才会调用具体函数)，编译器会使用 <code>runtime.slicecopy </code>替换运行期间调用的 <code>copy</code>。</p>
<p>无论是在编译期间拷贝还是运行时拷贝，两种拷贝方式都会通过 <code>runtime.memmove</code> 函数将整块内存的内容拷贝到目标的内存区域中。相比于依次拷贝元素，<code>runtime.memmove</code> 能够提供更好的性能。不过需要注意的是，整块拷贝内存仍然会占用非常多的资源，对大切片进行拷贝操作时一定要注意对性能的影响。</p>
<p>扩容切片时如果容量不够也会使用 <code>runtime.memmove</code> 将原切片拷贝至扩容后的新切片，然后再依次加入要新增的元素。</p>
<p>切片的很多功能都是在运行时执行的，无论是初始化切片，还是对切片进行追加和扩容都是需要运行时的支持的，因此在遇见大切片扩容或者拷贝时就可能会发生大规模的内存拷贝，一定要减少类似操作（如提前设置容量避免扩容时容量不够发生切片拷贝），避免影响程序性能。</p>
<h3 id="哈希表">哈希表</h3>
<p>哈希是除了数组之外最常见的数据结构，它表示的是键值对之间的映射关系。它是计算机科学中最重要的数据结构之一，这不仅因为它 O(1) 的读写性能非常优秀，还因为它提供了键值之间的映射。想要实现一个性能优异的哈希表，需要注意两个关键点 —— 哈希函数和冲突解决方法。</p>
<h4 id="设计原理">设计原理</h4>
<h5 id="哈希函数">哈希函数</h5>
<p>实现哈希表的关键点在于哈希函数的选择，哈希函数的选择在很大程度上能够决定哈希表的读写性能。在理想情况下，哈希函数应该能够将不同键映射到不同的索引上，这要求 <strong>哈希函数的输出范围（取)大于输入范围（存)</strong> ，但是由于键的数量会远远大于能映射的范围，所以在实际使用时，这个理想的效果是不可能实现的。</p>
<p>比较实际的方式是让哈希函数的结果能够尽可能的均匀分布，然后通过工程上的手段解决哈希碰撞的问题。哈希函数映射的结果一定要尽可能均匀，结果不均匀的哈希函数会带来更多的哈希冲突以及更差的读写性能。</p>
<p>如果使用结果分布较为均匀的哈希函数，那么哈希的增删改查的时间复杂度为 <strong>O</strong>(<strong>1</strong>)；但是如果哈希函数的结果分布不均匀，那么所有操作的时间复杂度可能会达到 <strong>O</strong>(<strong>n</strong>) （查询任何一个值都会遍历一遍map)，由此看来，使用好的哈希函数是至关重要的。</p>
<h5 id="解决冲突">解决冲突</h5>
<p>在通常情况下，哈希函数输入的范围一定会远远大于输出的范围，所以在使用哈希表时一定会遇到冲突，哪怕我们使用了完美的哈希函数，当输入的键足够多也会产生冲突。然而多数的哈希函数都是不够完美的，所以仍然存在发生哈希碰撞的可能，这时就需要一些方法来解决哈希碰撞的问题，常见方法的就是开放寻址法和拉链法。</p>
<blockquote>
<p>需要注意的是，这里提到的哈希碰撞不一定是多个键对应的哈希完全相等，可能是多个哈希的部分相等，例如：两个键对应哈希的前四个字节相同。</p>
</blockquote>
<h6 id="开放寻址法">开放寻址法</h6>
<p>这种方法的核心思想是 <strong>依次 探测和比较 底层数组中的元素 来判断目标键值对是否存在于哈希表中</strong> ，如果我们使用开放寻址法来实现哈希表，那么实现哈希表底层的数据结构就是数组，不过因为数组的长度有限，向哈希表写入 [ author, draven] 这个键值对时会从如下的索引开始遍历：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="line"><span class="cl"><span class="nx">index</span> <span class="o">:=</span> <span class="nf">hash</span><span class="p">(</span><span class="s">&#34;author&#34;</span><span class="p">)</span> <span class="o">%</span> <span class="nx">array</span><span class="p">.</span><span class="nx">len</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>当我们向当前哈希表写入新的数据时，如果发生了冲突，就会将键值对写入到下一个内存为空的位置。如果向下遍历时发现这个key存在就会修改其值。当我们读取数据时，就会先获取键的哈希并取模，如果获取到的索引对应的key与比对的key不相等，就会继续查找后面的元素，直到找到目标元素或者内存为空。</p>
<p>开放寻址法中对性能影响最大的是 负<strong>载因子</strong> ，它是数组中元素的数量与数组大小的比值。随着负载因子的增加，线性探测的平均用时就会逐渐增加（碰撞几率增加导致每次查询需要向后移动查询的次数增加)，这会影响哈希表的读写性能。当负载率超过 70% 之后，哈希表的性能就会急剧下降，而一旦负载率达到 100%，整个哈希表就会完全失效，这时查找和插入任意元素的时间复杂度都是 <strong>O</strong>(<strong>n</strong>) ，这时需要遍历数组中的全部元素，所以在实现哈希表时一定要关注负载因子的变化。</p>
<h6 id="拉链法">拉链法</h6>
<p>与开放寻址法相比，拉链法才是哈希表最常见的实现方法，大多数编程语言都是用拉链法来实现哈希表，它的实现比较开放寻址法稍微复杂一些，但是平均查找的长度也比较短，各个用于存储节点的内存都是动态申请的，可以节省比较多的存储空间（拉链的形式，发生冲突时才会申请内存存储冲突kv)。</p>
<p>实现拉链法一般会使用数组加上链表，不过一些编程语言会在拉链法的哈希中引入红黑树以优化性能，拉链法会使用链表数组作为哈希底层的数据结构，我们可以将它看成可以扩展的二维数组：
<img src="/p/go-%E8%AF%AD%E8%A8%80%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0%E8%AF%BB%E5%90%8E%E7%90%86%E8%A7%A3/media/image-2.png"
	width="1200"
	height="630"
	srcset="/p/go-%E8%AF%AD%E8%A8%80%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0%E8%AF%BB%E5%90%8E%E7%90%86%E8%A7%A3/media/image-2_hu317b262f90599d075b7c6aae3bb455b6_34692_480x0_resize_box_3.png 480w, /p/go-%E8%AF%AD%E8%A8%80%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0%E8%AF%BB%E5%90%8E%E7%90%86%E8%A7%A3/media/image-2_hu317b262f90599d075b7c6aae3bb455b6_34692_1024x0_resize_box_3.png 1024w"
	loading="lazy"
	
		alt="image2.png"
	
	
		class="gallery-image" 
		data-flex-grow="190"
		data-flex-basis="457px"
	
></p>
<p>如上图所示，当我们需要将一个键值对 (Key6, Value6) 写入哈希表时，键值对中的键 Key6 都会先经过一个哈希函数，哈希函数返回的哈希会帮助我们选择一个桶，和开放寻址法一样，选择桶的方式是直接对哈希返回的结果取模：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="line"><span class="cl"><span class="nx">index</span> <span class="o">:=</span> <span class="nf">hash</span><span class="p">(</span><span class="s">&#34;Key6&#34;</span><span class="p">)</span> <span class="o">%</span> <span class="nx">array</span><span class="p">.</span><span class="nx">len</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>选择了 2 号桶后就可以遍历当前桶中的链表了，在遍历链表的过程中会遇到以下两种情况：</p>
<ol>
<li>找到键相同的键值对 — 更新键对应的值；</li>
<li>没有找到键相同的键值对 — 在链表的末尾追加新的键值对；</li>
</ol>
<p>如果要在哈希表中获取某个键对应的值，首先取模命中相应的桶，然后依次遍历桶中的链表，遍历到相同key则返回值，如果遍历到链表的末尾也没有找到期望的键，就表示哈希表中没有该键对应的值。</p>
<p>在一个性能比较好的哈希表中，每一个桶中都应该有 0 ～ 1 个元素，有时会有 2 ~ 3 个，很少会超过这个数量。计算哈希、定位桶和遍历链表三个过程是哈希表读写操作的主要开销，使用拉链法实现的哈希也有装载因子这一概念：</p>
<blockquote>
<p>装载因子 <strong>:=元素数量</strong> ÷桶数量</p>
</blockquote>
<p>与开放地址法一样，拉链法的装载因子越大，哈希的读写性能就越差。在一般情况下使用拉链法的哈希表装载因子都不会超过 1，当哈希表的装载因子较大时会触发哈希的扩容，创建更多的桶来存储哈希中的元素，保证性能不会出现严重的下降。如果有 1000 个桶的哈希表存储了 10000 个键值对，它的性能是保存 1000 个键值对的 1/10，但是仍然比在链表中直接读写好 1000 倍 (从1000个桶里面读取10000个数据，最差读取一个数据需要链表查10次，而直接从链表中读取数据，最差需要链表查10000次，每个数据都要查询，因此比链表直接读写好1000 倍)。</p>
<h4 id="数据结构-2">数据结构</h4>
<p>Go语言运行时同时使用了</p>
<p>Go 语言运行时同时使用了多个数据结构组合来表示哈希表，其中 <a class="link" href="https://github.com/golang/go/blob/41d8e61a6b9d8f9db912626eb2bbc535e929fefc/src/runtime/map.go#L115"  target="_blank" rel="noopener"
    ><code>runtime.hmap</code></a> 是最核心的结构体：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="line"><span class="cl"><span class="kd">type</span> <span class="nx">hmap</span> <span class="kd">struct</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">	<span class="nx">count</span>     <span class="kt">int</span>
</span></span><span class="line"><span class="cl">	<span class="nx">flags</span>     <span class="kt">uint8</span>
</span></span><span class="line"><span class="cl">	<span class="nx">B</span>         <span class="kt">uint8</span>
</span></span><span class="line"><span class="cl">	<span class="nx">noverflow</span> <span class="kt">uint16</span>
</span></span><span class="line"><span class="cl">	<span class="nx">hash0</span>     <span class="kt">uint32</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">	<span class="nx">buckets</span>    <span class="nx">unsafe</span><span class="p">.</span><span class="nx">Pointer</span>
</span></span><span class="line"><span class="cl">	<span class="nx">oldbuckets</span> <span class="nx">unsafe</span><span class="p">.</span><span class="nx">Pointer</span>
</span></span><span class="line"><span class="cl">	<span class="nx">nevacuate</span>  <span class="kt">uintptr</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">	<span class="nx">extra</span> <span class="o">*</span><span class="nx">mapextra</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kd">type</span> <span class="nx">mapextra</span> <span class="kd">struct</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">	<span class="nx">overflow</span>    <span class="o">*</span><span class="p">[]</span><span class="o">*</span><span class="nx">bmap</span>
</span></span><span class="line"><span class="cl">	<span class="nx">oldoverflow</span> <span class="o">*</span><span class="p">[]</span><span class="o">*</span><span class="nx">bmap</span>
</span></span><span class="line"><span class="cl">	<span class="nx">nextOverflow</span> <span class="o">*</span><span class="nx">bmap</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div><ol>
<li><code>count</code> 表示当前哈希表中的元素数量；</li>
<li><code>B</code> 表示当前哈希表持有的 <code>buckets</code> 数量，但是因为哈希表中桶的数量都 2 的倍数，所以该字段会存储对数，也就是 <code>len(buckets) == 2^B</code>；</li>
<li><code>hash0</code> 是哈希的种子，它能为哈希函数的结果引入随机性，这个值在创建哈希表时确定，并在调用哈希函数时作为参数传入；</li>
<li><code>oldbuckets</code> 是哈希在扩容时用于保存之前 <code>buckets</code> 的字段；</li>
<li><code>noverflow</code> 为map中溢出桶的数量。当溢出桶太多时，map 会进行 same-size map growth，其实质是避免桶过大导致内存泄露。<code>extra</code> 存储map中的溢出桶；</li>
<li><code>nevacuate</code> 表示扩容进度，小于此地址的 <code>buckets</code> 迁移完成</li>
</ol>
<p>哈希表 <code>runtime.hmap</code> 的桶是 <code>runtime.bmap</code>。每一个 <code>runtime.bmap</code> 都能存储8个键值对，当哈希表中存储的数据过多时，单个桶已经装满就会使用 <code>extra.nextOverflow</code> 中的桶来存储溢出的数据。</p>
<p>上面两种不同的桶在内存中是连续存储的（即底层是一个数组，正常桶集和排列，然后溢出桶集和排列），它们分别被称为正常桶和溢出桶，溢出桶是在Go语言还使用C语言实现时使用的设计，由于它能够减少扩容的频率所以一直使用至今。</p>
<p><code>runtime.bmap</code> 在go源代码中的定义只包含一个简单的 <code>tophash</code> 字段，它存储了键的哈希的高8位，通过比较不同键的哈希的高8位可以减少访问键值对次数以提高性能（从判断键整体的不同变为了先判断高8位，符合再继续判断）。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="line"><span class="cl"><span class="kd">type</span> <span class="nx">bmap</span> <span class="kd">struct</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">	<span class="nx">tophash</span> <span class="p">[</span><span class="nx">bucketCnt</span><span class="p">]</span><span class="kt">uint8</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>随着哈希表存储的数据逐渐增多，我们会扩容哈希表或者使用溢出桶来存储溢出的数据，不会让单个桶中的数据超过8个，不过溢出桶只是临时的解决方案，创建过多的溢出桶最终也会导致哈希的扩容（溢出桶以链表的形式存在，不扩容的话，查询的速率就会变的非常慢）。</p>
<h4 id="初始化-2">初始化</h4>
<h5 id="字面量-1">字面量</h5>
<p>现代的编程语言基本都支持使用字面量的方式来初始化哈希，一般都会使用 <code>key: value</code> 的语法来表示键值对，Go 语言中也不例外：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="line"><span class="cl"><span class="nx">hash</span> <span class="o">:=</span> <span class="kd">map</span><span class="p">[</span><span class="kt">string</span><span class="p">]</span><span class="kt">int</span><span class="p">{</span>
</span></span><span class="line"><span class="cl">	<span class="s">&#34;1&#34;</span><span class="p">:</span> <span class="mi">2</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">	<span class="s">&#34;3&#34;</span><span class="p">:</span> <span class="mi">4</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">	<span class="s">&#34;5&#34;</span><span class="p">:</span> <span class="mi">6</span><span class="p">,</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>我们需要在初始化哈希时声明键值对的类型，这种使用字面量初始化的方式最终都会通过 <a class="link" href="https://github.com/golang/go/blob/ac0ba6707c1655ea4316b41d06571a0303cc60eb/src/cmd/compile/internal/gc/sinit.go#L753"  target="_blank" rel="noopener"
    ><code>cmd/compile/internal/gc.maplit</code></a> 初始化，我们来分析一下该函数初始化哈希的过程：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="line"><span class="cl"><span class="kd">func</span> <span class="nf">maplit</span><span class="p">(</span><span class="nx">n</span> <span class="o">*</span><span class="nx">Node</span><span class="p">,</span> <span class="nx">m</span> <span class="o">*</span><span class="nx">Node</span><span class="p">,</span> <span class="nx">init</span> <span class="o">*</span><span class="nx">Nodes</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">	<span class="nx">a</span> <span class="o">:=</span> <span class="nf">nod</span><span class="p">(</span><span class="nx">OMAKE</span><span class="p">,</span> <span class="kc">nil</span><span class="p">,</span> <span class="kc">nil</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">	<span class="nx">a</span><span class="p">.</span><span class="nx">Esc</span> <span class="p">=</span> <span class="nx">n</span><span class="p">.</span><span class="nx">Esc</span>
</span></span><span class="line"><span class="cl">	<span class="nx">a</span><span class="p">.</span><span class="nx">List</span><span class="p">.</span><span class="nf">Set2</span><span class="p">(</span><span class="nf">typenod</span><span class="p">(</span><span class="nx">n</span><span class="p">.</span><span class="nx">Type</span><span class="p">),</span> <span class="nf">nodintconst</span><span class="p">(</span><span class="nb">int64</span><span class="p">(</span><span class="nx">n</span><span class="p">.</span><span class="nx">List</span><span class="p">.</span><span class="nf">Len</span><span class="p">())))</span>
</span></span><span class="line"><span class="cl">	<span class="nf">litas</span><span class="p">(</span><span class="nx">m</span><span class="p">,</span> <span class="nx">a</span><span class="p">,</span> <span class="nx">init</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">	<span class="nx">entries</span> <span class="o">:=</span> <span class="nx">n</span><span class="p">.</span><span class="nx">List</span><span class="p">.</span><span class="nf">Slice</span><span class="p">()</span>
</span></span><span class="line"><span class="cl">	<span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="nx">entries</span><span class="p">)</span> <span class="p">&gt;</span> <span class="mi">25</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">		<span class="o">...</span>
</span></span><span class="line"><span class="cl">		<span class="k">return</span>
</span></span><span class="line"><span class="cl">	<span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">	<span class="c1">// Build list of var[c] = expr.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="c1">// Use temporaries so that mapassign1 can have addressable key, elem.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="o">...</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>当哈希表中的元素数量少于或者等于25个时，编译器会将字面量初始化的结构体转换成以下的代码，将所有的键值对一次性加入到哈希表中：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="line"><span class="cl"><span class="nx">hash</span> <span class="o">:=</span> <span class="nb">make</span><span class="p">(</span><span class="kd">map</span><span class="p">[</span><span class="kt">string</span><span class="p">]</span><span class="kt">int</span><span class="p">,</span> <span class="mi">3</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="nx">hash</span><span class="p">[</span><span class="s">&#34;1&#34;</span><span class="p">]</span> <span class="p">=</span> <span class="mi">2</span>
</span></span><span class="line"><span class="cl"><span class="nx">hash</span><span class="p">[</span><span class="s">&#34;3&#34;</span><span class="p">]</span> <span class="p">=</span> <span class="mi">4</span>
</span></span><span class="line"><span class="cl"><span class="nx">hash</span><span class="p">[</span><span class="s">&#34;5&#34;</span><span class="p">]</span> <span class="p">=</span> <span class="mi">6</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>这种初始化字面量的方式与数组和切片几乎完全相同，由此看来集和类型的初始化在Go 语言中有着相同的处理逻辑。</p>
<p>但是一旦哈希表中的元素数量超过25个，编译器会创建两个数组分别存储键和值，这些键值对会通过如下所示的for循环加入哈希：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="line"><span class="cl"><span class="nx">hash</span> <span class="o">:=</span> <span class="nb">make</span><span class="p">(</span><span class="kd">map</span><span class="p">[</span><span class="kt">string</span><span class="p">]</span><span class="kt">int</span><span class="p">,</span> <span class="mi">26</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="nx">vstatk</span> <span class="o">:=</span> <span class="p">[]</span><span class="kt">string</span><span class="p">{</span><span class="s">&#34;1&#34;</span><span class="p">,</span> <span class="s">&#34;2&#34;</span><span class="p">,</span> <span class="s">&#34;3&#34;</span><span class="p">,</span> <span class="o">...</span> <span class="err">，</span> <span class="s">&#34;26&#34;</span><span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="nx">vstatv</span> <span class="o">:=</span> <span class="p">[]</span><span class="kt">int</span><span class="p">{</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="o">...</span> <span class="p">,</span> <span class="mi">26</span><span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="k">for</span> <span class="nx">i</span> <span class="o">:=</span> <span class="mi">0</span><span class="p">;</span> <span class="nx">i</span> <span class="p">&lt;</span> <span class="nb">len</span><span class="p">(</span><span class="nx">vstak</span><span class="p">);</span> <span class="nx">i</span><span class="o">++</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="nx">hash</span><span class="p">[</span><span class="nx">vstatk</span><span class="p">[</span><span class="nx">i</span><span class="p">]]</span> <span class="p">=</span> <span class="nx">vstatv</span><span class="p">[</span><span class="nx">i</span><span class="p">]</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>这里的 <code>vstatk</code> 和 <code>vstatv</code> 还会根据切片字面量的初始化被编辑器继续展开。无论哈希使用哪种方法，使用字面量初始化的过程都会使用Go 语言中的关键字 <code>make</code> 来创建新的哈希并通过最原始的 <code>[ ]</code> 语法向哈希表中追加元素。</p>
<h5 id="运行时">运行时</h5>
<p>当创建的哈希被分配到栈上并且其桶容量小于 <code>BUCKETSIZE = 8</code> 时，Go 语言会在编译阶段使用如下方式快速初始化哈希，这也是编译器对小容量哈希做的优化：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="line"><span class="cl"><span class="kd">var</span> <span class="nx">h</span> <span class="o">*</span><span class="nx">hmap</span>
</span></span><span class="line"><span class="cl"><span class="kd">var</span> <span class="nx">hv</span> <span class="nx">hmap</span>
</span></span><span class="line"><span class="cl"><span class="kd">var</span> <span class="nx">bv</span> <span class="nx">bmap</span>
</span></span><span class="line"><span class="cl"><span class="nx">h</span> <span class="o">:=</span> <span class="o">&amp;</span><span class="nx">hv</span>
</span></span><span class="line"><span class="cl"><span class="nx">b</span> <span class="o">:=</span> <span class="o">&amp;</span><span class="nx">bv</span>
</span></span><span class="line"><span class="cl"><span class="nx">h</span><span class="p">.</span><span class="nx">buckets</span> <span class="p">=</span> <span class="nx">b</span>
</span></span><span class="line"><span class="cl"><span class="nx">h</span><span class="p">.</span><span class="nx">hash0</span> <span class="p">=</span> <span class="nf">fashtrand0</span><span class="p">()</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>除了上述特定的优化之外，无论 <code>make</code> 是从哪里来的，只要我们使用 <code>make</code> 创建哈希，Go 语言编译器都会在类型检查期间将它们转换成 <a class="link" href="https://github.com/golang/go/blob/ac0ba6707c1655ea4316b41d06571a0303cc60eb/src/runtime/map.go#L303"  target="_blank" rel="noopener"
    ><code>runtime.makemap</code></a>，使用字面量初始化哈希也只是语言提供的辅助工具，最后调用的都是 <a class="link" href="https://github.com/golang/go/blob/ac0ba6707c1655ea4316b41d06571a0303cc60eb/src/runtime/map.go#L303"  target="_blank" rel="noopener"
    ><code>runtime.makemap</code></a>：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="line"><span class="cl"><span class="kd">func</span> <span class="nf">makemap</span><span class="p">(</span><span class="nx">t</span> <span class="o">*</span><span class="nx">maptype</span><span class="p">,</span> <span class="nx">hint</span> <span class="kt">int</span><span class="p">,</span> <span class="nx">h</span> <span class="o">*</span><span class="nx">hmap</span><span class="p">)</span> <span class="o">*</span><span class="nx">hmap</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">	<span class="nx">mem</span><span class="p">,</span> <span class="nx">overflow</span> <span class="o">:=</span> <span class="nx">math</span><span class="p">.</span><span class="nf">MulUintptr</span><span class="p">(</span><span class="nb">uintptr</span><span class="p">(</span><span class="nx">hint</span><span class="p">),</span> <span class="nx">t</span><span class="p">.</span><span class="nx">bucket</span><span class="p">.</span><span class="nx">size</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">	<span class="k">if</span> <span class="nx">overflow</span> <span class="o">||</span> <span class="nx">mem</span> <span class="p">&gt;</span> <span class="nx">maxAlloc</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">		<span class="nx">hint</span> <span class="p">=</span> <span class="mi">0</span>
</span></span><span class="line"><span class="cl">	<span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">	<span class="k">if</span> <span class="nx">h</span> <span class="o">==</span> <span class="kc">nil</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">		<span class="nx">h</span> <span class="p">=</span> <span class="nb">new</span><span class="p">(</span><span class="nx">hmap</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">	<span class="p">}</span>
</span></span><span class="line"><span class="cl">	<span class="nx">h</span><span class="p">.</span><span class="nx">hash0</span> <span class="p">=</span> <span class="nf">fastrand</span><span class="p">()</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">	<span class="nx">B</span> <span class="o">:=</span> <span class="nb">uint8</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">	<span class="k">for</span> <span class="nf">overLoadFactor</span><span class="p">(</span><span class="nx">hint</span><span class="p">,</span> <span class="nx">B</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">		<span class="nx">B</span><span class="o">++</span>
</span></span><span class="line"><span class="cl">	<span class="p">}</span>
</span></span><span class="line"><span class="cl">	<span class="nx">h</span><span class="p">.</span><span class="nx">B</span> <span class="p">=</span> <span class="nx">B</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">	<span class="k">if</span> <span class="nx">h</span><span class="p">.</span><span class="nx">B</span> <span class="o">!=</span> <span class="mi">0</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">		<span class="kd">var</span> <span class="nx">nextOverflow</span> <span class="o">*</span><span class="nx">bmap</span>
</span></span><span class="line"><span class="cl">		<span class="nx">h</span><span class="p">.</span><span class="nx">buckets</span><span class="p">,</span> <span class="nx">nextOverflow</span> <span class="p">=</span> <span class="nf">makeBucketArray</span><span class="p">(</span><span class="nx">t</span><span class="p">,</span> <span class="nx">h</span><span class="p">.</span><span class="nx">B</span><span class="p">,</span> <span class="kc">nil</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">		<span class="k">if</span> <span class="nx">nextOverflow</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">			<span class="nx">h</span><span class="p">.</span><span class="nx">extra</span> <span class="p">=</span> <span class="nb">new</span><span class="p">(</span><span class="nx">mapextra</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">			<span class="nx">h</span><span class="p">.</span><span class="nx">extra</span><span class="p">.</span><span class="nx">nextOverflow</span> <span class="p">=</span> <span class="nx">nextOverflow</span>
</span></span><span class="line"><span class="cl">		<span class="p">}</span>
</span></span><span class="line"><span class="cl">	<span class="p">}</span>
</span></span><span class="line"><span class="cl">	<span class="k">return</span> <span class="nx">h</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>这个函数会按照下面的步骤执行：</p>
<ol>
<li>计算哈希占用的内存是否会溢出或者超出能分配的最大值；</li>
<li>调用 <code>runtime.fastrand()</code> 获取一个随机的哈希种子；</li>
<li>根据传入的 <code>hint</code> 计算出需要的最小需要的桶的数量；</li>
<li>使用 <code>runtime.makeBucketArray</code> 创建用于保存桶的数组；</li>
</ol>
<p><a class="link" href="https://github.com/golang/go/blob/ac0ba6707c1655ea4316b41d06571a0303cc60eb/src/runtime/map.go#L344"  target="_blank" rel="noopener"
    ><code>runtime.makeBucketArray</code></a> 会根据传入的B 计算出需要创建的桶数量并在内存中分配一片连续的空间用于存储数据。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="line"><span class="cl"><span class="kd">func</span> <span class="nf">makeBucketArray</span><span class="p">(</span><span class="nx">t</span> <span class="o">*</span><span class="nx">maptype</span><span class="p">,</span> <span class="nx">b</span> <span class="kt">uint8</span><span class="p">,</span> <span class="nx">dirtyalloc</span> <span class="nx">unsafe</span><span class="p">.</span><span class="nx">Pointer</span><span class="p">)</span> <span class="p">(</span><span class="nx">buckets</span> <span class="nx">unsafe</span><span class="p">.</span><span class="nx">Pointer</span><span class="p">,</span> <span class="nx">nextOverflow</span> <span class="o">*</span><span class="nx">bmap</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">	<span class="nx">base</span> <span class="o">:=</span> <span class="nf">bucketShift</span><span class="p">(</span><span class="nx">b</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">	<span class="nx">nbuckets</span> <span class="o">:=</span> <span class="nx">base</span>
</span></span><span class="line"><span class="cl">	<span class="k">if</span> <span class="nx">b</span> <span class="o">&gt;=</span> <span class="mi">4</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">		<span class="nx">nbuckets</span> <span class="o">+=</span> <span class="nf">bucketShift</span><span class="p">(</span><span class="nx">b</span> <span class="o">-</span> <span class="mi">4</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">		<span class="nx">sz</span> <span class="o">:=</span> <span class="nx">t</span><span class="p">.</span><span class="nx">bucket</span><span class="p">.</span><span class="nx">size</span> <span class="o">*</span> <span class="nx">nbuckets</span>
</span></span><span class="line"><span class="cl">		<span class="nx">up</span> <span class="o">:=</span> <span class="nf">roundupsize</span><span class="p">(</span><span class="nx">sz</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">		<span class="k">if</span> <span class="nx">up</span> <span class="o">!=</span> <span class="nx">sz</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">			<span class="nx">nbuckets</span> <span class="p">=</span> <span class="nx">up</span> <span class="o">/</span> <span class="nx">t</span><span class="p">.</span><span class="nx">bucket</span><span class="p">.</span><span class="nx">size</span>
</span></span><span class="line"><span class="cl">		<span class="p">}</span>
</span></span><span class="line"><span class="cl">	<span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">	<span class="nx">buckets</span> <span class="p">=</span> <span class="nf">newarray</span><span class="p">(</span><span class="nx">t</span><span class="p">.</span><span class="nx">bucket</span><span class="p">,</span> <span class="nb">int</span><span class="p">(</span><span class="nx">nbuckets</span><span class="p">))</span>
</span></span><span class="line"><span class="cl">	<span class="k">if</span> <span class="nx">base</span> <span class="o">!=</span> <span class="nx">nbuckets</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">		<span class="nx">nextOverflow</span> <span class="p">=</span> <span class="p">(</span><span class="o">*</span><span class="nx">bmap</span><span class="p">)(</span><span class="nf">add</span><span class="p">(</span><span class="nx">buckets</span><span class="p">,</span> <span class="nx">base</span><span class="o">*</span><span class="nb">uintptr</span><span class="p">(</span><span class="nx">t</span><span class="p">.</span><span class="nx">bucketsize</span><span class="p">)))</span>
</span></span><span class="line"><span class="cl">		<span class="nx">last</span> <span class="o">:=</span> <span class="p">(</span><span class="o">*</span><span class="nx">bmap</span><span class="p">)(</span><span class="nf">add</span><span class="p">(</span><span class="nx">buckets</span><span class="p">,</span> <span class="p">(</span><span class="nx">nbuckets</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span><span class="o">*</span><span class="nb">uintptr</span><span class="p">(</span><span class="nx">t</span><span class="p">.</span><span class="nx">bucketsize</span><span class="p">)))</span>
</span></span><span class="line"><span class="cl">		<span class="nx">last</span><span class="p">.</span><span class="nf">setoverflow</span><span class="p">(</span><span class="nx">t</span><span class="p">,</span> <span class="p">(</span><span class="o">*</span><span class="nx">bmap</span><span class="p">)(</span><span class="nx">buckets</span><span class="p">))</span>
</span></span><span class="line"><span class="cl">	<span class="p">}</span>
</span></span><span class="line"><span class="cl">	<span class="k">return</span> <span class="nx">buckets</span><span class="p">,</span> <span class="nx">nextOverflow</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div><ul>
<li>当桶的数量小于 2的四次方时( b =4)，由于数据较少、使用溢出桶的可能性较低，会省略创建溢出桶的过程以减少额外开销；</li>
<li>当桶的数量大于等于 2的四次方时，会额外创建 2的 (b-4) 个溢出桶；</li>
</ul>
<p>即无论b是否大于4都会创建正常桶，但是如果b 大于等于4则会额外创建多余的溢出桶。正常桶和溢出桶在内存中的空间是连续的，只是被 <code>runtime.hmap</code> 中的不同字段引用，当溢出桶数量较多时则会通过 <code>runtime.newobject</code> 来扩容创建新的溢出桶。</p>
<h4 id="读写操作">读写操作</h4>
<p>哈希表的访问一般都是通过下标或者遍历进行的：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="line"><span class="cl"><span class="nx">_</span> <span class="p">=</span> <span class="nx">hash</span><span class="p">[</span><span class="nx">key</span><span class="p">]</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="k">for</span> <span class="nx">k</span><span class="p">,</span> <span class="nx">v</span> <span class="o">:=</span> <span class="k">range</span> <span class="nx">hash</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="c1">// k, v
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="p">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>这两种方式虽然都能读取哈希表的数据，但是使用的函数和底层原理完全不同，前者需要知道哈希的键并且一次只能获取单个键对应的值，而后者可以遍历哈希中的全部键值对，访问数据时也不需要预先知道哈希的键，不过它的时间复杂度是ON。</p>
<p>数据结构的写一般指的都是增加、删除和修改，增加和修改字段都是使用索引和赋值语句，而删除字典中的数据需要使用关键字 <code>delete</code>：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="line"><span class="cl"><span class="nx">hash</span><span class="p">[</span><span class="nx">key</span><span class="p">]</span> <span class="p">=</span> <span class="nx">value</span>
</span></span><span class="line"><span class="cl"><span class="nx">hash</span><span class="p">[</span><span class="nx">key</span><span class="p">]</span> <span class="p">=</span> <span class="nx">newValue</span>
</span></span><span class="line"><span class="cl"><span class="nb">delete</span><span class="p">(</span><span class="nx">hash</span><span class="p">,</span> <span class="nx">key</span><span class="p">)</span>
</span></span></code></pre></td></tr></table>
</div>
</div><h5 id="访问">访问</h5>
<p>在编译的类型检查期间，<code>hash[key]</code> 以及类似的操作都会被转换成哈希的 <code>OINDEXMAP</code> 操作，中间代码生成阶段会将这些 <code>OINDEXMAP</code> 操作转换成如下代码：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="line"><span class="cl"><span class="nx">v</span>     <span class="o">:=</span> <span class="nx">hash</span><span class="p">[</span><span class="nx">key</span><span class="p">]</span> <span class="c1">// =&gt; v     := *mapaccess1(maptype, hash, &amp;key)
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="nx">v</span><span class="p">,</span> <span class="nx">ok</span> <span class="o">:=</span> <span class="nx">hash</span><span class="p">[</span><span class="nx">key</span><span class="p">]</span> <span class="c1">// =&gt; v, ok := mapaccess2(maptype, hash, &amp;key)
</span></span></span></code></pre></td></tr></table>
</div>
</div><p>赋值语句左侧接收的参数个数会决定使用的运行时方法：</p>
<ul>
<li>当接收一个参数时，会使用 <code>mapaccess1</code> ，该函数仅会返回一个指向目标值的指针；</li>
<li>当接收两个参数时，会使用 <code>mapaccess2</code> ，除了返回目标值之外，它还会返回一个用于表示当前键对应的值是否存在的布尔值；</li>
</ul>
<p><code>mapaccess1</code> 会先通过哈希表设置的哈希函数、哈希种子获取当前key键对应的哈希，再通过 <code>runtime.bucketMask</code> 和 <code>runtime.add</code> 拿到该键值对所在的桶序号和哈希高位的8位数字。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="line"><span class="cl"><span class="kd">func</span> <span class="nf">mapaccess1</span><span class="p">(</span><span class="nx">t</span> <span class="o">*</span><span class="nx">maptype</span><span class="p">,</span> <span class="nx">h</span> <span class="o">*</span><span class="nx">hmap</span><span class="p">,</span> <span class="nx">key</span> <span class="nx">unsafe</span><span class="p">.</span><span class="nx">Pointer</span><span class="p">)</span> <span class="nx">unsafe</span><span class="p">.</span><span class="nx">Pointer</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">	<span class="nx">alg</span> <span class="o">:=</span> <span class="nx">t</span><span class="p">.</span><span class="nx">key</span><span class="p">.</span><span class="nx">alg</span>
</span></span><span class="line"><span class="cl">	<span class="c1">// 获取hash
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="nx">hash</span> <span class="o">:=</span> <span class="nx">alg</span><span class="p">.</span><span class="nf">hash</span><span class="p">(</span><span class="nx">key</span><span class="p">,</span> <span class="nb">uintptr</span><span class="p">(</span><span class="nx">h</span><span class="p">.</span><span class="nx">hash0</span><span class="p">))</span>
</span></span><span class="line"><span class="cl">	<span class="c1">// 获取桶序号
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="nx">m</span> <span class="o">:=</span> <span class="nf">bucketMask</span><span class="p">(</span><span class="nx">h</span><span class="p">.</span><span class="nx">B</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">	<span class="nx">b</span> <span class="o">:=</span> <span class="p">(</span><span class="o">*</span><span class="nx">bmap</span><span class="p">)(</span><span class="nf">add</span><span class="p">(</span><span class="nx">h</span><span class="p">.</span><span class="nx">buckets</span><span class="p">,</span> <span class="p">(</span><span class="nx">hash</span><span class="o">&amp;</span><span class="nx">m</span><span class="p">)</span><span class="o">*</span><span class="nb">uintptr</span><span class="p">(</span><span class="nx">t</span><span class="p">.</span><span class="nx">bucketsize</span><span class="p">)))</span>
</span></span><span class="line"><span class="cl">	<span class="c1">// 获取高8位
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="nx">top</span> <span class="o">:=</span> <span class="nf">tophash</span><span class="p">(</span><span class="nx">hash</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="nx">bucketloop</span><span class="p">:</span>
</span></span><span class="line"><span class="cl">	<span class="c1">// 依次遍历 b 这个桶链表
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="k">for</span> <span class="p">;</span> <span class="nx">b</span> <span class="o">!=</span> <span class="kc">nil</span><span class="p">;</span> <span class="nx">b</span> <span class="p">=</span> <span class="nx">b</span><span class="p">.</span><span class="nf">overflow</span><span class="p">(</span><span class="nx">t</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">		<span class="c1">// 遍历单个桶，寻找高8位哈希相同的，然后取值
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>		<span class="k">for</span> <span class="nx">i</span> <span class="o">:=</span> <span class="nb">uintptr</span><span class="p">(</span><span class="mi">0</span><span class="p">);</span> <span class="nx">i</span> <span class="p">&lt;</span> <span class="nx">bucketCnt</span><span class="p">;</span> <span class="nx">i</span><span class="o">++</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">			<span class="k">if</span> <span class="nx">b</span><span class="p">.</span><span class="nx">tophash</span><span class="p">[</span><span class="nx">i</span><span class="p">]</span> <span class="o">!=</span> <span class="nx">top</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">				<span class="k">if</span> <span class="nx">b</span><span class="p">.</span><span class="nx">tophash</span><span class="p">[</span><span class="nx">i</span><span class="p">]</span> <span class="o">==</span> <span class="nx">emptyRest</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">					<span class="k">break</span> <span class="nx">bucketloop</span>
</span></span><span class="line"><span class="cl">				<span class="p">}</span>
</span></span><span class="line"><span class="cl">				<span class="k">continue</span>
</span></span><span class="line"><span class="cl">			<span class="p">}</span>
</span></span><span class="line"><span class="cl">			<span class="nx">k</span> <span class="o">:=</span> <span class="nf">add</span><span class="p">(</span><span class="nx">unsafe</span><span class="p">.</span><span class="nf">Pointer</span><span class="p">(</span><span class="nx">b</span><span class="p">),</span> <span class="nx">dataOffset</span><span class="o">+</span><span class="nx">i</span><span class="o">*</span><span class="nb">uintptr</span><span class="p">(</span><span class="nx">t</span><span class="p">.</span><span class="nx">keysize</span><span class="p">))</span>
</span></span><span class="line"><span class="cl">			<span class="k">if</span> <span class="nx">alg</span><span class="p">.</span><span class="nf">equal</span><span class="p">(</span><span class="nx">key</span><span class="p">,</span> <span class="nx">k</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">				<span class="nx">v</span> <span class="o">:=</span> <span class="nf">add</span><span class="p">(</span><span class="nx">unsafe</span><span class="p">.</span><span class="nf">Pointer</span><span class="p">(</span><span class="nx">b</span><span class="p">),</span> <span class="nx">dataOffset</span><span class="o">+</span><span class="nx">bucketCnt</span><span class="o">*</span><span class="nb">uintptr</span><span class="p">(</span><span class="nx">t</span><span class="p">.</span><span class="nx">keysize</span><span class="p">)</span><span class="o">+</span><span class="nx">i</span><span class="o">*</span><span class="nb">uintptr</span><span class="p">(</span><span class="nx">t</span><span class="p">.</span><span class="nx">valuesize</span><span class="p">))</span>
</span></span><span class="line"><span class="cl">				<span class="k">return</span> <span class="nx">v</span>
</span></span><span class="line"><span class="cl">			<span class="p">}</span>
</span></span><span class="line"><span class="cl">		<span class="p">}</span>
</span></span><span class="line"><span class="cl">	<span class="p">}</span>
</span></span><span class="line"><span class="cl">	<span class="c1">// 返回对应类型的零值
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="k">return</span> <span class="nx">unsafe</span><span class="p">.</span><span class="nf">Pointer</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">zeroVal</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>在 <code>bucketloop</code> 循环中，哈希会依次遍历对应桶的正常桶和溢出桶中的数据（之前获取的桶序号是数据所在桶的正常桶，而如果正常桶满了会存储到溢出桶中，正常桶中会有记录溢出桶指针的字段，以链表的形式存在，再满就是溢出桶存有指向溢出桶指针的字段），它会先比较 获取的哈希的高8位和桶中存储的 <code>tophash</code> 是否相等，后比较传入的 和桶中的值以加速数据的读写。</p>
<p>用于选择桶序号的是哈希的最低几位，而用于加速访问的是哈希的高8位，这种设计能够减少同一个桶中有大量相等 <code>tophash</code>的概率影响性能。</p>
<p><img src="/p/go-%E8%AF%AD%E8%A8%80%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0%E8%AF%BB%E5%90%8E%E7%90%86%E8%A7%A3/media/image-3.png"
	width="1200"
	height="610"
	srcset="/p/go-%E8%AF%AD%E8%A8%80%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0%E8%AF%BB%E5%90%8E%E7%90%86%E8%A7%A3/media/image-3_hu1f83d595401afecd320ae5dc4d390f9d_30905_480x0_resize_box_3.png 480w, /p/go-%E8%AF%AD%E8%A8%80%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0%E8%AF%BB%E5%90%8E%E7%90%86%E8%A7%A3/media/image-3_hu1f83d595401afecd320ae5dc4d390f9d_30905_1024x0_resize_box_3.png 1024w"
	loading="lazy"
	
		alt="image.png"
	
	
		class="gallery-image" 
		data-flex-grow="196"
		data-flex-basis="472px"
	
></p>
<p>如上图所示，每一个桶都是一整片内存空间，当发现桶中的 <code>tophash</code> 与传入键的 <code>tophash</code> 匹配之后，我们会通过指针和偏移量获取哈希中存储的 <code>key[i]</code> 与key相比较，如果两者相同就会根据指针和偏移量获取对应值的指针并返回，不同则会继续循环，直到遇见相同或者 正常桶和溢出桶都遍历完。</p>
<p>另一个同样用于访问哈希表中数据的 <code>runtime.mapaccess2</code> 只是在 <code>mapaccess1</code> 的基础上多返回了一个标识 键值对是否存在的布尔值：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="line"><span class="cl"><span class="kd">func</span> <span class="nf">mapaccess2</span><span class="p">(</span><span class="nx">t</span> <span class="o">*</span><span class="nx">maptype</span><span class="p">,</span> <span class="nx">h</span> <span class="o">*</span><span class="nx">hmap</span><span class="p">,</span> <span class="nx">key</span> <span class="nx">unsafe</span><span class="p">.</span><span class="nx">Pointer</span><span class="p">)</span> <span class="p">(</span><span class="nx">unsafe</span><span class="p">.</span><span class="nx">Pointer</span><span class="p">,</span> <span class="kt">bool</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">	<span class="o">...</span>
</span></span><span class="line"><span class="cl"><span class="nx">bucketloop</span><span class="p">:</span>
</span></span><span class="line"><span class="cl">	<span class="k">for</span> <span class="p">;</span> <span class="nx">b</span> <span class="o">!=</span> <span class="kc">nil</span><span class="p">;</span> <span class="nx">b</span> <span class="p">=</span> <span class="nx">b</span><span class="p">.</span><span class="nf">overflow</span><span class="p">(</span><span class="nx">t</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">		<span class="k">for</span> <span class="nx">i</span> <span class="o">:=</span> <span class="nb">uintptr</span><span class="p">(</span><span class="mi">0</span><span class="p">);</span> <span class="nx">i</span> <span class="p">&lt;</span> <span class="nx">bucketCnt</span><span class="p">;</span> <span class="nx">i</span><span class="o">++</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">			<span class="o">...</span>
</span></span><span class="line"><span class="cl">			<span class="k">if</span> <span class="nx">alg</span><span class="p">.</span><span class="nf">equal</span><span class="p">(</span><span class="nx">key</span><span class="p">,</span> <span class="nx">k</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">				<span class="nx">v</span> <span class="o">:=</span> <span class="nf">add</span><span class="p">(</span><span class="nx">unsafe</span><span class="p">.</span><span class="nf">Pointer</span><span class="p">(</span><span class="nx">b</span><span class="p">),</span> <span class="nx">dataOffset</span><span class="o">+</span><span class="nx">bucketCnt</span><span class="o">*</span><span class="nb">uintptr</span><span class="p">(</span><span class="nx">t</span><span class="p">.</span><span class="nx">keysize</span><span class="p">)</span><span class="o">+</span><span class="nx">i</span><span class="o">*</span><span class="nb">uintptr</span><span class="p">(</span><span class="nx">t</span><span class="p">.</span><span class="nx">valuesize</span><span class="p">))</span>
</span></span><span class="line"><span class="cl">				<span class="k">return</span> <span class="nx">v</span><span class="p">,</span> <span class="kc">true</span>
</span></span><span class="line"><span class="cl">			<span class="p">}</span>
</span></span><span class="line"><span class="cl">		<span class="p">}</span>
</span></span><span class="line"><span class="cl">	<span class="p">}</span>
</span></span><span class="line"><span class="cl">	<span class="k">return</span> <span class="nx">unsafe</span><span class="p">.</span><span class="nf">Pointer</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">zeroVal</span><span class="p">[</span><span class="mi">0</span><span class="p">]),</span> <span class="kc">false</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>上面的过程是在正常情况下，访问哈希表中元素时的表现，然而和数组一样，哈希表可能会在负载因子过高或者溢出桶过多时进行扩容，而哈希表扩容并不是原子过程，它是逐步迁移的，后续会介绍在扩容过程中如何保证哈希的访问。</p>
<h5 id="写入新增修改">写入（新增、修改）</h5>
<p>当形如 <code>hash[k]</code> 的表达式出现在赋值符号的左侧时，该表达式也会在编译期间转换成 <code>runtime.mapassign</code> 函数的调用，该函数与 <code>runtime.mapaccess1</code> 比较相似，我们将其分成几部分依次分析，首先是函数会根据传入的键拿到对应的哈希和桶：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="line"><span class="cl"><span class="kd">func</span> <span class="nf">mapassign</span><span class="p">(</span><span class="nx">t</span> <span class="o">*</span><span class="nx">maptype</span><span class="p">,</span> <span class="nx">h</span> <span class="o">*</span><span class="nx">hmap</span><span class="p">,</span> <span class="nx">key</span> <span class="nx">unsafe</span><span class="p">.</span><span class="nx">Pointer</span><span class="p">)</span> <span class="nx">unsafe</span><span class="p">.</span><span class="nx">Pointer</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">	<span class="nx">alg</span> <span class="o">:=</span> <span class="nx">t</span><span class="p">.</span><span class="nx">key</span><span class="p">.</span><span class="nx">alg</span>
</span></span><span class="line"><span class="cl">	<span class="nx">hash</span> <span class="o">:=</span> <span class="nx">alg</span><span class="p">.</span><span class="nf">hash</span><span class="p">(</span><span class="nx">key</span><span class="p">,</span> <span class="nb">uintptr</span><span class="p">(</span><span class="nx">h</span><span class="p">.</span><span class="nx">hash0</span><span class="p">))</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">	<span class="nx">h</span><span class="p">.</span><span class="nx">flags</span> <span class="p">^=</span> <span class="nx">hashWriting</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="nx">again</span><span class="p">:</span>
</span></span><span class="line"><span class="cl">	<span class="nx">bucket</span> <span class="o">:=</span> <span class="nx">hash</span> <span class="o">&amp;</span> <span class="nf">bucketMask</span><span class="p">(</span><span class="nx">h</span><span class="p">.</span><span class="nx">B</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">	<span class="nx">b</span> <span class="o">:=</span> <span class="p">(</span><span class="o">*</span><span class="nx">bmap</span><span class="p">)(</span><span class="nx">unsafe</span><span class="p">.</span><span class="nf">Pointer</span><span class="p">(</span><span class="nb">uintptr</span><span class="p">(</span><span class="nx">h</span><span class="p">.</span><span class="nx">buckets</span><span class="p">)</span> <span class="o">+</span> <span class="nx">bucket</span><span class="o">*</span><span class="nb">uintptr</span><span class="p">(</span><span class="nx">t</span><span class="p">.</span><span class="nx">bucketsize</span><span class="p">)))</span>
</span></span><span class="line"><span class="cl">	<span class="nx">top</span> <span class="o">:=</span> <span class="nf">tophash</span><span class="p">(</span><span class="nx">hash</span><span class="p">)</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>然后通过遍历比较桶中存储的 <code>tophash</code> 和键的哈希，如果找到了相同结果就会返回目标位置的地址。</p>
<p>其中 <code>inserti</code> 表示目标元素的在桶中的索引（<code>tophash</code> 的位置），<code>insertk </code>和 <code>val </code>分别表示键值对的地址，获得目标地址之后会通过算术计算寻址获得键值对 <code>k </code>和 <code>val</code>：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="line"><span class="cl">	<span class="kd">var</span> <span class="nx">inserti</span> <span class="o">*</span><span class="kt">uint8</span>
</span></span><span class="line"><span class="cl">	<span class="kd">var</span> <span class="nx">insertk</span> <span class="nx">unsafe</span><span class="p">.</span><span class="nx">Pointer</span>
</span></span><span class="line"><span class="cl">	<span class="kd">var</span> <span class="nx">val</span> <span class="nx">unsafe</span><span class="p">.</span><span class="nx">Pointer</span>
</span></span><span class="line"><span class="cl"><span class="nx">bucketloop</span><span class="p">:</span>
</span></span><span class="line"><span class="cl">	<span class="k">for</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">		<span class="k">for</span> <span class="nx">i</span> <span class="o">:=</span> <span class="nb">uintptr</span><span class="p">(</span><span class="mi">0</span><span class="p">);</span> <span class="nx">i</span> <span class="p">&lt;</span> <span class="nx">bucketCnt</span><span class="p">;</span> <span class="nx">i</span><span class="o">++</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">			<span class="k">if</span> <span class="nx">b</span><span class="p">.</span><span class="nx">tophash</span><span class="p">[</span><span class="nx">i</span><span class="p">]</span> <span class="o">!=</span> <span class="nx">top</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">				<span class="k">if</span> <span class="nf">isEmpty</span><span class="p">(</span><span class="nx">b</span><span class="p">.</span><span class="nx">tophash</span><span class="p">[</span><span class="nx">i</span><span class="p">])</span> <span class="o">&amp;&amp;</span> <span class="nx">inserti</span> <span class="o">==</span> <span class="kc">nil</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">					<span class="nx">inserti</span> <span class="p">=</span> <span class="o">&amp;</span><span class="nx">b</span><span class="p">.</span><span class="nx">tophash</span><span class="p">[</span><span class="nx">i</span><span class="p">]</span>
</span></span><span class="line"><span class="cl">					<span class="nx">insertk</span> <span class="p">=</span> <span class="nf">add</span><span class="p">(</span><span class="nx">unsafe</span><span class="p">.</span><span class="nf">Pointer</span><span class="p">(</span><span class="nx">b</span><span class="p">),</span> <span class="nx">dataOffset</span><span class="o">+</span><span class="nx">i</span><span class="o">*</span><span class="nb">uintptr</span><span class="p">(</span><span class="nx">t</span><span class="p">.</span><span class="nx">keysize</span><span class="p">))</span>
</span></span><span class="line"><span class="cl">					<span class="nx">val</span> <span class="p">=</span> <span class="nf">add</span><span class="p">(</span><span class="nx">unsafe</span><span class="p">.</span><span class="nf">Pointer</span><span class="p">(</span><span class="nx">b</span><span class="p">),</span> <span class="nx">dataOffset</span><span class="o">+</span><span class="nx">bucketCnt</span><span class="o">*</span><span class="nb">uintptr</span><span class="p">(</span><span class="nx">t</span><span class="p">.</span><span class="nx">keysize</span><span class="p">)</span><span class="o">+</span><span class="nx">i</span><span class="o">*</span><span class="nb">uintptr</span><span class="p">(</span><span class="nx">t</span><span class="p">.</span><span class="nx">valuesize</span><span class="p">))</span>
</span></span><span class="line"><span class="cl">				<span class="p">}</span>
</span></span><span class="line"><span class="cl">				<span class="k">if</span> <span class="nx">b</span><span class="p">.</span><span class="nx">tophash</span><span class="p">[</span><span class="nx">i</span><span class="p">]</span> <span class="o">==</span> <span class="nx">emptyRest</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">					<span class="k">break</span> <span class="nx">bucketloop</span>
</span></span><span class="line"><span class="cl">				<span class="p">}</span>
</span></span><span class="line"><span class="cl">				<span class="k">continue</span>
</span></span><span class="line"><span class="cl">			<span class="p">}</span>
</span></span><span class="line"><span class="cl">			<span class="nx">k</span> <span class="o">:=</span> <span class="nf">add</span><span class="p">(</span><span class="nx">unsafe</span><span class="p">.</span><span class="nf">Pointer</span><span class="p">(</span><span class="nx">b</span><span class="p">),</span> <span class="nx">dataOffset</span><span class="o">+</span><span class="nx">i</span><span class="o">*</span><span class="nb">uintptr</span><span class="p">(</span><span class="nx">t</span><span class="p">.</span><span class="nx">keysize</span><span class="p">))</span>
</span></span><span class="line"><span class="cl">			<span class="k">if</span> <span class="p">!</span><span class="nx">alg</span><span class="p">.</span><span class="nf">equal</span><span class="p">(</span><span class="nx">key</span><span class="p">,</span> <span class="nx">k</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">				<span class="k">continue</span>
</span></span><span class="line"><span class="cl">			<span class="p">}</span>
</span></span><span class="line"><span class="cl">			<span class="nx">val</span> <span class="p">=</span> <span class="nf">add</span><span class="p">(</span><span class="nx">unsafe</span><span class="p">.</span><span class="nf">Pointer</span><span class="p">(</span><span class="nx">b</span><span class="p">),</span> <span class="nx">dataOffset</span><span class="o">+</span><span class="nx">bucketCnt</span><span class="o">*</span><span class="nb">uintptr</span><span class="p">(</span><span class="nx">t</span><span class="p">.</span><span class="nx">keysize</span><span class="p">)</span><span class="o">+</span><span class="nx">i</span><span class="o">*</span><span class="nb">uintptr</span><span class="p">(</span><span class="nx">t</span><span class="p">.</span><span class="nx">valuesize</span><span class="p">))</span>
</span></span><span class="line"><span class="cl">			<span class="k">goto</span> <span class="nx">done</span>
</span></span><span class="line"><span class="cl">		<span class="p">}</span>
</span></span><span class="line"><span class="cl">		<span class="nx">ovf</span> <span class="o">:=</span> <span class="nx">b</span><span class="p">.</span><span class="nf">overflow</span><span class="p">(</span><span class="nx">t</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">		<span class="k">if</span> <span class="nx">ovf</span> <span class="o">==</span> <span class="kc">nil</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">			<span class="k">break</span>
</span></span><span class="line"><span class="cl">		<span class="p">}</span>
</span></span><span class="line"><span class="cl">		<span class="nx">b</span> <span class="p">=</span> <span class="nx">ovf</span>
</span></span><span class="line"><span class="cl">	<span class="p">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>上述的 for 循环会依次遍历对应的正常桶和溢出桶中存储的数据，整个过程会分别判断 <code>tophash</code> 是否相等、<code>key</code> 是否相等，遍历结束后会从循环中跳出。</p>
<p>而如果新增时桶已经满了，哈希就会调用 <code>runtime.hmap.newoverflow</code> 创建新桶或者使用 <code>runtime.hmap</code> 预先 在 <code>noverflow</code> 中创键好的桶来保存数据（然后之前的桶以链表的形式指向新的溢出桶），新建的桶不仅会被追加到已有的全部桶的末尾，还会增加哈希表的 <code>noverflow</code> 计数器。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="line"><span class="cl">	<span class="c1">// 如果inserti为空则说明高8位没有符合这个哈希的键，属于新增操作
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="k">if</span> <span class="nx">inserti</span> <span class="o">==</span> <span class="kc">nil</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">		<span class="nx">newb</span> <span class="o">:=</span> <span class="nx">h</span><span class="p">.</span><span class="nf">newoverflow</span><span class="p">(</span><span class="nx">t</span><span class="p">,</span> <span class="nx">b</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">		<span class="nx">inserti</span> <span class="p">=</span> <span class="o">&amp;</span><span class="nx">newb</span><span class="p">.</span><span class="nx">tophash</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
</span></span><span class="line"><span class="cl">		<span class="nx">insertk</span> <span class="p">=</span> <span class="nf">add</span><span class="p">(</span><span class="nx">unsafe</span><span class="p">.</span><span class="nf">Pointer</span><span class="p">(</span><span class="nx">newb</span><span class="p">),</span> <span class="nx">dataOffset</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">		<span class="nx">val</span> <span class="p">=</span> <span class="nf">add</span><span class="p">(</span><span class="nx">insertk</span><span class="p">,</span> <span class="nx">bucketCnt</span><span class="o">*</span><span class="nb">uintptr</span><span class="p">(</span><span class="nx">t</span><span class="p">.</span><span class="nx">keysize</span><span class="p">))</span>
</span></span><span class="line"><span class="cl">	<span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">	<span class="nf">typedmemmove</span><span class="p">(</span><span class="nx">t</span><span class="p">.</span><span class="nx">key</span><span class="p">,</span> <span class="nx">insertk</span><span class="p">,</span> <span class="nx">key</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">	<span class="o">*</span><span class="nx">inserti</span> <span class="p">=</span> <span class="nx">top</span>
</span></span><span class="line"><span class="cl">	<span class="nx">h</span><span class="p">.</span><span class="nx">count</span><span class="o">++</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="c1">// 修改操作，key存在
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="nx">done</span><span class="p">:</span>
</span></span><span class="line"><span class="cl">	<span class="k">return</span> <span class="nx">val</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>如果当前键值对在哈希中不存在，哈希会为新的键值对规划存储的内存地址，通过 <code>runtime.typedmemmove</code> 将键移动到对应的内存空间中并返回键对应值的地址 <code>val</code>。如果当前键值对在哈希表中存在，那么就会直接返回 <code>val </code>值的目标区域的内存地址（见上面23行 <code>goto done</code>），哈希并不会在 <code>runtime.mapassign</code> 这个运行时函数中将值拷贝到桶中，这个函数只会计算并返回对应值的内存地址，真正的赋值操作是在编译期间插入的（编译期生成插入代码，然后运行时执行）。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span><span class="lnt">8
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="line"><span class="cl"><span class="c1">// 执行mapassign
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="mo">0001</span><span class="mi">8</span> <span class="p">(</span><span class="o">+</span><span class="mi">5</span><span class="p">)</span> <span class="nx">CALL</span> <span class="nx">runtime</span><span class="p">.</span><span class="nf">mapassign_fast64</span><span class="p">(</span><span class="nx">SB</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="c1">// 24(SP) 返回了val值地址，即让寄存器DI 指向 val 的内存地址
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="mo">00020</span> <span class="p">(</span><span class="mi">5</span><span class="p">)</span> <span class="nx">MOVQ</span> <span class="mi">24</span><span class="p">(</span><span class="nx">SP</span><span class="p">),</span> <span class="nx">DI</span>               <span class="p">;;</span> <span class="nx">DI</span> <span class="p">=</span> <span class="o">&amp;</span><span class="nx">value</span>
</span></span><span class="line"><span class="cl"><span class="c1">// 将字符串的地址存储到寄存器AX 中
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="mo">00026</span> <span class="p">(</span><span class="mi">5</span><span class="p">)</span> <span class="nx">LEAQ</span> <span class="k">go</span><span class="p">.</span><span class="kt">string</span><span class="p">.</span><span class="s">&#34;88&#34;</span><span class="p">(</span><span class="nx">SB</span><span class="p">),</span> <span class="nx">AX</span>   <span class="p">;;</span> <span class="nx">AX</span> <span class="p">=</span> <span class="o">&amp;</span><span class="s">&#34;88&#34;</span>
</span></span><span class="line"><span class="cl"><span class="c1">// 将字符串 &#34;88&#34; 存储到目标地址上
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="mo">00027</span> <span class="p">(</span><span class="mi">5</span><span class="p">)</span> <span class="nx">MOVQ</span> <span class="nx">AX</span><span class="p">,</span> <span class="p">(</span><span class="nx">DI</span><span class="p">)</span>                 <span class="p">;;</span> <span class="o">*</span><span class="nx">DI</span> <span class="p">=</span> <span class="nx">AX</span>
</span></span></code></pre></td></tr></table>
</div>
</div><h5 id="扩容">扩容</h5>
<p>前面介绍哈希的写入过程时其实省略了扩容操作，随着哈希表中元素的逐渐增加，哈希的性能也会逐渐恶化，所以我们需要更多的桶和更大的内存来保证哈希的读写性能：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span><span class="lnt">8
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="line"><span class="cl"><span class="kd">func</span> <span class="nf">mapassign</span><span class="p">(</span><span class="nx">t</span> <span class="o">*</span><span class="nx">maptype</span><span class="p">,</span> <span class="nx">h</span> <span class="o">*</span><span class="nx">hmap</span><span class="p">,</span> <span class="nx">key</span> <span class="nx">unsafe</span><span class="p">.</span><span class="nx">Pointer</span><span class="p">)</span> <span class="nx">unsafe</span><span class="p">.</span><span class="nx">Pointer</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">	<span class="o">...</span>
</span></span><span class="line"><span class="cl">	<span class="k">if</span> <span class="p">!</span><span class="nx">h</span><span class="p">.</span><span class="nf">growing</span><span class="p">()</span> <span class="o">&amp;&amp;</span> <span class="p">(</span><span class="nf">overLoadFactor</span><span class="p">(</span><span class="nx">h</span><span class="p">.</span><span class="nx">count</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span> <span class="nx">h</span><span class="p">.</span><span class="nx">B</span><span class="p">)</span> <span class="o">||</span> <span class="nf">tooManyOverflowBuckets</span><span class="p">(</span><span class="nx">h</span><span class="p">.</span><span class="nx">noverflow</span><span class="p">,</span> <span class="nx">h</span><span class="p">.</span><span class="nx">B</span><span class="p">))</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">		<span class="nf">hashGrow</span><span class="p">(</span><span class="nx">t</span><span class="p">,</span> <span class="nx">h</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">		<span class="k">goto</span> <span class="nx">again</span>
</span></span><span class="line"><span class="cl">	<span class="p">}</span>
</span></span><span class="line"><span class="cl">	<span class="o">...</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p><code>runtime.mapassign</code> 函数会在以下两种情况发生时触发哈希的扩容：</p>
<ol>
<li>负载因子已经超过6.5；</li>
<li>哈希使用了太多的溢出桶；</li>
</ol>
<p>由于Go语言哈希的扩容不是一个原子的过程，所以还需要判断当前哈希是否已经处于扩容状态 <code>!h.growing()</code>，避免二次扩容造成混乱。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="line"><span class="cl"><span class="kd">func</span> <span class="p">(</span><span class="nx">h</span> <span class="o">*</span><span class="nx">hmap</span><span class="p">)</span> <span class="nf">growing</span><span class="p">()</span> <span class="kt">bool</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">	<span class="c1">// 只有在扩容时，oldbuckets才不会为空
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="k">return</span> <span class="nx">h</span><span class="p">.</span><span class="nx">oldbuckets</span> <span class="o">!=</span> <span class="kc">nil</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>根据触发的条件不同，扩容的方式分成两种，如果这次扩容是溢出的桶太多导致的，那么这次扩容就是等量扩容 <code>sameSizeGrow</code>，它是一种特殊情况下发生的扩容，当我们持续向哈希中插入数据然后后续将它们删除时，由于哈希表中的数据量没有超过阈值，但是又因为插入导致积累了过多的溢出桶，数据分布过于分散，就会造成缓慢的内存泄露。因此一旦哈希中出现了过多的溢出桶，就会创建新桶来保存数据，减少内存占用，垃圾回收会清理掉老的溢出桶并释放内存。</p>
<p>扩容的入口是 <a class="link" href="https://github.com/golang/go/blob/ac0ba6707c1655ea4316b41d06571a0303cc60eb/src/runtime/map.go#L1026"  target="_blank" rel="noopener"
    ><code>runtime.hashGrow</code></a>：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="line"><span class="cl"><span class="kd">func</span> <span class="nf">hashGrow</span><span class="p">(</span><span class="nx">t</span> <span class="o">*</span><span class="nx">maptype</span><span class="p">,</span> <span class="nx">h</span> <span class="o">*</span><span class="nx">hmap</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">	<span class="nx">bigger</span> <span class="o">:=</span> <span class="nb">uint8</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">	<span class="k">if</span> <span class="p">!</span><span class="nf">overLoadFactor</span><span class="p">(</span><span class="nx">h</span><span class="p">.</span><span class="nx">count</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span> <span class="nx">h</span><span class="p">.</span><span class="nx">B</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">		<span class="nx">bigger</span> <span class="p">=</span> <span class="mi">0</span>
</span></span><span class="line"><span class="cl">		<span class="nx">h</span><span class="p">.</span><span class="nx">flags</span> <span class="o">|=</span> <span class="nx">sameSizeGrow</span>
</span></span><span class="line"><span class="cl">	<span class="p">}</span>
</span></span><span class="line"><span class="cl">	<span class="nx">oldbuckets</span> <span class="o">:=</span> <span class="nx">h</span><span class="p">.</span><span class="nx">buckets</span>
</span></span><span class="line"><span class="cl">	<span class="nx">newbuckets</span><span class="p">,</span> <span class="nx">nextOverflow</span> <span class="o">:=</span> <span class="nf">makeBucketArray</span><span class="p">(</span><span class="nx">t</span><span class="p">,</span> <span class="nx">h</span><span class="p">.</span><span class="nx">B</span><span class="o">+</span><span class="nx">bigger</span><span class="p">,</span> <span class="kc">nil</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">	<span class="nx">h</span><span class="p">.</span><span class="nx">B</span> <span class="o">+=</span> <span class="nx">bigger</span>
</span></span><span class="line"><span class="cl">	<span class="nx">h</span><span class="p">.</span><span class="nx">flags</span> <span class="p">=</span> <span class="nx">flags</span>
</span></span><span class="line"><span class="cl">	<span class="nx">h</span><span class="p">.</span><span class="nx">oldbuckets</span> <span class="p">=</span> <span class="nx">oldbuckets</span>
</span></span><span class="line"><span class="cl">	<span class="nx">h</span><span class="p">.</span><span class="nx">buckets</span> <span class="p">=</span> <span class="nx">newbuckets</span>
</span></span><span class="line"><span class="cl">	<span class="nx">h</span><span class="p">.</span><span class="nx">nevacuate</span> <span class="p">=</span> <span class="mi">0</span>
</span></span><span class="line"><span class="cl">	<span class="nx">h</span><span class="p">.</span><span class="nx">noverflow</span> <span class="p">=</span> <span class="mi">0</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">	<span class="nx">h</span><span class="p">.</span><span class="nx">extra</span><span class="p">.</span><span class="nx">oldoverflow</span> <span class="p">=</span> <span class="nx">h</span><span class="p">.</span><span class="nx">extra</span><span class="p">.</span><span class="nx">overflow</span>
</span></span><span class="line"><span class="cl">	<span class="nx">h</span><span class="p">.</span><span class="nx">extra</span><span class="p">.</span><span class="nx">overflow</span> <span class="p">=</span> <span class="kc">nil</span>
</span></span><span class="line"><span class="cl">	<span class="nx">h</span><span class="p">.</span><span class="nx">extra</span><span class="p">.</span><span class="nx">nextOverflow</span> <span class="p">=</span> <span class="nx">nextOverflow</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>哈希在扩容过程中会通过 <code>runtime.makeBucketArray</code> 来创建一组新桶和预创建的溢出桶，随后将原有的桶数组设置到 <code>oldbuckets</code> 上并将新的空桶设置到 <code>buckets</code> 上，溢出桶也使用了相同的逻辑更新。</p>
<p>我们在 <code>runtime.hashGrow</code>中还看不出来等量扩容和翻倍扩容的太多区别，等量扩容创建的新桶数量和旧桶一样，该函数中只是创建了新的桶，并没有对数据进行拷贝和转移。无论是等量还是翻倍，数据迁移的过程是在 <a class="link" href="https://github.com/golang/go/blob/ac0ba6707c1655ea4316b41d06571a0303cc60eb/src/runtime/map.go#L1137"  target="_blank" rel="noopener"
    ><code>runtime.evacuate</code></a>中完成的，它会对传入桶中的元素进行再分配。</p>
<p>如果是翻倍扩容， <code>runtime.evacuate</code> 会将一个旧桶中的数据分流到两个新桶中，所以它会创建两个用于保存分配上下文的 <code>runtime.evacDst</code> 结构体，这两个结构体分别指向了一个新桶。如果是等量扩容，那么旧桶和新桶之间就是一对一的关系，只会初始化一个 <code>runtime.evacDst</code> 也不会进行分流，只会重新排列哈希让其分布紧凑。</p>
<p>在分流时，只使用哈希函数是不能定位到具体的一个桶，哈希函数只会返回很长的哈希，我们还需要一些方法将哈希映射到具体的桶上面。一般都会使用取模或者位操作来获取桶的编号，加入当前哈希中包含4个桶，那么它的桶掩码就是0b11(3)，使用位操作就会得到3，那么我们就会在3号桶中存储该数据：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-ruby" data-lang="ruby"><span class="line"><span class="cl"><span class="mh">0xb72bfae3f3285244c4732ce457cca823bc189e0b</span> <span class="o">&amp;</span> <span class="mb">0b11</span> <span class="c1">#=&gt; 0</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>如果新的哈希表有8个桶，在大多数情况下，原来经过桶掩码 0b11 结果为3的数据也会因为桶掩码增加了一位变成 <code>0b111</code> 而分流到新的3号和7号桶中，所有数据也都会被 <code>runtime.typememmove</code> 拷贝到目标桶中，两个桶一个拿一半数据，散布均与。</p>
<p><code>runtime.evacuate</code> 最后会调用 <code>runtime.advanceEvacuationMark</code> 来增加哈希的 <code>nevacuate</code> 计数器，并在所有的旧桶都迁移分流完成后清空哈希的 <code>oldbuckets</code> 和 <code>oldoverflow</code>。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="line"><span class="cl"><span class="kd">func</span> <span class="nf">advanceEvacuationMark</span><span class="p">(</span><span class="nx">h</span> <span class="o">*</span><span class="nx">hmap</span><span class="p">,</span> <span class="nx">t</span> <span class="o">*</span><span class="nx">maptype</span><span class="p">,</span> <span class="nx">newbit</span> <span class="kt">uintptr</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">	<span class="nx">h</span><span class="p">.</span><span class="nx">nevacuate</span><span class="o">++</span>
</span></span><span class="line"><span class="cl">	<span class="nx">stop</span> <span class="o">:=</span> <span class="nx">h</span><span class="p">.</span><span class="nx">nevacuate</span> <span class="o">+</span> <span class="mi">1024</span>
</span></span><span class="line"><span class="cl">	<span class="k">if</span> <span class="nx">stop</span> <span class="p">&gt;</span> <span class="nx">newbit</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">		<span class="nx">stop</span> <span class="p">=</span> <span class="nx">newbit</span>
</span></span><span class="line"><span class="cl">	<span class="p">}</span>
</span></span><span class="line"><span class="cl">	<span class="k">for</span> <span class="nx">h</span><span class="p">.</span><span class="nx">nevacuate</span> <span class="o">!=</span> <span class="nx">stop</span> <span class="o">&amp;&amp;</span> <span class="nf">bucketEvacuated</span><span class="p">(</span><span class="nx">t</span><span class="p">,</span> <span class="nx">h</span><span class="p">,</span> <span class="nx">h</span><span class="p">.</span><span class="nx">nevacuate</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">		<span class="nx">h</span><span class="p">.</span><span class="nx">nevacuate</span><span class="o">++</span>
</span></span><span class="line"><span class="cl">	<span class="p">}</span>
</span></span><span class="line"><span class="cl">	<span class="k">if</span> <span class="nx">h</span><span class="p">.</span><span class="nx">nevacuate</span> <span class="o">==</span> <span class="nx">newbit</span> <span class="p">{</span> <span class="c1">// newbit == # of oldbuckets
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>		<span class="nx">h</span><span class="p">.</span><span class="nx">oldbuckets</span> <span class="p">=</span> <span class="kc">nil</span>
</span></span><span class="line"><span class="cl">		<span class="k">if</span> <span class="nx">h</span><span class="p">.</span><span class="nx">extra</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">			<span class="nx">h</span><span class="p">.</span><span class="nx">extra</span><span class="p">.</span><span class="nx">oldoverflow</span> <span class="p">=</span> <span class="kc">nil</span>
</span></span><span class="line"><span class="cl">		<span class="p">}</span>
</span></span><span class="line"><span class="cl">		<span class="nx">h</span><span class="p">.</span><span class="nx">flags</span> <span class="o">&amp;^=</span> <span class="nx">sameSizeGrow</span>
</span></span><span class="line"><span class="cl">	<span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>之前在分析哈希表访问函数 <code>runtime.mapaccess1</code> 时其实省略了扩容期间获取键值对的逻辑，当哈希表的 <code>oldbuckets</code> 存在时，会先定位到旧桶并尝试从中获取对应键值对，然后再从新桶中获取键值对。因为旧桶的元素还没有被分流，其中还保存着我们需要使用的数据，所以旧桶会替代新创建的空桶提供数据。</p>
<p>在 <code>runtime.mapassign</code> 中也省略了一段逻辑，当哈希表正处于扩容状态时，每次向哈希表写入值都会触发 <code>runtime.growWork</code> 增加拷贝哈希表中的内容。即写入数据时会顺便进行将旧桶数据迁移至新桶的工作，当然这个不是一次性迁移全部。</p>
<p>当然除了写入操作之外，删除操作也会在哈希表扩容期间触发 <code>runtime.growWork</code>，触发的方式和代码与写的逻辑几乎完全相同，都是计算当前值所在的桶，然后对桶元素进行迁移。</p>
<p>需要注意的是，为了保证元素在map中的唯一性，当一个元素从旧桶迁移到新桶时，它会被从旧桶中删除。而一旦所有的元素都已经成功迁移到新桶中，旧桶就会被销毁，释放内存。这个销毁操作发生在所有数据都成功迁移后。</p>
<p>简单总结一下哈希表扩容的设计和原理，哈希在存储元素过多时会触发扩容操作，会将桶的数量翻倍，扩容过程不是原子操作的，而是通过 <code>runtime.growWork</code> 增量触发的，避免一次性扩容带来的性能瞬时抖动，在扩容期间访问哈希表时会使用旧桶，向哈希表写入或删除数据时会触发旧桶元素的分流迁移。除了这种正常的扩容之外，为了解决大量写入、删除造成的内存泄露问题，哈希引入了 <code>sameSizeGrow</code> 等量扩容 这一机制，在出现较多溢出桶时会整理哈希的内存减少空间的占用。</p>
<h5 id="删除">删除</h5>
<p>如果想要删除哈希中的元素，就需要使用go 语言中的 <code>delete</code> 关键字，这个关键字的唯一作用就是将某一个键值对从哈希表中删除，无论该键对应的值是否存在，这个内置函数都不会返回任何结果。</p>
<p>在编译期间，<code>delete</code> 关键字会被转换成操作为 <code>ODELETE</code> 的节点，而 <a class="link" href="https://github.com/golang/go/blob/41d8e61a6b9d8f9db912626eb2bbc535e929fefc/src/cmd/compile/internal/gc/walk.go#L411"  target="_blank" rel="noopener"
    ><code>cmd/compile/internal/gc.walkexpr</code></a> 会将 <code>ODELETE</code> 节点转换成 <code>runtime.mapdelete</code> 函数簇中的一个，包括 <code>runtime.mapdelete</code> 、<code>mapdelete_faststr</code>、<code>mapdelete_fast32</code>、<code>mapdelete_fast64</code></p>
<p>这四个函数的实现都是差不多的。哈希表的删除逻辑与写入逻辑很相似，只是触发哈希的删除需要使用关键字 <code>delete</code>，如果在删除期间遇到了哈希表的扩容，就会先分流扩容桶中的元素，分流结束后会找到桶中的目标元素完成键值对的删除工作。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="line"><span class="cl"><span class="kd">func</span> <span class="nf">mapdelete</span><span class="p">(</span><span class="nx">t</span> <span class="o">*</span><span class="nx">maptype</span><span class="p">,</span> <span class="nx">h</span> <span class="o">*</span><span class="nx">hmap</span><span class="p">,</span> <span class="nx">key</span> <span class="nx">unsafe</span><span class="p">.</span><span class="nx">Pointer</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">	<span class="o">...</span>
</span></span><span class="line"><span class="cl">	<span class="k">if</span> <span class="nx">h</span><span class="p">.</span><span class="nf">growing</span><span class="p">()</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">		<span class="nf">growWork</span><span class="p">(</span><span class="nx">t</span><span class="p">,</span> <span class="nx">h</span><span class="p">,</span> <span class="nx">bucket</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">	<span class="p">}</span>
</span></span><span class="line"><span class="cl">	<span class="o">...</span>
</span></span><span class="line"><span class="cl"><span class="nx">search</span><span class="p">:</span>
</span></span><span class="line"><span class="cl">	<span class="k">for</span> <span class="p">;</span> <span class="nx">b</span> <span class="o">!=</span> <span class="kc">nil</span><span class="p">;</span> <span class="nx">b</span> <span class="p">=</span> <span class="nx">b</span><span class="p">.</span><span class="nf">overflow</span><span class="p">(</span><span class="nx">t</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">		<span class="k">for</span> <span class="nx">i</span> <span class="o">:=</span> <span class="nb">uintptr</span><span class="p">(</span><span class="mi">0</span><span class="p">);</span> <span class="nx">i</span> <span class="p">&lt;</span> <span class="nx">bucketCnt</span><span class="p">;</span> <span class="nx">i</span><span class="o">++</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">			<span class="k">if</span> <span class="nx">b</span><span class="p">.</span><span class="nx">tophash</span><span class="p">[</span><span class="nx">i</span><span class="p">]</span> <span class="o">!=</span> <span class="nx">top</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">				<span class="k">if</span> <span class="nx">b</span><span class="p">.</span><span class="nx">tophash</span><span class="p">[</span><span class="nx">i</span><span class="p">]</span> <span class="o">==</span> <span class="nx">emptyRest</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">					<span class="k">break</span> <span class="nx">search</span>
</span></span><span class="line"><span class="cl">				<span class="p">}</span>
</span></span><span class="line"><span class="cl">				<span class="k">continue</span>
</span></span><span class="line"><span class="cl">			<span class="p">}</span>
</span></span><span class="line"><span class="cl">			<span class="nx">k</span> <span class="o">:=</span> <span class="nf">add</span><span class="p">(</span><span class="nx">unsafe</span><span class="p">.</span><span class="nf">Pointer</span><span class="p">(</span><span class="nx">b</span><span class="p">),</span> <span class="nx">dataOffset</span><span class="o">+</span><span class="nx">i</span><span class="o">*</span><span class="nb">uintptr</span><span class="p">(</span><span class="nx">t</span><span class="p">.</span><span class="nx">keysize</span><span class="p">))</span>
</span></span><span class="line"><span class="cl">			<span class="nx">k2</span> <span class="o">:=</span> <span class="nx">k</span>
</span></span><span class="line"><span class="cl">			<span class="k">if</span> <span class="p">!</span><span class="nx">alg</span><span class="p">.</span><span class="nf">equal</span><span class="p">(</span><span class="nx">key</span><span class="p">,</span> <span class="nx">k2</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">				<span class="k">continue</span>
</span></span><span class="line"><span class="cl">			<span class="p">}</span>
</span></span><span class="line"><span class="cl">			<span class="c1">// kv都设置为空
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>			<span class="o">*</span><span class="p">(</span><span class="o">*</span><span class="nx">unsafe</span><span class="p">.</span><span class="nx">Pointer</span><span class="p">)(</span><span class="nx">k</span><span class="p">)</span> <span class="p">=</span> <span class="kc">nil</span>
</span></span><span class="line"><span class="cl">			<span class="nx">v</span> <span class="o">:=</span> <span class="nf">add</span><span class="p">(</span><span class="nx">unsafe</span><span class="p">.</span><span class="nf">Pointer</span><span class="p">(</span><span class="nx">b</span><span class="p">),</span> <span class="nx">dataOffset</span><span class="o">+</span><span class="nx">bucketCnt</span><span class="o">*</span><span class="nb">uintptr</span><span class="p">(</span><span class="nx">t</span><span class="p">.</span><span class="nx">keysize</span><span class="p">)</span><span class="o">+</span><span class="nx">i</span><span class="o">*</span><span class="nb">uintptr</span><span class="p">(</span><span class="nx">t</span><span class="p">.</span><span class="nx">valuesize</span><span class="p">))</span>
</span></span><span class="line"><span class="cl">			<span class="o">*</span><span class="p">(</span><span class="o">*</span><span class="nx">unsafe</span><span class="p">.</span><span class="nx">Pointer</span><span class="p">)(</span><span class="nx">v</span><span class="p">)</span> <span class="p">=</span> <span class="kc">nil</span>
</span></span><span class="line"><span class="cl">			<span class="nx">b</span><span class="p">.</span><span class="nx">tophash</span><span class="p">[</span><span class="nx">i</span><span class="p">]</span> <span class="p">=</span> <span class="nx">emptyOne</span>
</span></span><span class="line"><span class="cl">			<span class="o">...</span>
</span></span><span class="line"><span class="cl">		<span class="p">}</span>
</span></span><span class="line"><span class="cl">	<span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div><h4 id="总结">总结</h4>
<p>Go 语言使用拉链法来解决哈希碰撞的问题，它的访问、写入和删除等操作都会在编译期间转换成运行时的函数和方法。哈希在每一个桶中存储键对应哈希的前8位，当对哈希进行操作时，这些 <code>tophash</code> 就成为可以帮助哈希快速遍历桶中元素的缓存（储存高8位是为了减少==操作带来的开销。如果高8位不同，它们的值必不相同，否则可能相同，这时候再用==操作判断)。</p>
<p>哈希表的每个桶都只能存储8个键值对，一旦当前哈希的某个桶超出8个，新的键值对就会存储到哈希的溢出桶中。随着键值对数量的增加，溢出桶的数量和哈希的负载因子也会逐渐升高，负载因子超过6.5就会触发翻倍扩容，而如果删除键值对过多，溢出桶依然存在就会触发等量扩容，使数据更紧凑。元素的再分配过程也是在调用写和删除操作时增量进行的，不属于原子操作，不会造成性能的瞬时巨大抖动。</p>
<p>哈希由于扩容只有写操作（插入、删除）才会触发迁移桶，当这类操作不频繁时就有可能在比较长时间内都是处在一个比之前内存大2倍的状态，必须所有桶都迁完之后才会一次性释放掉内存，因此如果一个map读非常多，写操作不多时，建议在初始化时分配好容量，避免一直处于扩容状态。</p>
<h3 id="字符串">字符串</h3>
<p>字符串是Go 语言中的基础数据类型，虽然字符串往往被看做一个整体，但是它实际上是一片连续的内存空间。字符串是由字符组成的数组，数组会占用一片连续的内存空间，而内存空间存储的字节共同组成了字符串，Go 语言中的字符串只是一个只读的字节数组。</p>
<p>如果是代码中存在的字符串，编译器会将其标记成只读数据 <code>SRODATA</code>，只读意味着字符串会被分配到只读的内存空间，Go 语言只是不支持直接去修改 <code>string</code> 类型变量的内存空间，仍然可以通过在 <code>string</code> 和 <code>[]byte</code> 类型之间反复转换实现修改这一目的（转换为byte切片即可修改，但是此时是申请了一片新的可读写的内存空间)。</p>
<p>Java、Python 以及很多编程语言的字符串也都是不可变的，这种不可变的特性可以保证我们不会引用到意外发生改变的值，而因为 Go 语言的字符串可以作为哈希的键，所以如果哈希的键是可变的，不仅会增加哈希实现的复杂度，还可能会影响哈希的比较。</p>
<h4 id="数据结构-3">数据结构</h4>
<p>字符串在 Go 语言中的接口其实非常简单，它就像一个另类的切片，每一个字符串在运行时都会使用 <code>reflect.StringHeader</code> 表示，其中包含指向字节数组的指针和数组的大小。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="line"><span class="cl"><span class="kd">type</span> <span class="nx">StringHeader</span> <span class="kd">struct</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">	<span class="nx">Data</span> <span class="kt">uintptr</span>
</span></span><span class="line"><span class="cl">	<span class="nx">Len</span>  <span class="kt">int</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>与切片的结构体相比，字符串只少了一个表示容量的 <code>Cap</code> 字段，而正是因为切片在 Go 语言的运行时表示与字符串高度相似，所以我们经常会说字符串是一个只读的切片类型。</p>
<p>字符串作为只读类型，我们并不会向字符串直接追加元素改变其本身的内存空间，所有在字符串上的写入操作都是通过拷贝实现的。</p>
<h4 id="解析过程">解析过程</h4>
<p>解析器会在词法分析阶段解析字符串，词法分析阶段会对源文件中的字符串进行切片和分组，将原有无意义的字符流转换成 Token 序列。我们可以使用两种字面量方式在 Go 语言中声明字符串，即双引号和反引号:</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="line"><span class="cl"><span class="nx">str1</span> <span class="o">:=</span> <span class="s">&#34;this is a string&#34;</span>
</span></span><span class="line"><span class="cl"><span class="nx">str2</span> <span class="o">:=</span> <span class="s">`this is another
</span></span></span><span class="line"><span class="cl"><span class="s">string`</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>两种不同的声明方式其实也意味着 Go 语言编译器需要能够区分并且正确解析两种不同的字符串格式。解析字符串使用的扫描器 <code>cmd/compile/internal/syntax.scanner</code> 会将输入的字符串转换成 Token 流，<code>stdString</code> 方法是它用来解析使用双引号的标准字符串：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="line"><span class="cl"><span class="kd">func</span> <span class="p">(</span><span class="nx">s</span> <span class="o">*</span><span class="nx">scanner</span><span class="p">)</span> <span class="nf">stdString</span><span class="p">()</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">	<span class="nx">s</span><span class="p">.</span><span class="nf">startLit</span><span class="p">()</span>
</span></span><span class="line"><span class="cl">	<span class="k">for</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">		<span class="nx">r</span> <span class="o">:=</span> <span class="nx">s</span><span class="p">.</span><span class="nf">getr</span><span class="p">()</span>
</span></span><span class="line"><span class="cl">		<span class="c1">// 遇见双引号跳过处理
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>		<span class="k">if</span> <span class="nx">r</span> <span class="o">==</span> <span class="sc">&#39;&#34;&#39;</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">			<span class="k">break</span>
</span></span><span class="line"><span class="cl">		<span class="p">}</span>
</span></span><span class="line"><span class="cl">		<span class="c1">// 逃逸双引号
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>		<span class="k">if</span> <span class="nx">r</span> <span class="o">==</span> <span class="sc">&#39;\\&#39;</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">			<span class="nx">s</span><span class="p">.</span><span class="nf">escape</span><span class="p">(</span><span class="sc">&#39;&#34;&#39;</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">			<span class="k">continue</span>
</span></span><span class="line"><span class="cl">		<span class="p">}</span>
</span></span><span class="line"><span class="cl">		<span class="c1">// 不能有换行
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>		<span class="k">if</span> <span class="nx">r</span> <span class="o">==</span> <span class="sc">&#39;\n&#39;</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">			<span class="nx">s</span><span class="p">.</span><span class="nf">ungetr</span><span class="p">()</span>
</span></span><span class="line"><span class="cl">			<span class="nx">s</span><span class="p">.</span><span class="nb">error</span><span class="p">(</span><span class="s">&#34;newline in string&#34;</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">			<span class="k">break</span>
</span></span><span class="line"><span class="cl">		<span class="p">}</span>
</span></span><span class="line"><span class="cl">		<span class="k">if</span> <span class="nx">r</span> <span class="p">&lt;</span> <span class="mi">0</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">			<span class="nx">s</span><span class="p">.</span><span class="nf">errh</span><span class="p">(</span><span class="nx">s</span><span class="p">.</span><span class="nx">line</span><span class="p">,</span> <span class="nx">s</span><span class="p">.</span><span class="nx">col</span><span class="p">,</span> <span class="s">&#34;string not terminated&#34;</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">			<span class="k">break</span>
</span></span><span class="line"><span class="cl">		<span class="p">}</span>
</span></span><span class="line"><span class="cl">	<span class="p">}</span>
</span></span><span class="line"><span class="cl">	<span class="nx">s</span><span class="p">.</span><span class="nx">nlsemi</span> <span class="p">=</span> <span class="kc">true</span>
</span></span><span class="line"><span class="cl">	<span class="nx">s</span><span class="p">.</span><span class="nx">lit</span> <span class="p">=</span> <span class="nb">string</span><span class="p">(</span><span class="nx">s</span><span class="p">.</span><span class="nf">stopLit</span><span class="p">())</span>
</span></span><span class="line"><span class="cl">	<span class="nx">s</span><span class="p">.</span><span class="nx">kind</span> <span class="p">=</span> <span class="nx">StringLit</span>
</span></span><span class="line"><span class="cl">	<span class="nx">s</span><span class="p">.</span><span class="nx">tok</span> <span class="p">=</span> <span class="nx">_Literal</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>从这个方法的实现我们能分析出 Go 语言处理标准字符串的逻辑：</p>
<ol>
<li>标准字符串使用双引号表示开头和结尾；</li>
<li>标准字符串需要使用反斜杠 <code>\</code> 来逃逸双引号；</li>
<li>标准字符串不能出现换行 <code>\n</code>，隐式换行也不行；</li>
</ol>
<p>使用反引号声明的原始字符串的解析规则就非常简单了，<code>syntax.scanner.rawString</code> 会将非反引号的所有字符都划分到当前字符串的范围中，所以我们可以使用它支持复杂的多行字符串：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="line"><span class="cl"><span class="kd">func</span> <span class="p">(</span><span class="nx">s</span> <span class="o">*</span><span class="nx">scanner</span><span class="p">)</span> <span class="nf">rawString</span><span class="p">()</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">	<span class="nx">s</span><span class="p">.</span><span class="nf">startLit</span><span class="p">()</span>
</span></span><span class="line"><span class="cl">	<span class="k">for</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">		<span class="nx">r</span> <span class="o">:=</span> <span class="nx">s</span><span class="p">.</span><span class="nf">getr</span><span class="p">()</span>
</span></span><span class="line"><span class="cl">		<span class="k">if</span> <span class="nx">r</span> <span class="o">==</span> <span class="sc">&#39;`&#39;</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">			<span class="k">break</span>
</span></span><span class="line"><span class="cl">		<span class="p">}</span>
</span></span><span class="line"><span class="cl">		<span class="k">if</span> <span class="nx">r</span> <span class="p">&lt;</span> <span class="mi">0</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">			<span class="nx">s</span><span class="p">.</span><span class="nf">errh</span><span class="p">(</span><span class="nx">s</span><span class="p">.</span><span class="nx">line</span><span class="p">,</span> <span class="nx">s</span><span class="p">.</span><span class="nx">col</span><span class="p">,</span> <span class="s">&#34;string not terminated&#34;</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">			<span class="k">break</span>
</span></span><span class="line"><span class="cl">		<span class="p">}</span>
</span></span><span class="line"><span class="cl">	<span class="p">}</span>
</span></span><span class="line"><span class="cl">	<span class="nx">s</span><span class="p">.</span><span class="nx">nlsemi</span> <span class="p">=</span> <span class="kc">true</span>
</span></span><span class="line"><span class="cl">	<span class="nx">s</span><span class="p">.</span><span class="nx">lit</span> <span class="p">=</span> <span class="nb">string</span><span class="p">(</span><span class="nx">s</span><span class="p">.</span><span class="nf">stopLit</span><span class="p">())</span>
</span></span><span class="line"><span class="cl">	<span class="nx">s</span><span class="p">.</span><span class="nx">kind</span> <span class="p">=</span> <span class="nx">StringLit</span>
</span></span><span class="line"><span class="cl">	<span class="nx">s</span><span class="p">.</span><span class="nx">tok</span> <span class="p">=</span> <span class="nx">_Literal</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>无论是标准字符串还是原始字符串都会被标记成 <code>StringLit</code> 并传递到语法分析阶段。</p>
<p>在语法分析阶段，与字符串相关的表达式都会由 <code>cmd/compile/internal/gc.noder.basicLit</code>方法处理：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="line"><span class="cl"><span class="kd">func</span> <span class="p">(</span><span class="nx">p</span> <span class="o">*</span><span class="nx">noder</span><span class="p">)</span> <span class="nf">basicLit</span><span class="p">(</span><span class="nx">lit</span> <span class="o">*</span><span class="nx">syntax</span><span class="p">.</span><span class="nx">BasicLit</span><span class="p">)</span> <span class="nx">Val</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">	<span class="k">switch</span> <span class="nx">s</span> <span class="o">:=</span> <span class="nx">lit</span><span class="p">.</span><span class="nx">Value</span><span class="p">;</span> <span class="nx">lit</span><span class="p">.</span><span class="nx">Kind</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">	<span class="k">case</span> <span class="nx">syntax</span><span class="p">.</span><span class="nx">StringLit</span><span class="p">:</span>
</span></span><span class="line"><span class="cl">		<span class="c1">// 删除结束换行符 \r
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>		<span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="nx">s</span><span class="p">)</span> <span class="p">&gt;</span> <span class="mi">0</span> <span class="o">&amp;&amp;</span> <span class="nx">s</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="sc">&#39;`&#39;</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">			<span class="nx">s</span> <span class="p">=</span> <span class="nx">strings</span><span class="p">.</span><span class="nf">Replace</span><span class="p">(</span><span class="nx">s</span><span class="p">,</span> <span class="s">&#34;\r&#34;</span><span class="p">,</span> <span class="s">&#34;&#34;</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">		<span class="p">}</span>
</span></span><span class="line"><span class="cl">		<span class="nx">u</span><span class="p">,</span> <span class="nx">_</span> <span class="o">:=</span> <span class="nx">strconv</span><span class="p">.</span><span class="nf">Unquote</span><span class="p">(</span><span class="nx">s</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">		<span class="k">return</span> <span class="nx">Val</span><span class="p">{</span><span class="nx">U</span><span class="p">:</span> <span class="nx">u</span><span class="p">}</span>
</span></span><span class="line"><span class="cl">	<span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>无论是 <code>import</code> 语句中包的路径(双引号)、结构体中的字段标签还是表达式中的字符串都会使用这个方法将原生字符串中最后的换行符删除并对字符串 Token 进行 Unquote，也就是去掉字符串两边的引号等无关干扰，还原其本来的面目。</p>
<p><a class="link" href="https://github.com/golang/go/blob/9c91cab0da9814a598f2c4f7568b6276ff972672/src/strconv/quote.go#L368"  target="_blank" rel="noopener"
    ><code>strconv.Unquote</code></a> 处理了很多边界条件导致实现非常复杂，其中不仅包括引号，还包括 UTF-8 等编码的处理逻辑。</p>
<h4 id="拼接">拼接</h4>
<p>Go 语言拼接字符串会使用 <code>+</code> 符号，编译器会将该符号对应的 <code>OADD</code> 节点转换成 <code>OADDSTR</code> 类型的节点，随后在 <code>gc.walkexpr</code> 中调用 <code>gc.addstr</code> 函数生成用于拼接字符串的代码，<code>gc.addstr</code> 能帮助我们在编译期间选择合适的函数对字符串进行拼接，该函数会根据要拼接的字符串数量选择不同的逻辑：</p>
<ul>
<li>如果小于或者等于 5 个，那么会调用 <code>concatstring{2,3,4,5} (concatstring2、concatstring3这种)</code> 等一系列函数；</li>
<li>如果超过 5 个，那么会选择 <code>runtime.concatstrings</code> 传入一个数组切片；</li>
</ul>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="line"><span class="cl"><span class="kd">func</span> <span class="nf">addstr</span><span class="p">(</span><span class="nx">n</span> <span class="o">*</span><span class="nx">Node</span><span class="p">,</span> <span class="nx">init</span> <span class="o">*</span><span class="nx">Nodes</span><span class="p">)</span> <span class="o">*</span><span class="nx">Node</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">	<span class="nx">c</span> <span class="o">:=</span> <span class="nx">n</span><span class="p">.</span><span class="nx">List</span><span class="p">.</span><span class="nf">Len</span><span class="p">()</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">	<span class="nx">buf</span> <span class="o">:=</span> <span class="nf">nodnil</span><span class="p">()</span>
</span></span><span class="line"><span class="cl">	<span class="nx">args</span> <span class="o">:=</span> <span class="p">[]</span><span class="o">*</span><span class="nx">Node</span><span class="p">{</span><span class="nx">buf</span><span class="p">}</span>
</span></span><span class="line"><span class="cl">	<span class="k">for</span> <span class="nx">_</span><span class="p">,</span> <span class="nx">n2</span> <span class="o">:=</span> <span class="k">range</span> <span class="nx">n</span><span class="p">.</span><span class="nx">List</span><span class="p">.</span><span class="nf">Slice</span><span class="p">()</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">		<span class="nx">args</span> <span class="p">=</span> <span class="nb">append</span><span class="p">(</span><span class="nx">args</span><span class="p">,</span> <span class="nf">conv</span><span class="p">(</span><span class="nx">n2</span><span class="p">,</span> <span class="nx">types</span><span class="p">.</span><span class="nx">Types</span><span class="p">[</span><span class="nx">TSTRING</span><span class="p">]))</span>
</span></span><span class="line"><span class="cl">	<span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">	<span class="c1">// 拼接函数名
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="kd">var</span> <span class="nx">fn</span> <span class="kt">string</span>
</span></span><span class="line"><span class="cl">	<span class="k">if</span> <span class="nx">c</span> <span class="o">&lt;=</span> <span class="mi">5</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">		<span class="nx">fn</span> <span class="p">=</span> <span class="nx">fmt</span><span class="p">.</span><span class="nf">Sprintf</span><span class="p">(</span><span class="s">&#34;concatstring%d&#34;</span><span class="p">,</span> <span class="nx">c</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">		<span class="nx">fn</span> <span class="p">=</span> <span class="s">&#34;concatstrings&#34;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">		<span class="nx">t</span> <span class="o">:=</span> <span class="nx">types</span><span class="p">.</span><span class="nf">NewSlice</span><span class="p">(</span><span class="nx">types</span><span class="p">.</span><span class="nx">Types</span><span class="p">[</span><span class="nx">TSTRING</span><span class="p">])</span>
</span></span><span class="line"><span class="cl">		<span class="nx">slice</span> <span class="o">:=</span> <span class="nf">nod</span><span class="p">(</span><span class="nx">OCOMPLIT</span><span class="p">,</span> <span class="kc">nil</span><span class="p">,</span> <span class="nf">typenod</span><span class="p">(</span><span class="nx">t</span><span class="p">))</span>
</span></span><span class="line"><span class="cl">		<span class="nx">slice</span><span class="p">.</span><span class="nx">List</span><span class="p">.</span><span class="nf">Set</span><span class="p">(</span><span class="nx">args</span><span class="p">[</span><span class="mi">1</span><span class="p">:])</span>
</span></span><span class="line"><span class="cl">		<span class="nx">args</span> <span class="p">=</span> <span class="p">[]</span><span class="o">*</span><span class="nx">Node</span><span class="p">{</span><span class="nx">buf</span><span class="p">,</span> <span class="nx">slice</span><span class="p">}</span>
</span></span><span class="line"><span class="cl">	<span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">	<span class="nx">cat</span> <span class="o">:=</span> <span class="nf">syslook</span><span class="p">(</span><span class="nx">fn</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">	<span class="nx">r</span> <span class="o">:=</span> <span class="nf">nod</span><span class="p">(</span><span class="nx">OCALL</span><span class="p">,</span> <span class="nx">cat</span><span class="p">,</span> <span class="kc">nil</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">	<span class="nx">r</span><span class="p">.</span><span class="nx">List</span><span class="p">.</span><span class="nf">Set</span><span class="p">(</span><span class="nx">args</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">	<span class="o">...</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">	<span class="k">return</span> <span class="nx">r</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>其实无论使用 <code>concatstring{2,3,4,5}</code> 中的哪一个,最终都会调用 <code>runtime.concatstrings</code>，它会先遍历传入的切片参数，再过滤空字符串并计算拼接后的字符串长度。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="line"><span class="cl"><span class="kd">func</span> <span class="nf">concatstrings</span><span class="p">(</span><span class="nx">buf</span> <span class="o">*</span><span class="nx">tmpBuf</span><span class="p">,</span> <span class="nx">a</span> <span class="p">[]</span><span class="kt">string</span><span class="p">)</span> <span class="kt">string</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">	<span class="nx">idx</span> <span class="o">:=</span> <span class="mi">0</span>
</span></span><span class="line"><span class="cl">	<span class="nx">l</span> <span class="o">:=</span> <span class="mi">0</span>
</span></span><span class="line"><span class="cl">	<span class="nx">count</span> <span class="o">:=</span> <span class="mi">0</span>
</span></span><span class="line"><span class="cl">	<span class="k">for</span> <span class="nx">i</span><span class="p">,</span> <span class="nx">x</span> <span class="o">:=</span> <span class="k">range</span> <span class="nx">a</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">		<span class="nx">n</span> <span class="o">:=</span> <span class="nb">len</span><span class="p">(</span><span class="nx">x</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">		<span class="c1">// 过滤拼接中的空字符串
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>		<span class="k">if</span> <span class="nx">n</span> <span class="o">==</span> <span class="mi">0</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">			<span class="k">continue</span>
</span></span><span class="line"><span class="cl">		<span class="p">}</span>
</span></span><span class="line"><span class="cl">		<span class="nx">l</span> <span class="o">+=</span> <span class="nx">n</span>
</span></span><span class="line"><span class="cl">		<span class="nx">count</span><span class="o">++</span>
</span></span><span class="line"><span class="cl">		<span class="nx">idx</span> <span class="p">=</span> <span class="nx">i</span>
</span></span><span class="line"><span class="cl">	<span class="p">}</span>
</span></span><span class="line"><span class="cl">	<span class="c1">// 如果count=0说明+两边都是空字符串，直接返回&#34;&#34;
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="k">if</span> <span class="nx">count</span> <span class="o">==</span> <span class="mi">0</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">		<span class="k">return</span> <span class="s">&#34;&#34;</span>
</span></span><span class="line"><span class="cl">	<span class="p">}</span>
</span></span><span class="line"><span class="cl">	<span class="k">if</span> <span class="nx">count</span> <span class="o">==</span> <span class="mi">1</span> <span class="o">&amp;&amp;</span> <span class="p">(</span><span class="nx">buf</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="o">||</span> <span class="p">!</span><span class="nf">stringDataOnStack</span><span class="p">(</span><span class="nx">a</span><span class="p">[</span><span class="nx">idx</span><span class="p">]))</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">		<span class="k">return</span> <span class="nx">a</span><span class="p">[</span><span class="nx">idx</span><span class="p">]</span>
</span></span><span class="line"><span class="cl">	<span class="p">}</span>
</span></span><span class="line"><span class="cl">	<span class="nx">s</span><span class="p">,</span> <span class="nx">b</span> <span class="o">:=</span> <span class="nf">rawstringtmp</span><span class="p">(</span><span class="nx">buf</span><span class="p">,</span> <span class="nx">l</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">	<span class="c1">// 拷贝
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="k">for</span> <span class="nx">_</span><span class="p">,</span> <span class="nx">x</span> <span class="o">:=</span> <span class="k">range</span> <span class="nx">a</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">		<span class="nb">copy</span><span class="p">(</span><span class="nx">b</span><span class="p">,</span> <span class="nx">x</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">		<span class="nx">b</span> <span class="p">=</span> <span class="nx">b</span><span class="p">[</span><span class="nb">len</span><span class="p">(</span><span class="nx">x</span><span class="p">):]</span>
</span></span><span class="line"><span class="cl">	<span class="p">}</span>
</span></span><span class="line"><span class="cl">	<span class="k">return</span> <span class="nx">s</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>如果非空字符串且数量为 1 (过滤拼接的空字符串后的数量为1) 并且当前的字符串不在栈上，就可以直接返回该字符串，不需要做出额外操作。</p>
<p>但是在正常情况下，运行时会调用 <code>copy</code> 将输入的多个字符串拷贝到目标字符串所在的内存空间。新的字符串是一片新的内存空间，长度是计算出来的拼接字符串的总和，与原字符串没有任何关联，一旦需要拼接的字符串非常大，拷贝带来的性能损失是无法忽略的。</p>
<h4 id="类型转换">类型转换</h4>
<p>当我们使用 Go 语言解析和序列化 JSON 等数据格式时，经常需要将数据在 <code>string</code> 和 <code>[]byte</code> 之间来回转换，类型转换的开销并没有想象的那么小，我们经常会看到 <code>runtime.slicebytetostring</code> 等函数出现在火焰图中，成为程序的性能热点。</p>
<p>从字节切片到字符串的转换需要使用 <code>runtime.slicebytetostring</code> 函数，例如: <code>string(bytes)</code>，该函数在函数体中会先处理两种比较常见的情况，也就是长度为0或者1的字节切片，这两种情况处理起来都非常简单：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="line"><span class="cl"><span class="kd">func</span> <span class="nf">slicebytetostring</span><span class="p">(</span><span class="nx">buf</span> <span class="o">*</span><span class="nx">tmpBuf</span><span class="p">,</span> <span class="nx">b</span> <span class="p">[]</span><span class="kt">byte</span><span class="p">)</span> <span class="p">(</span><span class="nx">str</span> <span class="kt">string</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">	<span class="nx">l</span> <span class="o">:=</span> <span class="nb">len</span><span class="p">(</span><span class="nx">b</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">	<span class="k">if</span> <span class="nx">l</span> <span class="o">==</span> <span class="mi">0</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">		<span class="k">return</span> <span class="s">&#34;&#34;</span>
</span></span><span class="line"><span class="cl">	<span class="p">}</span>
</span></span><span class="line"><span class="cl">	<span class="k">if</span> <span class="nx">l</span> <span class="o">==</span> <span class="mi">1</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">		<span class="nf">stringStructOf</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">str</span><span class="p">).</span><span class="nx">str</span> <span class="p">=</span> <span class="nx">unsafe</span><span class="p">.</span><span class="nf">Pointer</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">staticbytes</span><span class="p">[</span><span class="nx">b</span><span class="p">[</span><span class="mi">0</span><span class="p">]])</span>
</span></span><span class="line"><span class="cl">		<span class="nf">stringStructOf</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">str</span><span class="p">).</span><span class="nx">len</span> <span class="p">=</span> <span class="mi">1</span>
</span></span><span class="line"><span class="cl">		<span class="k">return</span>
</span></span><span class="line"><span class="cl">	<span class="p">}</span>
</span></span><span class="line"><span class="cl">	<span class="kd">var</span> <span class="nx">p</span> <span class="nx">unsafe</span><span class="p">.</span><span class="nx">Pointer</span>
</span></span><span class="line"><span class="cl">	<span class="k">if</span> <span class="nx">buf</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="o">&amp;&amp;</span> <span class="nb">len</span><span class="p">(</span><span class="nx">b</span><span class="p">)</span> <span class="o">&lt;=</span> <span class="nb">len</span><span class="p">(</span><span class="nx">buf</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">		<span class="nx">p</span> <span class="p">=</span> <span class="nx">unsafe</span><span class="p">.</span><span class="nf">Pointer</span><span class="p">(</span><span class="nx">buf</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">		<span class="nx">p</span> <span class="p">=</span> <span class="nf">mallocgc</span><span class="p">(</span><span class="nb">uintptr</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="nx">b</span><span class="p">)),</span> <span class="kc">nil</span><span class="p">,</span> <span class="kc">false</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">	<span class="p">}</span>
</span></span><span class="line"><span class="cl">	<span class="nf">stringStructOf</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">str</span><span class="p">).</span><span class="nx">str</span> <span class="p">=</span> <span class="nx">p</span>
</span></span><span class="line"><span class="cl">	<span class="nf">stringStructOf</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">str</span><span class="p">).</span><span class="nx">len</span> <span class="p">=</span> <span class="nb">len</span><span class="p">(</span><span class="nx">b</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">	<span class="nf">memmove</span><span class="p">(</span><span class="nx">p</span><span class="p">,</span> <span class="p">(</span><span class="o">*</span><span class="p">(</span><span class="o">*</span><span class="nx">slice</span><span class="p">)(</span><span class="nx">unsafe</span><span class="p">.</span><span class="nf">Pointer</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">b</span><span class="p">))).</span><span class="nx">array</span><span class="p">,</span> <span class="nb">uintptr</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="nx">b</span><span class="p">)))</span>
</span></span><span class="line"><span class="cl">	<span class="k">return</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>它会先根据传入的缓冲区大小来决定是否需要为新字符串分配一片内存空间(mallocgc)，<code>runtime.stringStructOf</code> 会将传入的字符串指针转换成 <code>runtime.stringStruct</code> 结构指针（字符串底层就是这个结构体，不转换的话无法修改字符串的大小和内容），然后设置结构体持有的字符串指针str和长度len，最后通过 <code>runtime.memove</code> 将原[]byte 中的字节全部复制到新的内存空间中 <code>memove(目标地址,原地址，要复制多少)</code>。</p>
<p>当我们想要将字符串转换成 <code>[]byte</code> 类型时就需要使用 <code>runtime.stringtoslicebyte</code> 函数，该函数的实现非常容易理解：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="line"><span class="cl"><span class="kd">func</span> <span class="nf">stringtoslicebyte</span><span class="p">(</span><span class="nx">buf</span> <span class="o">*</span><span class="nx">tmpBuf</span><span class="p">,</span> <span class="nx">s</span> <span class="kt">string</span><span class="p">)</span> <span class="p">[]</span><span class="kt">byte</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">	<span class="kd">var</span> <span class="nx">b</span> <span class="p">[]</span><span class="kt">byte</span>
</span></span><span class="line"><span class="cl">	<span class="k">if</span> <span class="nx">buf</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="o">&amp;&amp;</span> <span class="nb">len</span><span class="p">(</span><span class="nx">s</span><span class="p">)</span> <span class="o">&lt;=</span> <span class="nb">len</span><span class="p">(</span><span class="nx">buf</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">		<span class="o">*</span><span class="nx">buf</span> <span class="p">=</span> <span class="nx">tmpBuf</span><span class="p">{}</span>
</span></span><span class="line"><span class="cl">		<span class="nx">b</span> <span class="p">=</span> <span class="nx">buf</span><span class="p">[:</span><span class="nb">len</span><span class="p">(</span><span class="nx">s</span><span class="p">)]</span>
</span></span><span class="line"><span class="cl">	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">		<span class="nx">b</span> <span class="p">=</span> <span class="nf">rawbyteslice</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="nx">s</span><span class="p">))</span>
</span></span><span class="line"><span class="cl">	<span class="p">}</span>
</span></span><span class="line"><span class="cl">	<span class="nb">copy</span><span class="p">(</span><span class="nx">b</span><span class="p">,</span> <span class="nx">s</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">	<span class="k">return</span> <span class="nx">b</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>上述函数会根据是否传入缓冲区做出不同的处理：</p>
<ul>
<li>当传入缓冲区时，它会使用传入的缓冲区来拷贝字符串内容</li>
<li>当没有传入缓冲区时，运行时会调用 <code>runtime.rawbyteslice</code> 创建新的字节切片并将字符串内容拷贝过去</li>
</ul>
<p>字符串和 <code>[]byte</code> 中的内容虽然一样，但是字符串的内容是只读的，我们不能通过下标或者其他形式改变其中的数据，而 <code>[]byte</code> 中的内容是可以读写的。由于字符串是只读的，所以无论从哪种类型转换到另一种都需要拷贝数据，而内存拷贝的性能损耗会随着字符串和 <code>[]byte</code> 长度的增长而增长。</p>
<p>字符串是 Go 语言中相对来说比较简单的一种数据结构，作为只读的数据类型，我们无法改变其本身的结构，所以在做拼接和类型转换等操作时一定要注意性能的损耗，遇到需要极致性能的场景一定要尽量减少类型转换的次数。</p>
<h2 id="语言基础">语言基础</h2>
<h3 id="函数调用">函数调用</h3>
<p>无论是系统级编程语言 C 和 Go，还是脚本语言 Ruby 和 Python，这些编程语言在调用函数时往往都使用相同的语法：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c" data-lang="c"><span class="line"><span class="cl"><span class="nf">somefunction</span><span class="p">(</span><span class="n">arg0</span><span class="p">,</span> <span class="n">arg1</span><span class="p">)</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>虽然它们调用函数的语法很相似，但是它们的调用惯例却可能大不相同。</p>
<h4 id="调用惯例">调用惯例</h4>
<p>调用惯例是调用方和被调用方对于参数和返回值传递的约定。</p>
<p>当我们在 x86_64 的机器上使用 C 语言调用函数时，参数都是通过寄存器和栈传递的，其中：</p>
<ul>
<li>六个以及六个以下的参数会按照顺序分别使用 edi、esi、edx、ecx、r8d 和 r9d 六个寄存器传递；</li>
<li>六个以上的参数会使用栈传递（1-6使用寄存器，7及以后使用栈传递），函数的参数会以从右到左的顺序依次存入栈中；</li>
</ul>
<p>而函数的返回值是通过 eax 寄存器进行传递的，由于只使用了一个寄存器存储返回值，所以 C 语言的函数不能同时返回多个值。</p>
<p>反观golang是直接使用栈来传递参数和接收返回值的，所以它只需要在栈上多分配一些内存就可以返回多个值。</p>
<p>总结：C语言和Go语言在设计函数的调用惯例时选择了不同的实现方式。C语言同时使用了寄存器和栈来传递参数，使用寄存器传递返回值；而Go语言只使用栈传递参数和返回值。我们可以对比一下这两种设计的优缺点：</p>
<ul>
<li>C 语言的方式能够极大的减少函数调用的额外开销，但是也增加了实现的复杂度（使用寄存器）；
<ul>
<li>CPU 访问栈的开销要比访问寄存器高几十倍；</li>
<li>需要单独处理函数参数过多的情况；</li>
</ul>
</li>
<li>Go 语言的方式能够降低实现的复杂度并支持返回多个值，但是牺牲了函数调用的性能；
<ul>
<li>不需要考虑超过寄存器数量的参数应该如何传递（不使用寄存器来传递参数）；</li>
<li>不需要考虑不同架构上的寄存器差异；</li>
<li>函数入参和出参的内存空间都需要在栈上进行分配；</li>
</ul>
</li>
</ul>
<p>Go 语言使用栈作为参数和返回值传递的方法是综合考虑后的设计，选择这种设计意味着编译器会更加简单、更容易维护，当然也损失了一定的性能。</p>
<h4 id="参数传递">参数传递</h4>
<p>我们先来介绍一下传值和传引用两者的区别：</p>
<ul>
<li>值传递：函数调用时会对参数进行拷贝，被调用方和调用方两者持有不相关的两份数据；</li>
<li>引用传递：函数调用时会传递参数的指针，被调用方和调用方两者持有相同的数据，任意一方做出的修改都会影响另一方。</li>
</ul>
<p>不同语言会选择不同的方式传递参数，Go 语言选择了传值的方式， <strong>无论是传递基本类型、结构体还是指针，都会对传递的参数进行拷贝</strong> 。只是区分了值类型和引用类型，传递只有值传递，引用类型就是拷贝它的指针进行传递。接收方收到参数时会对这些参数进行复制；了解到这一点之后，在传递数组或者内存占用非常大的结构体时，我们应该尽量使用指针作为参数类型来避免发生数据拷贝进而影响性能。</p>
<p>我们可以简单总结出以下几条规则：</p>
<ol>
<li>通过堆栈传递参数，入栈的顺序是从右到左（最后的参数就在栈底了)，而参数的计算是从左到右；</li>
<li>函数返回值通过堆栈传递并由调用者预先分配内存空间（调用方会先将返回值压入栈中，然后再从右到左压入参数，紧接着执行调用，被调用方会复制栈中的参数和返回值进行计算)；</li>
<li>调用函数时都是传值，接收方会对入参进行复制再计算；</li>
</ol>

</section>


    <footer class="article-footer">
    

    
    <section class="article-copyright">
        <svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-copyright" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round">
  <path stroke="none" d="M0 0h24v24H0z"/>
  <circle cx="12" cy="12" r="9" />
  <path d="M14.5 9a3.5 4 0 1 0 0 6" />
</svg>



        <span>Licensed under CC BY-NC-SA 4.0</span>
    </section>
    </footer>


    
</article>

    

    

     
    
        
    

    <footer class="site-footer">
    <section class="copyright">
        &copy; 
        
            2022 - 
        
        2023 笑傩
    </section>
    
    <section class="powerby">
        Built with <a href="https://gohugo.io/" target="_blank" rel="noopener">Hugo</a> <br />
        主题 <b><a href="https://github.com/CaiJimmy/hugo-theme-stack" target="_blank" rel="noopener" data-version="3.16.0">Stack</a></b> 由 <a href="https://jimmycai.com" target="_blank" rel="noopener">Jimmy</a> 设计
    </section>
</footer>


    
<div class="pswp" tabindex="-1" role="dialog" aria-hidden="true">

    
    <div class="pswp__bg"></div>

    
    <div class="pswp__scroll-wrap">

        
        <div class="pswp__container">
            <div class="pswp__item"></div>
            <div class="pswp__item"></div>
            <div class="pswp__item"></div>
        </div>

        
        <div class="pswp__ui pswp__ui--hidden">

            <div class="pswp__top-bar">

                

                <div class="pswp__counter"></div>

                <button class="pswp__button pswp__button--close" title="Close (Esc)"></button>

                <button class="pswp__button pswp__button--share" title="Share"></button>

                <button class="pswp__button pswp__button--fs" title="Toggle fullscreen"></button>

                <button class="pswp__button pswp__button--zoom" title="Zoom in/out"></button>

                
                
                <div class="pswp__preloader">
                    <div class="pswp__preloader__icn">
                        <div class="pswp__preloader__cut">
                            <div class="pswp__preloader__donut"></div>
                        </div>
                    </div>
                </div>
            </div>

            <div class="pswp__share-modal pswp__share-modal--hidden pswp__single-tap">
                <div class="pswp__share-tooltip"></div>
            </div>

            <button class="pswp__button pswp__button--arrow--left" title="Previous (arrow left)">
            </button>

            <button class="pswp__button pswp__button--arrow--right" title="Next (arrow right)">
            </button>

            <div class="pswp__caption">
                <div class="pswp__caption__center"></div>
            </div>

        </div>

    </div>

</div><script 
                src="https://cdn.jsdelivr.net/npm/photoswipe@4.1.3/dist/photoswipe.min.js"integrity="sha256-ePwmChbbvXbsO02lbM3HoHbSHTHFAeChekF1xKJdleo="crossorigin="anonymous"
                defer
                >
            </script><script 
                src="https://cdn.jsdelivr.net/npm/photoswipe@4.1.3/dist/photoswipe-ui-default.min.js"integrity="sha256-UKkzOn/w1mBxRmLLGrSeyB4e1xbrp4xylgAWb3M42pU="crossorigin="anonymous"
                defer
                >
            </script><link 
                rel="stylesheet" 
                href="https://cdn.jsdelivr.net/npm/photoswipe@4.1.3/dist/default-skin/default-skin.min.css"crossorigin="anonymous"
            ><link 
                rel="stylesheet" 
                href="https://cdn.jsdelivr.net/npm/photoswipe@4.1.3/dist/photoswipe.min.css"crossorigin="anonymous"
            >

            </main>
        </div>
        <script 
                src="https://cdn.jsdelivr.net/npm/node-vibrant@3.1.6/dist/vibrant.min.js"integrity="sha256-awcR2jno4kI5X0zL8ex0vi2z&#43;KMkF24hUW8WePSA9HM="crossorigin="anonymous"
                
                >
            </script><script type="text/javascript" src="/ts/main.js" defer></script>


<link rel="preconnect" href="https://fonts.googleapis.com">
<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
<link href="https://fonts.googleapis.com/css2?family=Long+Cang&family=Ma+Shan+Zheng&family=Noto+Sans+SC:wght@300&family=Noto+Serif+SC:wght@300&family=Zhi+Mang+Xing&display=swap" rel="stylesheet">

    </body>
</html>
