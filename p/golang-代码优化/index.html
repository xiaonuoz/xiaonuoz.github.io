<!DOCTYPE html>
<html lang="zh-cn" dir="ltr">
    <head><meta charset='utf-8'>
<meta name='viewport' content='width=device-width, initial-scale=1'><meta name='description' content='此文介绍从各个方向优化golang代码，让golang运行更流畅，内存消耗更少。 字符串拼接 在Go语言中，字符串只是可读的，它无法被修改，拼接'>
<title>golang 代码优化</title>

<link rel='canonical' href='https://xiaonuoz.github.io/p/golang-%E4%BB%A3%E7%A0%81%E4%BC%98%E5%8C%96/'>

<link rel="stylesheet" href="/scss/style.min.5470349c9ee04f592bc7c1dcd2e028072cd1dec2a37467ccfd4c5ecaf180dcaa.css"><meta property='og:title' content='golang 代码优化'>
<meta property='og:description' content='此文介绍从各个方向优化golang代码，让golang运行更流畅，内存消耗更少。 字符串拼接 在Go语言中，字符串只是可读的，它无法被修改，拼接'>
<meta property='og:url' content='https://xiaonuoz.github.io/p/golang-%E4%BB%A3%E7%A0%81%E4%BC%98%E5%8C%96/'>
<meta property='og:site_name' content='笑傩'>
<meta property='og:type' content='article'><meta property='article:section' content='Post' /><meta property='article:published_time' content='2023-03-24T00:00:00&#43;00:00'/><meta property='article:modified_time' content='2023-03-24T00:00:00&#43;00:00'/>
<meta name="twitter:title" content="golang 代码优化">
<meta name="twitter:description" content="此文介绍从各个方向优化golang代码，让golang运行更流畅，内存消耗更少。 字符串拼接 在Go语言中，字符串只是可读的，它无法被修改，拼接">
    <link rel="shortcut icon" href="/favicon.ico" />

    </head>
    <body class="
    article-page
    ">
    <script>
        (function() {
            const colorSchemeKey = 'StackColorScheme';
            if(!localStorage.getItem(colorSchemeKey)){
                localStorage.setItem(colorSchemeKey, "auto");
            }
        })();
    </script><script>
    (function() {
        const colorSchemeKey = 'StackColorScheme';
        const colorSchemeItem = localStorage.getItem(colorSchemeKey);
        const supportDarkMode = window.matchMedia('(prefers-color-scheme: dark)').matches === true;

        if (colorSchemeItem == 'dark' || colorSchemeItem === 'auto' && supportDarkMode) {
            

            document.documentElement.dataset.scheme = 'dark';
        } else {
            document.documentElement.dataset.scheme = 'light';
        }
    })();
</script>
<div class="container main-container flex on-phone--column extended"><aside class="sidebar left-sidebar sticky ">
    <button class="hamburger hamburger--spin" type="button" id="toggle-menu" aria-label="切换菜单">
        <span class="hamburger-box">
            <span class="hamburger-inner"></span>
        </span>
    </button>

    <header>
        
            
            <figure class="site-avatar">
                <a href="/">
                
                    
                    
                    
                        
                        <img src="/img/avatar_hu89d70501dbd1e038dcbf309839bfe7a9_213951_300x0_resize_box_3.png" width="300"
                            height="300" class="site-logo" loading="lazy" alt="Avatar">
                    
                
                </a>
                
            </figure>
            
        
        
        <div class="site-meta">
            <h1 class="site-name"><a href="/">笑傩</a></h1>
            <h2 class="site-description">永远不要高估自己~</h2>
        </div>
    </header><ol class="social-menu">
            
                <li>
                    <a 
                        href='https://github.com/xiaonuoz'
                        target="_blank"
                        title="GitHub"
                        rel="me"
                    >
                        
                        
                            <svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-brand-github" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round">
  <path stroke="none" d="M0 0h24v24H0z" fill="none"/>
  <path d="M9 19c-4.3 1.4 -4.3 -2.5 -6 -3m12 5v-3.5c0 -1 .1 -1.4 -.5 -2c2.8 -.3 5.5 -1.4 5.5 -6a4.6 4.6 0 0 0 -1.3 -3.2a4.2 4.2 0 0 0 -.1 -3.2s-1.1 -.3 -3.5 1.3a12.3 12.3 0 0 0 -6.2 0c-2.4 -1.6 -3.5 -1.3 -3.5 -1.3a4.2 4.2 0 0 0 -.1 3.2a4.6 4.6 0 0 0 -1.3 3.2c0 4.6 2.7 5.7 5.5 6c-.6 .6 -.6 1.2 -.5 2v3.5" />
</svg>



                        
                    </a>
                </li>
            
        </ol><ol class="menu" id="main-menu">
        
        
        
        <li >
            <a href='/' >
                
                
                
                    <svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-home" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round">
  <path stroke="none" d="M0 0h24v24H0z"/>
  <polyline points="5 12 3 12 12 3 21 12 19 12" />
  <path d="M5 12v7a2 2 0 0 0 2 2h10a2 2 0 0 0 2 -2v-7" />
  <path d="M9 21v-6a2 2 0 0 1 2 -2h2a2 2 0 0 1 2 2v6" />
</svg>



                
                <span>主页</span>
            </a>
        </li>
        
        
        <li >
            <a href='/search/' >
                
                
                
                    <svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-search" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round">
  <path stroke="none" d="M0 0h24v24H0z"/>
  <circle cx="10" cy="10" r="7" />
  <line x1="21" y1="21" x2="15" y2="15" />
</svg>



                
                <span>搜索</span>
            </a>
        </li>
        

        <div class="menu-bottom-section">
            
            
                <li id="dark-mode-toggle">
                    <svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-toggle-left" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round">
  <path stroke="none" d="M0 0h24v24H0z"/>
  <circle cx="8" cy="12" r="2" />
  <rect x="2" y="6" width="20" height="12" rx="6" />
</svg>



                    <svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-toggle-right" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round">
  <path stroke="none" d="M0 0h24v24H0z"/>
  <circle cx="16" cy="12" r="2" />
  <rect x="2" y="6" width="20" height="12" rx="6" />
</svg>



                    <span>暗色模式</span>
                </li>
            
        </div>
    </ol>
</aside>

    <aside class="sidebar right-sidebar sticky">
        
            
                
    <section class="widget archives">
        <div class="widget-icon">
            <svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-hash" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round">
  <path stroke="none" d="M0 0h24v24H0z"/>
  <line x1="5" y1="9" x2="19" y2="9" />
  <line x1="5" y1="15" x2="19" y2="15" />
  <line x1="11" y1="4" x2="7" y2="20" />
  <line x1="17" y1="4" x2="13" y2="20" />
</svg>



        </div>
        <h2 class="widget-title section-title">目录</h2>
        
        <div class="widget--toc">
            <nav id="TableOfContents">
  <ol>
    <li><a href="#字符串拼接">字符串拼接</a></li>
    <li><a href="#切片使用陷阱">切片使用陷阱</a></li>
    <li><a href="#for-和-range-的性能比较">for 和 range 的性能比较</a>
      <ol>
        <li><a href="#arrayslice">array/slice</a></li>
        <li><a href="#map">map</a></li>
        <li><a href="#channel">channel</a></li>
        <li><a href="#range优化">range优化</a></li>
      </ol>
    </li>
    <li><a href="#反射reflect性能">反射(reflect)性能</a>
      <ol>
        <li><a href="#提高性能">提高性能</a></li>
      </ol>
    </li>
    <li><a href="#使用空结构体节省内存">使用空结构体节省内存</a></li>
    <li><a href="#内存对齐">内存对齐</a>
      <ol>
        <li><a href="#unsafealignof">unsafe.Alignof()</a></li>
        <li><a href="#合理布局减少内存占用">合理布局减少内存占用</a></li>
        <li><a href="#空结构体struct-的对齐">空结构体struct{} 的对齐</a></li>
      </ol>
    </li>
    <li><a href="#互斥锁和读写锁的性能比较">互斥锁和读写锁的性能比较</a>
      <ol>
        <li><a href="#互斥锁如何实现公平">互斥锁如何实现公平</a></li>
      </ol>
    </li>
    <li><a href="#协程的退出">协程的退出</a>
      <ol>
        <li><a href="#超时返回时的陷阱">超时返回时的陷阱</a>
          <ol>
            <li><a href="#超时退出后子协程依然存在导致内存泄漏">超时退出后，子协程依然存在，导致内存泄漏</a></li>
            <li><a href="#强制kill-goroutine-是不能实现的">强制kill goroutine 是不能实现的</a></li>
          </ol>
        </li>
        <li><a href="#channel-忘记关闭的陷阱">channel 忘记关闭的陷阱</a>
          <ol>
            <li><a href="#关于通道和协程的垃圾回收">关于通道和协程的垃圾回收</a></li>
            <li><a href="#通道关闭原则">通道关闭原则</a></li>
            <li><a href="#优雅的关闭通道">优雅的关闭通道</a></li>
          </ol>
        </li>
      </ol>
    </li>
    <li><a href="#并发过高导致程序崩溃">并发过高导致程序崩溃</a>
      <ol>
        <li><a href="#利用channel的缓冲区来限制goroutine的数量">利用channel的缓冲区来限制goroutine的数量</a></li>
        <li><a href="#使用第三方库">使用第三方库</a></li>
        <li><a href="#调整系统资源的上限">调整系统资源的上限</a>
          <ol>
            <li><a href="#ulimit">ulimit</a></li>
            <li><a href="#虚拟内存交换分区-virtual-memory">虚拟内存/交换分区 (virtual memory)</a></li>
          </ol>
        </li>
      </ol>
    </li>
    <li><a href="#syncpool-复用对象">sync.Pool 复用对象</a>
      <ol>
        <li><a href="#使用方法">使用方法</a>
          <ol>
            <li><a href="#声明对象池">声明对象池</a></li>
          </ol>
        </li>
      </ol>
    </li>
    <li><a href="#synconce-如何提升性能">sync.Once 如何提升性能</a>
      <ol>
        <li><a href="#synconce-的原理">sync.Once 的原理</a></li>
      </ol>
    </li>
  </ol>
</nav>
        </div>
    </section>

            
        
    </aside>


            <main class="main full-width">
    <article class="main-article">
    <header class="article-header">

    <div class="article-details">
    
    <header class="article-category">
        
            <a href="/categories/golang/" >
                golang
            </a>
        
    </header>
    

    <div class="article-title-wrapper">
        <h2 class="article-title">
            <a href="/p/golang-%E4%BB%A3%E7%A0%81%E4%BC%98%E5%8C%96/">golang 代码优化</a>
        </h2>
    
        
    </div>

    
    
    
    
    <footer class="article-time">
        
            <div>
                <svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-calendar-time" width="56" height="56" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round">
  <path stroke="none" d="M0 0h24v24H0z"/>
  <path d="M11.795 21h-6.795a2 2 0 0 1 -2 -2v-12a2 2 0 0 1 2 -2h12a2 2 0 0 1 2 2v4" />
  <circle cx="18" cy="18" r="4" />
  <path d="M15 3v4" />
  <path d="M7 3v4" />
  <path d="M3 11h16" />
  <path d="M18 16.496v1.504l1 1" />
</svg>
                <time class="article-time--published">Mar 24, 2023</time>
            </div>
        

        
    </footer>
    

    
</div>

</header>

    <section class="article-content">
    
    
    <p>此文介绍从各个方向优化golang代码，让golang运行更流畅，内存消耗更少。</p>
<h2 id="字符串拼接">字符串拼接</h2>
<p>在Go语言中，字符串只是可读的，它无法被修改，拼接字符串实际上是创建了一个新的字符串对象。因此如果频繁的拼接字符串，就意味着在频繁的分配内存，会对性能造成严重的影响。</p>
<p>当使用 + 拼接 2 个字符串时，生成一个新的字符串，那么就需要开辟一段新的空间，新空间的大小是原来两个字符串的大小之和。拼接第三个字符串时，再开辟一段新空间，新空间大小是三个字符串大小之和，以此类推。</p>
<p>而 <code>strings.Builder</code>，<code>bytes.Buffer</code>，包括切片 []byte 的内存是以倍数申请的。例如，初始大小为 0，当第一次写入大小为 10 byte 的字符串时，则会申请大小为 16 byte 的内存（恰好大于 10 byte 的 2 的指数），第二次写入 10 byte 时，内存不够，则申请 32 byte 的内存，第三次写入内存足够，则不申请新的，以此类推。在实际过程中，超过一定大小，申请策略上会有些许调整。</p>
<p>官方推荐的字符串拼接方法是<code>strings.Builder</code>,它的性能比<code>bytes.Buffer</code>略快10%,一个比较重要的区别在于,<code>bytes.Buffer</code> 转化为字符串时重新申请了一块空间，存放生成的字符串变量，而 <code>strings.Builder</code> 直接将底层的 []byte 转换成了字符串类型返回了回来。</p>
<p>速度最快的是用[]byte来拼接，因为它一次性分配完了所需要的内存，通过append来拼接字符串，但是这个有一个很大的缺陷就是，在日常开发中，很多时候并不知道给这个字符串分配有多大的内存。<strong>而且<code>strings.Builder</code>也有 <code>Grow()</code> 方法可以进行预分配内存。</strong></p>
<ul>
<li>bytes.Buffer</li>
</ul>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span><span class="lnt">8
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">// To build strings more efficiently, see the strings.Builder type.
</span></span><span class="line"><span class="cl">func (b *Buffer) String() string {
</span></span><span class="line"><span class="cl">	if b == nil {
</span></span><span class="line"><span class="cl">		// Special case, useful in debugging.
</span></span><span class="line"><span class="cl">		return &#34;&lt;nil&gt;&#34;
</span></span><span class="line"><span class="cl">	}
</span></span><span class="line"><span class="cl">	return string(b.buf[b.off:])
</span></span><span class="line"><span class="cl">}
</span></span></code></pre></td></tr></table>
</div>
</div><ul>
<li>strings.Builder</li>
</ul>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">// String returns the accumulated string.
</span></span><span class="line"><span class="cl">func (b *Builder) String() string {
</span></span><span class="line"><span class="cl">	return *(*string)(unsafe.Pointer(&amp;b.buf))
</span></span><span class="line"><span class="cl">}
</span></span></code></pre></td></tr></table>
</div>
</div><p>bytes.Buffer 的注释中还特意提到了：</p>
<p><code>To build strings more efficiently, see the strings.Builder type.</code></p>
<h2 id="切片使用陷阱">切片使用陷阱</h2>
<p>在已有切片的基础上进行切片，不会创建新的底层数组，它会与原切片共用一个底层数组。因为原来的底层数组没有发生变化，内存会一直占用 (内存逃逸)，直到没有变量引用该数组才会进行垃圾回收。</p>
<p>因此很可能出现这么一种情况，原切片由大量的元素构成，但是我们在原切片的基础上切片，虽然只使用了很小一段，但底层数组在内存中仍然占据了大量空间，得不到释放。比较推荐的做法，使用 copy 替代 re-slice。copy会创建一个新的底层数据，原数据可以正确的得到回收。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">func lastNumsBySlice(origin []int) []int {
</span></span><span class="line"><span class="cl">	return origin[len(origin)-2:]
</span></span><span class="line"><span class="cl">}
</span></span></code></pre></td></tr></table>
</div>
</div><h2 id="for-和-range-的性能比较">for 和 range 的性能比较</h2>
<h3 id="arrayslice">array/slice</h3>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">words := []string{&#34;Go&#34;, &#34;语言&#34;, &#34;高性能&#34;, &#34;编程&#34;}
</span></span><span class="line"><span class="cl">for i, s := range words {
</span></span><span class="line"><span class="cl">    words = append(words, &#34;test&#34;)
</span></span><span class="line"><span class="cl">    fmt.Println(i, s)
</span></span><span class="line"><span class="cl">}
</span></span></code></pre></td></tr></table>
</div>
</div><ul>
<li>变量 words 在循环开始前，仅会计算一次，如果在循环中修改切片的长度不会改变本次循环的次数。</li>
<li>迭代过程中，每次迭代的下标和值被赋值给变量 i 和 s，第二个参数 s 是可选的。</li>
<li>针对 nil 切片，迭代次数为 0。</li>
</ul>
<h3 id="map">map</h3>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">m := map[string]int{
</span></span><span class="line"><span class="cl">    &#34;one&#34;:   1,
</span></span><span class="line"><span class="cl">    &#34;two&#34;:   2,
</span></span><span class="line"><span class="cl">    &#34;three&#34;: 3,
</span></span><span class="line"><span class="cl">}
</span></span><span class="line"><span class="cl">for k, v := range m {
</span></span><span class="line"><span class="cl">    delete(m, &#34;two&#34;)
</span></span><span class="line"><span class="cl">    m[&#34;four&#34;] = 4
</span></span><span class="line"><span class="cl">    fmt.Printf(&#34;%v: %v\n&#34;, k, v)
</span></span><span class="line"><span class="cl">}
</span></span></code></pre></td></tr></table>
</div>
</div><ul>
<li>和切片不同的是，迭代过程中，删除还未迭代到的键值对，则该键值对不会被迭代。尽量不要在遍历map时进行删除操作，因为map是无序的，你根本不知道它的迭代顺序，因此无法确定它会在迭代前删除还是删除前迭代</li>
<li>在迭代过程中，如果创建新的键值对，那么新增键值对，可能被迭代，也可能不会被迭代。</li>
<li>针对 nil 字典，迭代次数为 0</li>
</ul>
<h3 id="channel">channel</h3>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">ch := make(chan string)
</span></span><span class="line"><span class="cl">go func() {
</span></span><span class="line"><span class="cl">    ch &lt;- &#34;Go&#34;
</span></span><span class="line"><span class="cl">    ch &lt;- &#34;语言&#34;
</span></span><span class="line"><span class="cl">    ch &lt;- &#34;高性能&#34;
</span></span><span class="line"><span class="cl">    ch &lt;- &#34;编程&#34;
</span></span><span class="line"><span class="cl">    close(ch)
</span></span><span class="line"><span class="cl">}()
</span></span><span class="line"><span class="cl">for n := range ch {
</span></span><span class="line"><span class="cl">    fmt.Println(n)
</span></span><span class="line"><span class="cl">}
</span></span></code></pre></td></tr></table>
</div>
</div><ul>
<li>发送给信道(channel) 的值可以使用 for 循环迭代，直到信道被关闭。</li>
<li>如果是 nil 信道，循环将永远阻塞。</li>
<li>如果去除close就会发生死锁panic。</li>
</ul>
<h3 id="range优化">range优化</h3>
<p>range在迭代过程中返回的值是对元素的拷贝，每遍历一个都会拷贝一次当前索引元素，修改拷贝的值不会影响到切片中元素值，因此如果每次迭代的元素的内存占用很低，那么 for 和 range 的性能几乎是一样，例如 []int。但是如果元素是一个很大的结构体时range就会严重的影响到性能(因为拷贝需要时间)。</p>
<p>对应这种情况，建议使用for来进行遍历，通过索引下标去寻找对应的值，不进行拷贝。也可以用<code>for i:=range slice</code> 的方法来忽略拷贝。如果必须迭代值，则需要将切片或者数组的元素改为指针， 这样它虽然会发生拷贝，但是拷贝的是指针，指针相比于具体的值会小很多，而且还可以通过寻址直接修改元素的值。</p>
<h2 id="反射reflect性能">反射(reflect)性能</h2>
<p>标准库 reflect 为 Go 语言提供了运行时动态获取对象的类型和值以及动态创建对象的能力。反射可以帮助抽象和简化代码，提高开发效率。</p>
<p>但是相比于硬编码的方式，反射的性能就会慢很多。</p>
<ul>
<li>创建对象时，reflect.New的耗时约为new()的1.5倍</li>
<li>修改反射字段值时，FieldByName的性能相比Field劣化10倍以上，而Field的性能相比不使用反射的普通赋值操作劣化100倍左右，因此如果要使用反射修改值，尽量使用Field()
<ul>
<li>FieldByName()和Field()有这么大的性能差距就在于两者的底层逻辑实现不同，在反射的内部，字段是按照定义时的顺序存储的。</li>
<li>FieldByName()底层是使用for循环逐个查找字段名匹配的字段，其查找效率为O(N)</li>
<li>Field()是根据下标直接访问对应字段，查找效率为O(1)。</li>
<li>结构体所包含的字段(包括方法)越多，两者之间的效率差距则越大。</li>
</ul>
</li>
</ul>
<h3 id="提高性能">提高性能</h3>
<ol>
<li>避免使用反射</li>
</ol>
<p>使用反射赋值，效率非常低下，如果有替代方案的话，尽量避免使用反射，特别是会被频繁使用的热点代码尤为注意。例如在RPC协议中，需要对结构体进行序列化和反序列化，这个时候避免使用 Go 语言自带的 <code>json</code> 的 <code>Marshal</code> 和 <code>Unmarshal</code> 方法，<strong>因为标准库中的 json 序列化和反序列化是利用反射实现的</strong>。可选的替代方案有 <code>easyjson</code>，<strong>在大部分场景下，相比标准库，有 5 倍左右的性能提升。</strong></p>
<ol start="2">
<li>缓存Map</li>
</ol>
<p>因为FieldByName()相比于Field()有一个数量级的性能劣化。那么在实际应用中就要避免之间调用FieldByName。因此就可以通过map来实现，先使用for循环遍历typ.NumField()，将所有的字段通过Field()的方法存到一个map中，然后后续使用时再从map中取。</p>
<p>map的value尽量存储对应字段的索引,直接存储对应结构体的话，它为Type的StructField结构体，无法获取到对应具体实例该字段的值。</p>
<p>使用map可以让FieldByName消耗的时间从原本的10倍缩小到2倍左右。</p>
<h2 id="使用空结构体节省内存">使用空结构体节省内存</h2>
<p>空结构体 struct{} 实例不占据任何的内存空间，可以通过unsafe.Sizeof 计算出一个数据类型实例需要占用的字节数。</p>
<p>因为空结构体不占据内存空间，因此被广泛作为各种场景下的占位符使用。一是节省资源，二是空结构体本身就具备很强的语义，即这里不需要任何值，仅作为占位符</p>
<ul>
<li>将空结构体作为map的值使用，实现set类型。</li>
<li>作为不发送数据的信道，只用来通知子协程(goroutine)执行任务，或只用来控制协程并发度。</li>
<li>作为仅包含方法的结构体，主要用来给一系列函数进行分组。</li>
</ul>
<h2 id="内存对齐">内存对齐</h2>
<p>CPU访问内存时并不是逐个字节的访问，而是以字长为单位进行访问。而32位的cpu字长为(32/8) 4字节，即cpu每次访问内存的单位也是4字节。</p>
<p>这么设计的目的主要是减少CPU访问内存的次数，加大CPU访问内存的吞吐量。</p>
<p><img src="/p/golang-%E4%BB%A3%E7%A0%81%E4%BC%98%E5%8C%96/media/%E5%86%85%E5%AD%98%E5%AF%B9%E9%BD%90-1.png"
	width="1130"
	height="674"
	srcset="/p/golang-%E4%BB%A3%E7%A0%81%E4%BC%98%E5%8C%96/media/%E5%86%85%E5%AD%98%E5%AF%B9%E9%BD%90-1_huefaf2885a9b6222efd88d25e25f0d796_65827_480x0_resize_box_3.png 480w, /p/golang-%E4%BB%A3%E7%A0%81%E4%BC%98%E5%8C%96/media/%E5%86%85%E5%AD%98%E5%AF%B9%E9%BD%90-1_huefaf2885a9b6222efd88d25e25f0d796_65827_1024x0_resize_box_3.png 1024w"
	loading="lazy"
	
		alt="内存对齐-1.png"
	
	
		class="gallery-image" 
		data-flex-grow="167"
		data-flex-basis="402px"
	
>
如此图中，如果不进行内存对齐，访问b变量时就需要进行2次内存访问。第一次访问得到b变量的第1个字节，第二次访问得到b变量的后两个字节。</p>
<p>并且内存对齐对实现变量的原子性操作也是有好处的，如果变量的大小不超过字长，那么内存对齐后，对该变量的访问就是原子的。</p>
<p><strong>总结：合理的内存对齐可以提高内存读写的性能，并且便于实现变量操作的原子性。</strong></p>
<h3 id="unsafealignof">unsafe.Alignof()</h3>
<p>可以根据此方法计算内存对齐遵守的规律。它会返回一个类型的对齐值，也可以叫做对齐系数或者对齐倍数。</p>
<p>其实例占据的空间必须是对齐值的整数倍，例如一个结构体有一个int16和int32成员，那么它的内存就是2+4=6，但是通过Alignof()得到它的对齐系数为4，因此最终的内存占用值就为8。</p>
<p>它的对齐系数取决于其结构体中占用内存最大的那个成员的对齐系数。</p>
<ul>
<li>对于任意类型的变量 x ，unsafe.Alignof(x) 至少为 1</li>
<li>对于 struct 结构体类型的变量 x，计算 x 每一个字段 f 的 unsafe.Alignof(x.f)，unsafe.Alignof(x) 等于其中的最大值</li>
<li>对于 array 数组类型的变量 x，unsafe.Alignof(x) 等于构成数组的元素类型的对齐倍数(例如切片组成为 cap、len和指向底层数组的指针ptr)，对齐倍数取三者中占用内存最大的那个成员的对齐系数即可</li>
</ul>
<h3 id="合理布局减少内存占用">合理布局减少内存占用</h3>
<p>对齐系数只是用来推算结构体内存占用必须为系数的整数倍，它无法直接得出该结构体占用内存的值，还需要根据具体排列情况来获取。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">type demo1 struct {
</span></span><span class="line"><span class="cl">	a int8
</span></span><span class="line"><span class="cl">	b int16
</span></span><span class="line"><span class="cl">	c int32
</span></span><span class="line"><span class="cl">}
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">type demo2 struct {
</span></span><span class="line"><span class="cl">	a int8
</span></span><span class="line"><span class="cl">	c int32
</span></span><span class="line"><span class="cl">	b int16
</span></span><span class="line"><span class="cl">}
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">func main() {
</span></span><span class="line"><span class="cl">	fmt.Println(unsafe.Sizeof(demo1{})) // 8
</span></span><span class="line"><span class="cl">	fmt.Println(unsafe.Sizeof(demo2{})) // 12
</span></span><span class="line"><span class="cl">}
</span></span></code></pre></td></tr></table>
</div>
</div><p>unsafe.Alignof(x)只会返回最终的对齐系数，。每个字段会按照自身的对齐系数来确定在内存中的偏移量，字段排列顺序不同，上一个字段因为偏移而浪费的大小也不同。</p>
<ul>
<li>demo1:
<ul>
<li>a是第一个字段，它的对齐系数为8/8=1，自身就是8bit，即占满第0个字节。</li>
<li>b是第二个字段，它的对齐系数为16/8=2，那么偏移量必须为2的倍数，即占据第2和第3个字节，第1个字节被留空。</li>
<li>c是第三个字段，它的对齐系数为32/8=4，那么偏移量必须为4的倍数，即占据第4-7字节。</li>
</ul>
</li>
</ul>
<p>因此demo1内存占用为8字节。</p>
<ul>
<li>demo2:
<ul>
<li>a是第一个字段，和demo1一样占据第0字节。</li>
<li>b是第二个字段,对齐系数为4，4的倍数即必须从第4字节开始，占据4-7字节。</li>
<li>c是第三个字段，对齐系数为2，即占用8-9字节。</li>
<li>demo2的最终对齐倍数为占据内存最大的成员对齐系数值，即它的对齐系数为4，而abc加起来占据了10字节，并不是4的整数倍，因此demo2最终内存占用为12字节。</li>
</ul>
</li>
</ul>
<p><img src="/p/golang-%E4%BB%A3%E7%A0%81%E4%BC%98%E5%8C%96/media/%E5%86%85%E5%AD%98%E5%AF%B9%E9%BD%90-2.png"
	width="1155"
	height="419"
	srcset="/p/golang-%E4%BB%A3%E7%A0%81%E4%BC%98%E5%8C%96/media/%E5%86%85%E5%AD%98%E5%AF%B9%E9%BD%90-2_hub2deb09a9ceb43164162f9914bb1b95c_31255_480x0_resize_box_3.png 480w, /p/golang-%E4%BB%A3%E7%A0%81%E4%BC%98%E5%8C%96/media/%E5%86%85%E5%AD%98%E5%AF%B9%E9%BD%90-2_hub2deb09a9ceb43164162f9914bb1b95c_31255_1024x0_resize_box_3.png 1024w"
	loading="lazy"
	
		alt="内存对齐-2.png"
	
	
		class="gallery-image" 
		data-flex-grow="275"
		data-flex-basis="661px"
	
></p>
<p>因此，在对内存特别敏感的结构体的设计上，可以通过调整字段的顺序来减少内存的占用。只需要将结构体的成员按照各自内存占用大小升序排列即可，这样成员的对齐系数是逐渐增大的，排列的会更加紧凑，内存占用也就越小。</p>
<h3 id="空结构体struct-的对齐">空结构体struct{} 的对齐</h3>
<p>空 struct{} 大小为 0，当作为其他 struct 的字段时，一般不需要内存对齐(某个结构体中存在空结构体,只要不是放置在最后，都不会占用空间)。</p>
<p>但是有一种情况除外：即当 struct{} 作为结构体最后一个字段时，会被填充对齐到前一个字段的大小，地址偏移对齐规则不变。</p>
<p>因为如果有指针指向该字段, 返回的地址将在结构体之外，如果此指针一直存活不释放对应的内存，就会有内存泄露的问题（该内存不因结构体释放而释放，因为空结构不占用内存，导致这个指针无法指向相对应的值）。</p>
<p>因此，当 struct{} 作为其他 struct 最后一个字段时，需要填充额外的内存保证安全。我们做个试验，验证下这种情况。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">type demo3 struct {
</span></span><span class="line"><span class="cl">	c int32
</span></span><span class="line"><span class="cl">	a struct{}
</span></span><span class="line"><span class="cl">}
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">type demo4 struct {
</span></span><span class="line"><span class="cl">	a struct{}
</span></span><span class="line"><span class="cl">	c int32
</span></span><span class="line"><span class="cl">}
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">func main() {
</span></span><span class="line"><span class="cl">	fmt.Println(unsafe.Sizeof(demo3{})) // 8
</span></span><span class="line"><span class="cl">	fmt.Println(unsafe.Sizeof(demo4{})) // 4
</span></span><span class="line"><span class="cl">}
</span></span></code></pre></td></tr></table>
</div>
</div><h2 id="互斥锁和读写锁的性能比较">互斥锁和读写锁的性能比较</h2>
<ul>
<li>互斥锁： 互斥即不可同时运行。即使用了互斥锁的两个代码片段互相排斥，只有其中一个代码片段执行完成后，另一个才能执行。在一个 Go 协程调用 Lock 方法获得锁后，其他请求锁的协程都会阻塞在 Lock 方法，直到锁被释放。</li>
<li>读写锁： 保证读操作的安全，那只要保证并发读时没有写操作在进行就行。在这种场景下我们需要一种特殊类型的锁，其允许多个只读操作并行执行，但写操作会完全互斥。这种锁称之为 <code>多读单写锁</code>，简称读写锁，读写锁分为读锁和写锁，读锁是允许同时执行的，但写锁是互斥的。一般来说，有如下几种情况：
<ul>
<li>读锁之间不互斥，没有写锁的情况下，读锁是无阻塞的，多个协程可以同时获得读锁。</li>
<li>写锁之间是互斥的，存在写锁，其他写锁阻塞。</li>
<li>写锁与读锁是互斥的，如果存在读锁，写锁阻塞，如果存在写锁，读锁阻塞。</li>
</ul>
</li>
</ul>
<p>读写锁的存在是为了解决读多写少时的性能问题，读场景较多时，读写锁可有效地减少锁阻塞的时间。读写锁一般作用在读远远大于写的情况，最好在读某个共享变量时加锁，读完立马解锁，不要在锁里面处理业务逻辑，这会造成锁住的时间增长。</p>
<h3 id="互斥锁如何实现公平">互斥锁如何实现公平</h3>
<p>互斥锁有两种状态： 正常状态和饥饿状态。
在正常情况下，所有等待锁的goroutine会按照FIFO(先进先出) 顺序等待。唤醒的goroutine不会直接拥有锁，而是会和新请求获取锁的goroutine竞争 锁的拥有。新请求锁的goroutine具有优势，因为它正在CPU上执行，所以刚刚唤醒的goroutine有很大可能在锁的竞争中失败。在这种情况下，这个被唤醒的goroutine会加入到等待队列的前面，但是如果一个等待的goroutine超过1ms 没有获取锁，那么它会将锁转变为饥饿模式。
在饥饿模式下，锁的分配模式会变成 根据等待队列的顺序依次给予，新来的goroutine不会再去尝试获取锁，即使锁可能是unlock解锁状态，也不会去尝试自旋操作，它会直接放在等待队列尾部等待获取锁。
如果一个等待的goroutine获取了锁，并且满足以下其中任何一个条件:</p>
<ul>
<li>它是队列中的最后一个，不再有新的goroutine排在后面，这说明这个锁即将变成空闲状态。</li>
<li>它等待的时间小于1ms。</li>
</ul>
<p>那么锁就会从饥饿状态转换为正常状态。</p>
<p>正常状态有很好的性能表现，饥饿模式也是非常重要的，因为它能阻止尾部延迟的现象。</p>
<h2 id="协程的退出">协程的退出</h2>
<h3 id="超时返回时的陷阱">超时返回时的陷阱</h3>
<p>超时控制在网络编程中是非常常见的，利用 context.WithTimeout 和 time.After 都能够很轻易地实现。</p>
<h4 id="超时退出后子协程依然存在导致内存泄漏">超时退出后，子协程依然存在，导致内存泄漏</h4>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">func doBadthing(done chan bool) {
</span></span><span class="line"><span class="cl">	time.Sleep(time.Second)
</span></span><span class="line"><span class="cl">	done &lt;- true
</span></span><span class="line"><span class="cl">}
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">func timeout(f func(chan bool)) error {
</span></span><span class="line"><span class="cl">	done := make(chan bool)
</span></span><span class="line"><span class="cl">	go f(done)
</span></span><span class="line"><span class="cl">	select {
</span></span><span class="line"><span class="cl">	case &lt;-done:
</span></span><span class="line"><span class="cl">		fmt.Println(&#34;done&#34;)
</span></span><span class="line"><span class="cl">		return nil
</span></span><span class="line"><span class="cl">	case &lt;-time.After(time.Millisecond):
</span></span><span class="line"><span class="cl">		return fmt.Errorf(&#34;timeout&#34;)
</span></span><span class="line"><span class="cl">	}
</span></span><span class="line"><span class="cl">}
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">// fmt.Println(timeout(doBadthing))
</span></span></code></pre></td></tr></table>
</div>
</div><p>在这个代码中出现的问题就是，假如执行了1000次timeout(doBadthing),那么就会多1000个子协程永久存在与内存中，直到程序结束。原因就是超时时间为1ms，而doBadthing的执行为1s，那么每次都会走超时逻辑，这就导致1s后向done中发送信息时却找不到接收者(timeout已经结束),那么它会永久阻塞。</p>
<p>解决办法：</p>
<ul>
<li>将done从无缓冲channel改为缓存为1的有缓冲channel，这样就不会在done处阻塞，而这个有缓冲的channel因为没人使用也会被垃圾回收掉。</li>
<li>在doBadthing中增加select{} 机制，如果向done发送数据失败，则说明缺少接收者，即超时了，那么这个子协程直接退出。</li>
</ul>
<h4 id="强制kill-goroutine-是不能实现的">强制kill goroutine 是不能实现的</h4>
<p>即时超时返回了，但是子协程仍在继续运行，直到自己退出。那么有可能在超时的时候，就强制关闭子协程吗？</p>
<p>答案是不能，goroutine 只能自己退出，而不能被其他 goroutine 强制关闭或杀死。</p>
<p>goroutine 被设计为不可以从外部无条件地结束掉，只能通过 channel 来与它通信。也就是说，每一个 goroutine 都需要承担自己退出的责任。</p>
<p>因为 goroutine 不能被强制 kill，在超时或其他类似的场景下，为了 goroutine 尽可能正常退出，建议如下：</p>
<ul>
<li>尽量使用非阻塞 I/O（非阻塞 I/O 常用来实现高性能的网络库），阻塞 I/O 很可能导致 goroutine 在某个调用一直等待，而无法正确结束。</li>
<li>业务逻辑总是考虑退出机制，避免死循环。</li>
<li>任务是分段执行时，超时后立马退出，避免 goroutine 无用的执行过多，浪费资源(在复杂的业务逻辑中，超时可能和部分业务是耦合在一起的，在这种情况下就很难使用非阻塞 I/O 来设计超时，因为如果是非阻塞I/O，它不会进行阻塞，就无法判断有没有超时，会继续向后执行很多不应该执行的业务代码，因此在设计超时机制时，尝试考虑使用select{}是否可行)</li>
</ul>
<h3 id="channel-忘记关闭的陷阱">channel 忘记关闭的陷阱</h3>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">func do(taskCh chan int) {
</span></span><span class="line"><span class="cl">	for {
</span></span><span class="line"><span class="cl">		select {
</span></span><span class="line"><span class="cl">		case t := &lt;-taskCh:
</span></span><span class="line"><span class="cl">			time.Sleep(time.Millisecond)
</span></span><span class="line"><span class="cl">			fmt.Printf(&#34;task %d is done\n&#34;, t)
</span></span><span class="line"><span class="cl">		}
</span></span><span class="line"><span class="cl">	}
</span></span><span class="line"><span class="cl">}
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">func sendTasks() {
</span></span><span class="line"><span class="cl">	taskCh := make(chan int, 10)
</span></span><span class="line"><span class="cl">	go do(taskCh)
</span></span><span class="line"><span class="cl">	for i := 0; i &lt; 1000; i++ {
</span></span><span class="line"><span class="cl">		taskCh &lt;- i
</span></span><span class="line"><span class="cl">	}
</span></span><span class="line"><span class="cl">}
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">func TestDo(t *testing.T) {
</span></span><span class="line"><span class="cl">    t.Log(runtime.NumGoroutine())
</span></span><span class="line"><span class="cl">    sendTasks()
</span></span><span class="line"><span class="cl">	time.Sleep(time.Second)
</span></span><span class="line"><span class="cl">	t.Log(runtime.NumGoroutine())
</span></span><span class="line"><span class="cl">}
</span></span></code></pre></td></tr></table>
</div>
</div><p>通过测试结果发现，子协程多了一个，也就是说，有一个协程一直没有得到释放。原因就是子协程<code>go do(taskCh)</code> 的select一直处于阻塞状态，等待接收任务，因此直到程序结束协程都没有释放。
解决办法就是发送完成后通过close(chan)来关闭通道，此时接收者获取的值就是对应类型的零值，然后通过<code>t, beforeClosed := &lt;-taskCh</code>的beforeClosed来判断通道是否关闭，当它为false时表示channel已经被关闭，并且channel里面的数据为空，直接返回。也可以将<code>select{}</code>改为<code>for range</code>的方式，它也会一直读取channel的数据，当close执行后，for循环会退出。</p>
<h4 id="关于通道和协程的垃圾回收">关于通道和协程的垃圾回收</h4>
<p>注意，一个通道被其发送数据协程队列和接收数据协程队列中的所有协程引用着。因此，如果一个通道的这两个队列只要有一个不为空，则此通道肯定不会被垃圾回收。另一方面，如果一个协程处于一个通道的某个协程队列之中，则此协程也肯定不会被垃圾回收，即使此通道仅被此协程所引用。事实上，一个协程只有在退出后才能被垃圾回收。</p>
<h4 id="通道关闭原则">通道关闭原则</h4>
<p>一个常用的使用Go通道的原则是<code>不要在数据接收方或者在有多个发送者的情况下关闭通道</code>。换句话说，我们只应该让一个通道唯一的发送者关闭此通道 (因为对一个已经关闭的channel再次关闭会panic)。</p>
<p>可以使用sync.One() 或者互斥锁来确保channel 只被关闭一次。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">type MyChannel struct {
</span></span><span class="line"><span class="cl">	C    chan T
</span></span><span class="line"><span class="cl">	once sync.Once
</span></span><span class="line"><span class="cl">}
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">func NewMyChannel() *MyChannel {
</span></span><span class="line"><span class="cl">	return &amp;MyChannel{C: make(chan T)}
</span></span><span class="line"><span class="cl">}
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">func (mc *MyChannel) SafeClose() {
</span></span><span class="line"><span class="cl">	mc.once.Do(func() {
</span></span><span class="line"><span class="cl">		close(mc.C)
</span></span><span class="line"><span class="cl">	})
</span></span><span class="line"><span class="cl">}
</span></span></code></pre></td></tr></table>
</div>
</div><div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">type MyChannel struct {
</span></span><span class="line"><span class="cl">    C      chan T
</span></span><span class="line"><span class="cl">    closed bool
</span></span><span class="line"><span class="cl">    mutex  sync.Mutex
</span></span><span class="line"><span class="cl">}
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">func NewMyChannel() *MyChannel {
</span></span><span class="line"><span class="cl">    return &amp;MyChannel{C: make(chan T)}
</span></span><span class="line"><span class="cl">}
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">func (mc *MyChannel) SafeClose() {
</span></span><span class="line"><span class="cl">    mc.mutex.Lock()
</span></span><span class="line"><span class="cl">    defer mc.mutex.Unlock()
</span></span><span class="line"><span class="cl">    if !mc.closed {
</span></span><span class="line"><span class="cl">        close(mc.C)
</span></span><span class="line"><span class="cl">        mc.closed = true
</span></span><span class="line"><span class="cl">    }
</span></span><span class="line"><span class="cl">}
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">func (mc *MyChannel) IsClosed() bool {
</span></span><span class="line"><span class="cl">    mc.mutex.Lock()
</span></span><span class="line"><span class="cl">    defer mc.mutex.Unlock()
</span></span><span class="line"><span class="cl">    return mc.closed
</span></span><span class="line"><span class="cl">}
</span></span></code></pre></td></tr></table>
</div>
</div><h4 id="优雅的关闭通道">优雅的关闭通道</h4>
<ul>
<li>M 个接受者，1 个发送者。这是最简单的情况，只需让发送者在不想再发送数据的时候关闭数据通道，直接在发送者方close(ch)即可。</li>
<li>1 个接收者，N 个发送者。这个情况比上面的要复杂一点。我们不能让接收者关闭数据通道，不然就会违反了<code>通道关闭原则</code>。但是可以在接收者处创建一个额外的channel,通过关闭额外的信号通道来通知发送者不要再发送数据了</li>
</ul>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span><span class="lnt">33
</span><span class="lnt">34
</span><span class="lnt">35
</span><span class="lnt">36
</span><span class="lnt">37
</span><span class="lnt">38
</span><span class="lnt">39
</span><span class="lnt">40
</span><span class="lnt">41
</span><span class="lnt">42
</span><span class="lnt">43
</span><span class="lnt">44
</span><span class="lnt">45
</span><span class="lnt">46
</span><span class="lnt">47
</span><span class="lnt">48
</span><span class="lnt">49
</span><span class="lnt">50
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">// 在例子中，通道 dataCh 不曾被关闭过。如果一个通道不会再有 goroutine 去使用它，它最终会被垃圾回收，不管它是否被关闭。所以在这里优雅的关闭通道就是不要去关闭通道。
</span></span><span class="line"><span class="cl">	wgReceivers := sync.WaitGroup{}
</span></span><span class="line"><span class="cl">	wgReceivers.Add(1)
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">	dataCh := make(chan int, 100)
</span></span><span class="line"><span class="cl">	stopCh := make(chan struct{})
</span></span><span class="line"><span class="cl">	// stopCh 是一个信号通道。用于通知发送方不要继续发送了
</span></span><span class="line"><span class="cl">	// 它的发送者是 dataCh 的接收者。
</span></span><span class="line"><span class="cl">	// 它的接收者是 dataCh 的发送者。
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">	// 发送者，设置1000个发送者
</span></span><span class="line"><span class="cl">	for i := 0; i &lt; 1000; i++ {
</span></span><span class="line"><span class="cl">		go func() {
</span></span><span class="line"><span class="cl">			for {
</span></span><span class="line"><span class="cl">				select {
</span></span><span class="line"><span class="cl">				case &lt;-stopCh:
</span></span><span class="line"><span class="cl">					return
</span></span><span class="line"><span class="cl">				default:
</span></span><span class="line"><span class="cl">				}
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">				// 即使 stopCh 已经关闭，如果发送给 dataCh 没有阻塞，那么在第二个 select 中第一个分支可能会在一些循环中不会执行(因为select是随机执行一个不阻塞的分支)。
</span></span><span class="line"><span class="cl">				// 如果这是不可接受的，则上面的第一个select代码块是必需的。
</span></span><span class="line"><span class="cl">				select {
</span></span><span class="line"><span class="cl">				// 判断能否从stopCh中获取停止发送的信号,因为stopCh在正常情况下没有发送方，导致这一个分支一直处于阻塞状态，直到接收方执行close(ch)后，
</span></span><span class="line"><span class="cl">				// 从已关闭的channel中接收数据，如果channel中已经没有数据，则永远不会阻塞，每次接收的都是类型的零值。因此此处发送方不阻塞，直接结束协程。
</span></span><span class="line"><span class="cl">				case &lt;-stopCh:
</span></span><span class="line"><span class="cl">					return
</span></span><span class="line"><span class="cl">				case dataCh &lt;- rand.Intn(100):
</span></span><span class="line"><span class="cl">				}
</span></span><span class="line"><span class="cl">			}
</span></span><span class="line"><span class="cl">		}()
</span></span><span class="line"><span class="cl">	}
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">	// 接收者
</span></span><span class="line"><span class="cl">	go func() {
</span></span><span class="line"><span class="cl">		defer wgReceivers.Done()
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">		for value := range dataCh {
</span></span><span class="line"><span class="cl">			if value == 99 {
</span></span><span class="line"><span class="cl">				//  dataCh 通道的接收者也是 stopCh 通道的发送者。
</span></span><span class="line"><span class="cl">				// 在这里关闭停止通道是安全的。.
</span></span><span class="line"><span class="cl">				close(stopCh)
</span></span><span class="line"><span class="cl">				return
</span></span><span class="line"><span class="cl">			}
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">			log.Println(value)
</span></span><span class="line"><span class="cl">		}
</span></span><span class="line"><span class="cl">	}()
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">	wgReceivers.Wait()
</span></span></code></pre></td></tr></table>
</div>
</div><ul>
<li>M个接收者和N个发送者。它们中的任何一个协程都可以去通知让一个中间调解协程帮忙发出停止数据传送的信号。这是最复杂的一种情形。我们不能让接收者和发送者中的任何一个关闭用来传输数据的通道，我们也不能让多个接收者之一关闭一个额外的信号通道。 这两种做法都违反了<code>通道关闭原则</code>。 然而，我们可以引入一个中间调解者角色并让其关闭额外的信号通道来通知所有的接收者和发送者结束工作</li>
</ul>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">  1
</span><span class="lnt">  2
</span><span class="lnt">  3
</span><span class="lnt">  4
</span><span class="lnt">  5
</span><span class="lnt">  6
</span><span class="lnt">  7
</span><span class="lnt">  8
</span><span class="lnt">  9
</span><span class="lnt"> 10
</span><span class="lnt"> 11
</span><span class="lnt"> 12
</span><span class="lnt"> 13
</span><span class="lnt"> 14
</span><span class="lnt"> 15
</span><span class="lnt"> 16
</span><span class="lnt"> 17
</span><span class="lnt"> 18
</span><span class="lnt"> 19
</span><span class="lnt"> 20
</span><span class="lnt"> 21
</span><span class="lnt"> 22
</span><span class="lnt"> 23
</span><span class="lnt"> 24
</span><span class="lnt"> 25
</span><span class="lnt"> 26
</span><span class="lnt"> 27
</span><span class="lnt"> 28
</span><span class="lnt"> 29
</span><span class="lnt"> 30
</span><span class="lnt"> 31
</span><span class="lnt"> 32
</span><span class="lnt"> 33
</span><span class="lnt"> 34
</span><span class="lnt"> 35
</span><span class="lnt"> 36
</span><span class="lnt"> 37
</span><span class="lnt"> 38
</span><span class="lnt"> 39
</span><span class="lnt"> 40
</span><span class="lnt"> 41
</span><span class="lnt"> 42
</span><span class="lnt"> 43
</span><span class="lnt"> 44
</span><span class="lnt"> 45
</span><span class="lnt"> 46
</span><span class="lnt"> 47
</span><span class="lnt"> 48
</span><span class="lnt"> 49
</span><span class="lnt"> 50
</span><span class="lnt"> 51
</span><span class="lnt"> 52
</span><span class="lnt"> 53
</span><span class="lnt"> 54
</span><span class="lnt"> 55
</span><span class="lnt"> 56
</span><span class="lnt"> 57
</span><span class="lnt"> 58
</span><span class="lnt"> 59
</span><span class="lnt"> 60
</span><span class="lnt"> 61
</span><span class="lnt"> 62
</span><span class="lnt"> 63
</span><span class="lnt"> 64
</span><span class="lnt"> 65
</span><span class="lnt"> 66
</span><span class="lnt"> 67
</span><span class="lnt"> 68
</span><span class="lnt"> 69
</span><span class="lnt"> 70
</span><span class="lnt"> 71
</span><span class="lnt"> 72
</span><span class="lnt"> 73
</span><span class="lnt"> 74
</span><span class="lnt"> 75
</span><span class="lnt"> 76
</span><span class="lnt"> 77
</span><span class="lnt"> 78
</span><span class="lnt"> 79
</span><span class="lnt"> 80
</span><span class="lnt"> 81
</span><span class="lnt"> 82
</span><span class="lnt"> 83
</span><span class="lnt"> 84
</span><span class="lnt"> 85
</span><span class="lnt"> 86
</span><span class="lnt"> 87
</span><span class="lnt"> 88
</span><span class="lnt"> 89
</span><span class="lnt"> 90
</span><span class="lnt"> 91
</span><span class="lnt"> 92
</span><span class="lnt"> 93
</span><span class="lnt"> 94
</span><span class="lnt"> 95
</span><span class="lnt"> 96
</span><span class="lnt"> 97
</span><span class="lnt"> 98
</span><span class="lnt"> 99
</span><span class="lnt">100
</span><span class="lnt">101
</span><span class="lnt">102
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">const Max = 100000
</span></span><span class="line"><span class="cl">	const NumReceivers = 10
</span></span><span class="line"><span class="cl">	const NumSenders = 1000
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">	wgReceivers := sync.WaitGroup{}
</span></span><span class="line"><span class="cl">	wgReceivers.Add(NumReceivers)
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">	dataCh := make(chan int)
</span></span><span class="line"><span class="cl">	stopCh := make(chan struct{})
</span></span><span class="line"><span class="cl">	// stopCh是一个额外的信号通道。
</span></span><span class="line"><span class="cl">	// 它的发送者为中间调解者。它的接收者为dataCh数据通道的所有的发送者和接收者。
</span></span><span class="line"><span class="cl">	// 平常都处于阻塞状态，直到执行close(stopCh)后
</span></span><span class="line"><span class="cl">	toStop := make(chan string, 1)
</span></span><span class="line"><span class="cl">	// toStop是一个用来通知中间调解者，让其关闭 通道stopCh 的信号通道。
</span></span><span class="line"><span class="cl">	// 此第二个信号通道的发送者为 dataCh数据通道的所有的发送者和接收者，
</span></span><span class="line"><span class="cl">	// 它的接收者为中间调解者。它必须为一个缓冲通道，
</span></span><span class="line"><span class="cl">	// 不然如果在中间调解者还未准备好的情况下就已经有某个协程向toStop发送信号时，会发送阻塞，走default分支，此信号就会被抛弃。
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">	// 中间调解者
</span></span><span class="line"><span class="cl">	go func() {
</span></span><span class="line"><span class="cl">		&lt;-toStop
</span></span><span class="line"><span class="cl">		close(stopCh)
</span></span><span class="line"><span class="cl">	}()
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">	// 发送者
</span></span><span class="line"><span class="cl">	for i := 0; i &lt; NumSenders; i++ {
</span></span><span class="line"><span class="cl">		go func(id string) {
</span></span><span class="line"><span class="cl">			for {
</span></span><span class="line"><span class="cl">				value := rand.Intn(Max)
</span></span><span class="line"><span class="cl">				if value == 0 {
</span></span><span class="line"><span class="cl">					// 为了防止阻塞，这里使用了一个尝试
</span></span><span class="line"><span class="cl">					// 发送操作来向中间调解者发送信号。
</span></span><span class="line"><span class="cl">					select {
</span></span><span class="line"><span class="cl">					case toStop &lt;- &#34;发送者#&#34; + id:
</span></span><span class="line"><span class="cl">					default:
</span></span><span class="line"><span class="cl">					}
</span></span><span class="line"><span class="cl">					return
</span></span><span class="line"><span class="cl">				}
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">				// 此处的尝试接收操作是为了让此发送协程尽早
</span></span><span class="line"><span class="cl">				// 退出。标准编译器对尝试接收和尝试发送做了
</span></span><span class="line"><span class="cl">				// 特殊的优化，因而它们的速度很快。
</span></span><span class="line"><span class="cl">				select {
</span></span><span class="line"><span class="cl">				case &lt;-stopCh:
</span></span><span class="line"><span class="cl">					return
</span></span><span class="line"><span class="cl">				default:
</span></span><span class="line"><span class="cl">				}
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">				// 即使stopCh已关闭，如果这个select代码块
</span></span><span class="line"><span class="cl">				// 中第二个分支的发送操作是非阻塞的，则第一个
</span></span><span class="line"><span class="cl">				// 分支仍很有可能在若干个循环步内依然不会被选
</span></span><span class="line"><span class="cl">				// 中。如果这是不可接受的，则上面的第一个尝试
</span></span><span class="line"><span class="cl">				// 接收操作代码块是必需的。
</span></span><span class="line"><span class="cl">				select {
</span></span><span class="line"><span class="cl">				case &lt;-stopCh:
</span></span><span class="line"><span class="cl">					return
</span></span><span class="line"><span class="cl">				case dataCh &lt;- value:
</span></span><span class="line"><span class="cl">				}
</span></span><span class="line"><span class="cl">			}
</span></span><span class="line"><span class="cl">		}(strconv.Itoa(i))
</span></span><span class="line"><span class="cl">	}
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">	// 接收者
</span></span><span class="line"><span class="cl">	for i := 0; i &lt; NumReceivers; i++ {
</span></span><span class="line"><span class="cl">		go func(id string) {
</span></span><span class="line"><span class="cl">			defer wgReceivers.Done()
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">			for {
</span></span><span class="line"><span class="cl">				// 和发送者协程一样，此处的尝试接收操作是为了
</span></span><span class="line"><span class="cl">				// 让此接收协程尽早退出。
</span></span><span class="line"><span class="cl">				select {
</span></span><span class="line"><span class="cl">				case &lt;-stopCh:
</span></span><span class="line"><span class="cl">					return
</span></span><span class="line"><span class="cl">				default:
</span></span><span class="line"><span class="cl">				}
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">				// 即使stopCh已关闭，如果这个select代码块
</span></span><span class="line"><span class="cl">				// 中第二个分支的接收操作是非阻塞的，则第一个
</span></span><span class="line"><span class="cl">				// 分支仍很有可能在若干个循环步内依然不会被选
</span></span><span class="line"><span class="cl">				// 中。如果这是不可接受的，则上面尝试接收操作
</span></span><span class="line"><span class="cl">				// 代码块是必需的。
</span></span><span class="line"><span class="cl">				select {
</span></span><span class="line"><span class="cl">				case &lt;-stopCh:
</span></span><span class="line"><span class="cl">					return
</span></span><span class="line"><span class="cl">				case value := &lt;-dataCh:
</span></span><span class="line"><span class="cl">					if value == Max-1 {
</span></span><span class="line"><span class="cl">						// 为了防止阻塞，这里使用了一个尝试
</span></span><span class="line"><span class="cl">						// 发送操作来向中间调解者发送信号。
</span></span><span class="line"><span class="cl">						select {
</span></span><span class="line"><span class="cl">						case toStop &lt;- &#34;接收者#&#34; + id:
</span></span><span class="line"><span class="cl">						default:
</span></span><span class="line"><span class="cl">						}
</span></span><span class="line"><span class="cl">						return
</span></span><span class="line"><span class="cl">					}
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">					log.Println(value)
</span></span><span class="line"><span class="cl">				}
</span></span><span class="line"><span class="cl">			}
</span></span><span class="line"><span class="cl">		}(strconv.Itoa(i))
</span></span><span class="line"><span class="cl">	}
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">	wgReceivers.Wait()
</span></span></code></pre></td></tr></table>
</div>
</div><p><code>并没有什么情况非得逼得我们违反通道关闭原则。 如果你遇到了此情形，请考虑修改你的代码流程和结构设计</code></p>
<h2 id="并发过高导致程序崩溃">并发过高导致程序崩溃</h2>
<p>如果无限制的开启协程会导致内存不足崩溃，或者对单个 file/socket 的并发操作个数超过系统上限 (比如在协程中打印内容，fmt.Printf也是操作文件描述符，过多的协程会导致系统资源耗尽)</p>
<p>不同的应用程序所消耗的资源是不一样的。比较推荐的方式是：应用程序来主动限制并发的协程数量。</p>
<h3 id="利用channel的缓冲区来限制goroutine的数量">利用channel的缓冲区来限制goroutine的数量</h3>
<p>每次开启协程前先向一个有缓冲的channel中发送一条消息，当channel满时就会阻塞，不会再创建新的协程。而每个协程结束时都会从channel中接收一条消息，只有一个协程结束，才能新建一个协程，从而控制了程序创建的协程数量。</p>
<p><code>runtime.GOMAXPROCS(逻辑CPU数量)</code> 控制的是可以并发执行的最大 P 数量（即逻辑 CPU 数量），，但是它不能控制总协程数量 (GMP模型中，协程可以在P队列中等待)，GOMAXPROCS默认值就是CPU逻辑核心数量，如8核16线程GOMAXPROCS设置的值就是16，可以通过<code>NumCPU()</code>查看，可以设置比核心数量大，但是没意义，因为正在运行的协程依然最大只能有逻辑CPU数，多余的 P 只会浪费资源，不会带来更好的性能。</p>
<h3 id="使用第三方库">使用第三方库</h3>
<p>目前有很多第三方库实现了协程池，可以很方便地用来控制协程的并发数量。</p>
<ul>
<li><a class="link" href="https://github.com/Jeffail/tunny"  target="_blank" rel="noopener"
    >Jeffail/tunny</a></li>
<li><a class="link" href="https://github.com/panjf2000/ants"  target="_blank" rel="noopener"
    >panjf2000/ants</a></li>
</ul>
<p>以<code>tunny</code>举例:</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="line"><span class="cl"><span class="kn">package</span> <span class="nx">main</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kn">import</span> <span class="p">(</span>
</span></span><span class="line"><span class="cl">	<span class="s">&#34;log&#34;</span>
</span></span><span class="line"><span class="cl">	<span class="s">&#34;time&#34;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">	<span class="s">&#34;github.com/Jeffail/tunny&#34;</span>
</span></span><span class="line"><span class="cl"><span class="p">)</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kd">func</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">	<span class="c1">// 创建协程池，第一个参数是协程池的大小，第二个参数是协程运行的函数
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="nx">pool</span> <span class="o">:=</span> <span class="nx">tunny</span><span class="p">.</span><span class="nf">NewFunc</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="kd">func</span><span class="p">(</span><span class="nx">i</span> <span class="kd">interface</span><span class="p">{})</span> <span class="kd">interface</span><span class="p">{}</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">		<span class="nx">log</span><span class="p">.</span><span class="nf">Println</span><span class="p">(</span><span class="nx">i</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">		<span class="nx">time</span><span class="p">.</span><span class="nf">Sleep</span><span class="p">(</span><span class="nx">time</span><span class="p">.</span><span class="nx">Second</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">		<span class="k">return</span> <span class="kc">nil</span>
</span></span><span class="line"><span class="cl">	<span class="p">})</span>
</span></span><span class="line"><span class="cl">	<span class="c1">// 关闭协程池
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="k">defer</span> <span class="nx">pool</span><span class="p">.</span><span class="nf">Close</span><span class="p">()</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">	<span class="c1">// 将参数传递给协程池定义好的worker处理
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="k">for</span> <span class="nx">i</span> <span class="o">:=</span> <span class="mi">0</span><span class="p">;</span> <span class="nx">i</span> <span class="p">&lt;</span> <span class="mi">10</span><span class="p">;</span> <span class="nx">i</span><span class="o">++</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">		<span class="k">go</span> <span class="nx">pool</span><span class="p">.</span><span class="nf">Process</span><span class="p">(</span><span class="nx">i</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">	<span class="p">}</span>
</span></span><span class="line"><span class="cl">	<span class="nx">time</span><span class="p">.</span><span class="nf">Sleep</span><span class="p">(</span><span class="nx">time</span><span class="p">.</span><span class="nx">Second</span> <span class="o">*</span> <span class="mi">4</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div><h3 id="调整系统资源的上限">调整系统资源的上限</h3>
<h4 id="ulimit">ulimit</h4>
<p>有些时候，即使我们有效地限制了协程的并发数量，仍然会出现某一类资源不足的问题。
比如分布式编译加速工具需要解析gcc命令以及依赖的源文件和头文件，有些编译命令依赖的头文件可能有上百个，那这个时候即使我们将协程的并发数限制到 1000，也可能会超过进程运行时并发打开的文件句柄数量 <code>(程序打开的文件数量超过了系统设置的程序打开句柄数量，资源耗尽)</code>，但是分布式编译工具，仅将依赖的源文件和头文件分发到远端机器执行，并不会消耗本机的内存和 CPU 资源，因此 1000 个并发并不高，这种情况下，降低并发数会影响到编译加速的效率，这种时候我们就可以通过设置系统的打开句柄数量来解决。</p>
<p>操作系统通常会限制同时打开文件数量、栈空间大小等，ulimit -a 可以看到系统当前的设置：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">$ ulimit -a
</span></span><span class="line"><span class="cl">-t: cpu time (seconds)              unlimited
</span></span><span class="line"><span class="cl">-f: file size (blocks)              unlimited
</span></span><span class="line"><span class="cl">-d: data seg size (kbytes)          unlimited
</span></span><span class="line"><span class="cl">-s: stack size (kbytes)             8192
</span></span><span class="line"><span class="cl">-c: core file size (blocks)         0
</span></span><span class="line"><span class="cl">-v: address space (kbytes)          unlimited
</span></span><span class="line"><span class="cl">-l: locked-in-memory size (kbytes)  unlimited
</span></span><span class="line"><span class="cl">-u: processes                       1418
</span></span><span class="line"><span class="cl">-n: file descriptors                12800
</span></span></code></pre></td></tr></table>
</div>
</div><p>我们可以使用 <code>ulimit -n 999999</code>，将同时打开的文件句柄数量调整为 999999 来解决这个问题，其他的参数也可以按需调整</p>
<h4 id="虚拟内存交换分区-virtual-memory">虚拟内存/交换分区 (virtual memory)</h4>
<p>虚拟内存是一项非常常见的技术了，即在内存不足时，将磁盘映射为内存使用，比如 linux 下的交换分区(swap space)。设置完交换分区后，内存不足时系统会自动使用交换分区作内存用。
在 linux 上创建并使用交换分区是一件非常简单的事情：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">sudo fallocate -l 20G /mnt/.swapfile # 创建 20G 空文件
</span></span><span class="line"><span class="cl">sudo mkswap /mnt/.swapfile    # 转换为交换分区文件
</span></span><span class="line"><span class="cl">sudo chmod 600 /mnt/.swapfile # 修改权限为 600
</span></span><span class="line"><span class="cl">sudo swapon /mnt/.swapfile    # 激活交换分区
</span></span><span class="line"><span class="cl">free -m # 查看当前内存使用情况(包括交换分区)
</span></span></code></pre></td></tr></table>
</div>
</div><p>关闭交换分区也非常简单：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">sudo swapoff /mnt/.swapfile
</span></span><span class="line"><span class="cl">rm -rf /mnt/.swapfile
</span></span></code></pre></td></tr></table>
</div>
</div><p><code>磁盘的 I/O 读写性能和内存条相差是非常大的，</code>例如 DDR3 的内存条读写速率很容易达到 20GB/s，但是 SSD 固态硬盘的读写性能通常只能达到 0.5GB/s，相差 40倍之多。因此，使用虚拟内存技术将硬盘映射为内存使用，显然会对性能产生一定的影响。如果应用程序只是在较短的时间内需要较大的内存，那么虚拟内存能够有效避免 <code>out of memory (内存不足)</code> 的问题。如果应用程序长期高频率读写大量内存，那么虚拟内存对性能的影响就比较明显了。</p>
<h2 id="syncpool-复用对象">sync.Pool 复用对象</h2>
<p>通过保存和复用临时对象，减少内存分配，降低GC垃圾回收压力,<code>sync.Pool</code>主要就是复用一个临时变量，避免频繁的创建临时结构体来承载数据，造成极大的GC压力和不必要的内存，它是并发安全的，所以可以多协程共用。</p>
<p>常用于网络包收取发送的时候，因为收取发送时需要频繁的反序列化，如果每次反序列化时都是一个新的临时变量，在高并发时，会造成极大的GC压力，采用sync.Pool的话，一直仅有一个临时变量，就不会分配过多内存。</p>
<p>例如json 的反序列化在文本解析和网络通信过程中非常常见，当程序并发度非常高的情况下，短时间内需要创建大量的临时对象来承载反序列化的数据。而这些对象是都是分配在堆上的，会给 GC 造成很大压力，严重影响程序的性能。</p>
<p>sync.Pool 是可伸缩的，同时也是并发安全的，其大小仅受限于内存的大小。sync.Pool 用于存储那些被分配了但是没有被使用，而未来可能会使用的值。这样就可以不用再次经过内存分配，可直接复用已有对象，减轻 GC 的压力，从而提升系统的性能。</p>
<p>sync.Pool 的大小在高负载时会动态扩容，存放在池中的对象如果不活跃了会被自动清理。</p>
<h3 id="使用方法">使用方法</h3>
<h4 id="声明对象池">声明对象池</h4>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">var studentPool = sync.Pool{
</span></span><span class="line"><span class="cl">    New: func() interface{} { 
</span></span><span class="line"><span class="cl">        return new(Student) 
</span></span><span class="line"><span class="cl">    },
</span></span><span class="line"><span class="cl">}
</span></span></code></pre></td></tr></table>
</div>
</div><p>只需要实现 New 函数即可。对象池中没有对象时，将会调用 New 函数创建。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">#### Get &amp; Put
</span></span><span class="line"><span class="cl">stu := studentPool.Get().(*Student)
</span></span><span class="line"><span class="cl">json.Unmarshal(buf, stu)
</span></span><span class="line"><span class="cl">studentPool.Put(stu)
</span></span></code></pre></td></tr></table>
</div>
</div><ul>
<li>Get() 用于从对象池中获取对象，因为返回值是 interface{}，因此需要类型转换。</li>
<li>Put() 则是在对象使用完毕后，返回对象池。</li>
</ul>
<p><code>sync.Pool</code> 作为使用方不能对 Pool 里面的对象个数做假定，同时也无法获取 Pool 池中对象个数。可以往池中Put发送多个对象，但是Get()时是随机取出对象，无法保证以固定的顺序获取Pool池中的存储对象。</p>
<p>没有配置 New 方法时，如果 Get 操作多于 Put 操作，继续 Get 会得到一个 nil interface{} 对象，所以需要配置New()代码进行兼容。</p>
<p>配置 New 方法后，Get 获取不到对象时（Pool 池中已经没有对象了），会调用自定义的 New 方法创建一个对象并返回。需要注意的是，sync.Pool 本身数据结构是并发安全的，但是 Pool.New 函数（用户自定义的）不一定是线程安全的。Pool.New 函数可能会被并发调用，如果 New 函数里面的实现逻辑是 非并发安全的，那就会有问题。</p>
<p><code>sync.Pool</code>不适合存储带状态的对象，因为获取对象是随机的 <code>(Get 到的对象可能是刚创建的，也可能是之前创建并 cache 住的)</code>，并且缓存对象的释放策略完全由 runtime 内部管理，你无法确定此次获取的数据是否是自己需要的，也许是之前未被取出，还未释放的数据。</p>
<h2 id="synconce-如何提升性能">sync.Once 如何提升性能</h2>
<p>sync.Once 是 Go 标准库提供的使函数只执行一次的实现，常应用于单例模式，例如初始化配置、保持数据库连接等。作用与 init 函数类似，但有区别。</p>
<ul>
<li>init 函数是当所在的 package 首次被加载时执行，若执行后init()中的全局变量迟迟未被使用，则既浪费了内存，又延长了程序加载时间。</li>
<li>sync.Once 可以在代码的任意位置初始化和调用，因此可以延迟到需要使用时再执行，并发场景下是线程安全的。</li>
</ul>
<p>在多数情况下，sync.Once 被用于控制变量的初始化，这个变量的读写满足如下三个条件：</p>
<ul>
<li>当且仅当第一次访问某个变量时，进行初始化（写）；</li>
<li>变量初始化过程中，其他执行该sync.Once.Do()的协程会发生阻塞，直到初始化完成，保证所有协程都能拿到初始化后的值；</li>
<li>变量仅初始化一次，初始化完成后驻留在内存里。</li>
</ul>
<p>sync.Once 仅提供了一个方法 Do，参数 f 是对象初始化函数。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">func (o *Once) Do(f func())
</span></span></code></pre></td></tr></table>
</div>
</div><p>如果不使用sync.One，并发运行初始化时，每次都构造出一个新的对象，既浪费内存，又浪费初始化时间。如果初始化时不加锁，初始化全局变量就可能出现并发冲突。这种情况下，使用 sync.Once 既能够保证全局变量初始化时是线程安全的，又能节省内存和初始化时间。</p>
<h3 id="synconce-的原理">sync.Once 的原理</h3>
<p>首先要保证变量仅被初始化一次，那么就需要有一个标志来判断变量是否已经初始化过，若没有才需要初始化。</p>
<p>其次就是保证线程安全，支持并发，这无疑需要互斥锁来实现。</p>
<p>源码<code> (代码位于 $(dirname $(which go))/../src/sync/once.g)</code>：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="line"><span class="cl"><span class="kn">package</span> <span class="nx">sync</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kn">import</span> <span class="p">(</span>
</span></span><span class="line"><span class="cl">    <span class="s">&#34;sync/atomic&#34;</span>
</span></span><span class="line"><span class="cl"><span class="p">)</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kd">type</span> <span class="nx">Once</span> <span class="kd">struct</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">	<span class="c1">// 标志位，判断是否已经初始化
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="nx">done</span> <span class="kt">uint32</span>
</span></span><span class="line"><span class="cl">    <span class="nx">m</span>    <span class="nx">Mutex</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kd">func</span> <span class="p">(</span><span class="nx">o</span> <span class="o">*</span><span class="nx">Once</span><span class="p">)</span> <span class="nf">Do</span><span class="p">(</span><span class="nx">f</span> <span class="kd">func</span><span class="p">())</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">	<span class="c1">// 原子操作判断是否初始化过，标志位设置为uint32就是因为atomic的最小单位就是32，没有uint8
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="k">if</span> <span class="nx">atomic</span><span class="p">.</span><span class="nf">LoadUint32</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">o</span><span class="p">.</span><span class="nx">done</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="nx">o</span><span class="p">.</span><span class="nf">doSlow</span><span class="p">(</span><span class="nx">f</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kd">func</span> <span class="p">(</span><span class="nx">o</span> <span class="o">*</span><span class="nx">Once</span><span class="p">)</span> <span class="nf">doSlow</span><span class="p">(</span><span class="nx">f</span> <span class="kd">func</span><span class="p">())</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">	<span class="c1">// 加锁避免并发问题，不再Do层面加锁的原因就是加快速度，如果在Do中加锁，那么即使初始化过后，以后执行Do方法依然需要加锁
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="nx">o</span><span class="p">.</span><span class="nx">m</span><span class="p">.</span><span class="nf">Lock</span><span class="p">()</span>
</span></span><span class="line"><span class="cl">    <span class="k">defer</span> <span class="nx">o</span><span class="p">.</span><span class="nx">m</span><span class="p">.</span><span class="nf">Unlock</span><span class="p">()</span>
</span></span><span class="line"><span class="cl">	<span class="c1">// Once都是同一个，因此在原子操作设置完后，这个done就为1了
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="k">if</span> <span class="nx">o</span><span class="p">.</span><span class="nx">done</span> <span class="o">==</span> <span class="mi">0</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">		<span class="c1">// 设置标志为已初始化
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="k">defer</span> <span class="nx">atomic</span><span class="p">.</span><span class="nf">StoreUint32</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">o</span><span class="p">.</span><span class="nx">done</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">        <span class="nf">f</span><span class="p">()</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>done 在热路径中，done 放在第一个字段，能够减少 CPU 指令，也就是说，这样做能够提升性能</p>
<ul>
<li>热路径<code>(hot path)</code>是程序非常频繁执行的一系列指令，sync.Once 绝大部分场景都会访问 o.done (判断是否执行过)，在热路径上是比较好理解的，如果 <code>hot path</code> 编译后的机器码指令更少，更直接，必然是能够提升性能的</li>
<li>为什么放在第一个字段就能够减少指令呢？ 因为结构体第一个字段的地址和结构体的指针是相同的，如果是第一个字段，直接对结构体的指针解引用即可。 如果是后面的字段，除了结构体指针外，还需要计算与第一个值的偏移(calculate offset)。在机器码中，偏移量是随指令传递的附加值，CPU 需要做一次偏移值与指针的加法运算，才能获取要访问的值的地址。因此，访问第一个字段的机器代码更紧凑，速度更快。</li>
</ul>

</section>


    <footer class="article-footer">
    

    
    <section class="article-copyright">
        <svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-copyright" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round">
  <path stroke="none" d="M0 0h24v24H0z"/>
  <circle cx="12" cy="12" r="9" />
  <path d="M14.5 9a3.5 4 0 1 0 0 6" />
</svg>



        <span>Licensed under CC BY-NC-SA 4.0</span>
    </section>
    </footer>


    
</article>

    

    

     
    
        
    

    <footer class="site-footer">
    <section class="copyright">
        &copy; 
        
            2022 - 
        
        2023 笑傩
    </section>
    
    <section class="powerby">
        Built with <a href="https://gohugo.io/" target="_blank" rel="noopener">Hugo</a> <br />
        主题 <b><a href="https://github.com/CaiJimmy/hugo-theme-stack" target="_blank" rel="noopener" data-version="3.16.0">Stack</a></b> 由 <a href="https://jimmycai.com" target="_blank" rel="noopener">Jimmy</a> 设计
    </section>
</footer>


    
<div class="pswp" tabindex="-1" role="dialog" aria-hidden="true">

    
    <div class="pswp__bg"></div>

    
    <div class="pswp__scroll-wrap">

        
        <div class="pswp__container">
            <div class="pswp__item"></div>
            <div class="pswp__item"></div>
            <div class="pswp__item"></div>
        </div>

        
        <div class="pswp__ui pswp__ui--hidden">

            <div class="pswp__top-bar">

                

                <div class="pswp__counter"></div>

                <button class="pswp__button pswp__button--close" title="Close (Esc)"></button>

                <button class="pswp__button pswp__button--share" title="Share"></button>

                <button class="pswp__button pswp__button--fs" title="Toggle fullscreen"></button>

                <button class="pswp__button pswp__button--zoom" title="Zoom in/out"></button>

                
                
                <div class="pswp__preloader">
                    <div class="pswp__preloader__icn">
                        <div class="pswp__preloader__cut">
                            <div class="pswp__preloader__donut"></div>
                        </div>
                    </div>
                </div>
            </div>

            <div class="pswp__share-modal pswp__share-modal--hidden pswp__single-tap">
                <div class="pswp__share-tooltip"></div>
            </div>

            <button class="pswp__button pswp__button--arrow--left" title="Previous (arrow left)">
            </button>

            <button class="pswp__button pswp__button--arrow--right" title="Next (arrow right)">
            </button>

            <div class="pswp__caption">
                <div class="pswp__caption__center"></div>
            </div>

        </div>

    </div>

</div><script 
                src="https://cdn.jsdelivr.net/npm/photoswipe@4.1.3/dist/photoswipe.min.js"integrity="sha256-ePwmChbbvXbsO02lbM3HoHbSHTHFAeChekF1xKJdleo="crossorigin="anonymous"
                defer
                >
            </script><script 
                src="https://cdn.jsdelivr.net/npm/photoswipe@4.1.3/dist/photoswipe-ui-default.min.js"integrity="sha256-UKkzOn/w1mBxRmLLGrSeyB4e1xbrp4xylgAWb3M42pU="crossorigin="anonymous"
                defer
                >
            </script><link 
                rel="stylesheet" 
                href="https://cdn.jsdelivr.net/npm/photoswipe@4.1.3/dist/default-skin/default-skin.min.css"crossorigin="anonymous"
            ><link 
                rel="stylesheet" 
                href="https://cdn.jsdelivr.net/npm/photoswipe@4.1.3/dist/photoswipe.min.css"crossorigin="anonymous"
            >

            </main>
        </div>
        <script 
                src="https://cdn.jsdelivr.net/npm/node-vibrant@3.1.6/dist/vibrant.min.js"integrity="sha256-awcR2jno4kI5X0zL8ex0vi2z&#43;KMkF24hUW8WePSA9HM="crossorigin="anonymous"
                
                >
            </script><script type="text/javascript" src="/ts/main.js" defer></script>


<link rel="preconnect" href="https://fonts.googleapis.com">
<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
<link href="https://fonts.googleapis.com/css2?family=Long+Cang&family=Ma+Shan+Zheng&family=Noto+Sans+SC:wght@300&family=Noto+Serif+SC:wght@300&family=Zhi+Mang+Xing&display=swap" rel="stylesheet">

    </body>
</html>
